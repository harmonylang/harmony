#!/bin/sh
: This is the Harmony compiler.

true <<'++COPYRIGHT++'
Copyright (C) 2020  Robbert van Renesse
	
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived
from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
++COPYRIGHT++

if python3 -V >/dev/null 2>&1
then
	PYTHON=python3
elif python -V >/dev/null 2>&1
then
	v=`python -V`
	case $v in
	"3."*) PYTHON=python ;;
	*) echo 'harmony requires python3 to run' >&2; exit 1
	esac
else
	echo 'harmony requires python3 to run' >&2; exit 1
fi

: DO NOT EDIT THE PYTHON SOURCE CODE.  IT IS AUTOMATICALLY SOURCED
: FROM harmony.py

$PYTHON - $@ <<'++++++'
"""
	This is the Harmony compiler and model checker.

    Copyright (C) 2020, 2021  Robbert van Renesse

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
"""

version = [
1,1, 1506

]

internal_modules = {
#############################
#     START OF MODULES      #
#############################

    "synch": """import list
import bag

def tas(lk):
    atomic:
        result = !lk
        !lk = True

def cas(p, old, new):
    atomic:
        result = !p == old
        if result:
            !p = new

def BinSema(acquired):
    result = acquired

def Lock():
    result = BinSema(False)

def acquired(binsema):
    result = !binsema

def acquire(binsema):
    await not tas(binsema)

def release(binsema):
    atomic:
        assert !binsema
        !binsema = False
    
def held(binsema):
    result = !binsema

def Condition():
    result = bag.empty()

def wait(c, lk):
    let blocked, cnt, ctx = True, 0, get_context():
        atomic:
            cnt = bag.count(!c, ctx)
            bag.add(c, ctx)
            !lk = False
        while blocked:
            atomic:
                if (not !lk) and (bag.count(!c, ctx) <= cnt):
                    !lk = True
                    blocked = False

def notify(c):
    atomic:
        if !c != bag.empty():
            bag.remove(c, bag.bchoose(!c))

def notifyAll(c):
    !c = bag.empty()

def Semaphore(cnt):
    result = cnt

def P(sema):
    let blocked = True:
        while blocked:
            atomic:
                if !sema > 0:
                    !sema -= 1
                    blocked = False
def V(sema):
    atomic: !sema += 1
    
def Queue():
    result = []

def get(q):
    let blocked = True:
        while blocked:
            atomic:
                if !q != []:
                    result = list.head(!q)
                    !q = list.tail(!q)
                    blocked = False

def put(q, item):
    atomic: !q = list.append(!q, item)
""",
    "synchS": """import list

def tas(lk):
    atomic:
        result = !lk
        !lk = True

def cas(p, old, new):
    atomic:
        result = !p == old
        if result:
            !p = new

def BinSema(acquired):
    result = { .acquired: acquired, .suspended: [] }

def Lock():
    result = BinSema(False)

def acquire(binsema):
    atomic:
        if binsema->acquired:
            stop binsema->suspended[len binsema->suspended]
            assert binsema->acquired
        else:
            binsema->acquired = True

def release(binsema):
    atomic:
        assert binsema->acquired
        if binsema->suspended == []:
            binsema->acquired = False
        else:
            go (list.head(binsema->suspended)) ()
            binsema->suspended = list.tail(binsema->suspended)

def held(binsema):
    result = binsema->acquired

def Condition():
    result = []

def wait(c, lk):
    atomic:
        release(lk)
        stop (!c)[len !c]
    acquire(lk)

def notify(c):
    atomic:
        if !c != []:
            go (list.head(!c)) ()
            !c = list.tail(!c)
        
def notifyAll(c):
    atomic:
        while !c != []:
            go (list.head(!c)) ()
            !c = list.tail(!c)
        
def Semaphore(cnt):
    result = { .count: cnt, .waiters: [] }

def P(sema):
    atomic:
        if sema->count > 0:
            sema->count -= 1
        else:
            stop sema->waiters[len sema->waiters]
        
def V(sema):
    atomic:
        let cnt, waiters = sema->count, sema->waiters:
            if waiters != []:
                assert cnt == 0
                go (waiters[0]) ()
                sema->waiters = list.tail(waiters)
            else:
                sema->count = cnt + 1

def Queue():
    result = { .list: [], .waiters: [] }

def get(q):
    atomic:
        if q->list == []:
            stop q->waiters[len q->waiters]
        
        result = list.head(q->list)
        q->list = list.tail(q->list)

def put(q, item):
    atomic:
        q->list = list.append(q->list, item)
        let waiters = q->waiters:
            if waiters != []:
                go (waiters[0]) item
                q->waiters = list.tail(waiters)
""",
    "list": """# return s[b:e]
def subseq(s, b, e):
    result = [ s[x] for x in {b..e-1} ]

def append(s, e):
    result = s + [e,]

def head(s):
    result = s[0]

def tail(s):
    result = subseq(s, 1, len(s))

# sum of a list or set
def sum(a):
    result = 0
    for v in a:
        result += v

# convert list (or values of a dict) to a set
def set(a):
    result = { v for v in a }

# convert set into a (sorted) list
def list(a):
    result = [ v for v in a ]

# convert values of a dictionary into a list
def values(d):
    result = [ d[k] for k in keys d ]

# like Python .items()
def items(d):
    result = [ (k, d[k]) for k in keys d ]

# like Python enumerate()
def enumerate(d):
    result = []
    let index = 0:
        for k in keys d:
            result += [ (index, d[k]), ]
            index += 1
        
# quicksort of a list
def qsort(a):
    if a == []:
        result = []
    else:
        let (pivot, rest) = head(a), tail(a)
        let lower = [ v for v in rest where v < pivot ]
        let higher = [ v for v in rest where v >= pivot ]:
            result = qsort(lower) + [pivot,] + qsort(higher)

# like Python sorted()
def sorted(d):
    result = qsort(list(d))

# like Python reversed()
def reversed(d):
    let n = len(d):
        result = [ d[n-i] for i in { 1..n } ]
""",
    "bag": """def empty():
    result = []

def fromSet(s):
    result = { elt:1 for elt in s }

def fromList(a):
    result = []
    for i in keys(a):
        if a[i] in keys(result):
            result[a[i]] += 1
        else:
            result[a[i]] = 1

def count(bg, elt):
    if elt in keys(bg):
        result = bg[elt]
    else:
        result = 0

def bchoose(bg):
    # TODO.  Assert that no elements are mapped to 0
    assert 0 not in { bg[k] for k in keys(bg) }
    result = choose(keys(bg))

def add(pb, elt):
    if elt in keys(!pb):
        (!pb)[elt] += 1
    else:
        (!pb)[elt] = 1

def remove(pb, elt):
    if (elt in keys(!pb)) and ((!pb)[elt] > 0):
        (!pb)[elt] -= 1
    
    if (!pb)[elt] <= 0:
        del (!pb)[elt]
""",
    "set": """def issubset(s, t):
    result = (s & t) == s

def issuperset(s, t):
    result = (s & t) == t
""",
    "alloc": """pool = []
next = 0

def malloc(v):
    atomic:
        pool[next] = v
        result = ?pool[next]
        next += 1

# Commented out code tests for bad frees, but can lead to data races
def free(r):
    atomic:
       # let poolcopy = pool:
            del !r
       #    assert poolcopy != pool, .bad_free

def leak_check():
    assert pool == [], .alloc_leak
""",


#############################
#      END OF MODULES       #
#############################
}

charm_src = r"""
#define _GNU_SOURCE

// Downloaded from https://github.com/exebook/hashdict.c

#ifndef HASHDICTC
#define HASHDICTC
#include <stdlib.h> /* malloc/calloc */
#include <stdint.h> /* uint32_t */
#include <string.h> /* memcpy/memcmp */

#define HASHDICT_VALUE_TYPE void*

typedef void (*enumFunc)(void *env, const void *key, unsigned int key_size,
                                HASHDICT_VALUE_TYPE value);

struct keynode {
	struct keynode *next;
	char *key;
	unsigned int len;
	HASHDICT_VALUE_TYPE value;
};
		
struct dict {
	struct keynode **table;
	int length, count;
	double growth_treshold;
	double growth_factor;
};

struct dict *dict_new(int initial_size);
void dict_delete(struct dict *dict);
void *dict_lookup(struct dict *dict, const void *key, unsigned int keylen);
void **dict_insert(struct dict *dict, const void *key, unsigned int keylen);
void *dict_find(struct dict *dict, const void *key, unsigned int keylen);
void *dict_retrieve(const void *p, int *psize);
void dict_iter(struct dict *dict, enumFunc f, void *user);
#endif

#ifndef JSON_H
#define JSON_H

typedef struct json_buf {
    char *base;
    int len;
} json_buf_t;

struct json_value { 
	enum { JV_ATOM, JV_MAP, JV_LIST } type;
	union {
		json_buf_t atom;
		struct dict *map;		// maps atoms to json_values
		struct {
			struct json_value **vals;
			unsigned int nvals;
		} list;
	} u;
};

struct json_value *json_parse_value(json_buf_t *buf);
struct json_value *json_string(char *s, unsigned int len);
void json_value_free(struct json_value *jv);
void json_dump(struct json_value *jv);
void json_list_append(struct json_value *list, struct json_value *jv);
void json_map_append(struct json_value *map, json_buf_t key, struct json_value *jv);
char *json_lookup_string(struct dict *map, char *key);
struct json_value *json_lookup_map(struct dict *map, char *key);
struct json_value *json_lookup_value(struct dict *map, char *key);

#endif /* JSON_H */

#include <stdint.h>
#include <stdbool.h>

#ifndef HARMONY_COMBINE
#include "hashdict.h"
#include "json.h"
#endif

#define new_alloc(t)	(t *) calloc(1, sizeof(t))

#define CALLTYPE_PROCESS       1
#define CALLTYPE_NORMAL        2
#define CALLTYPE_INTERRUPT     3

struct queue *queue_init(void);
void queue_enqueue(struct queue *queue, void *item);
void queue_prepend(struct queue *queue, void *item);
bool queue_dequeue(struct queue *queue, void **item);
bool queue_empty(struct queue *queue);
void queue_release(struct queue *queue);
void queue_cleanup(void);

void *mcopy(void *p, unsigned int size);
char *scopy(char *s);
void mfree(void *p);

unsigned long to_ulong(const char *p, int len);

void ops_init();
struct op_info *ops_get(char *opname, int size);

struct code {
    struct op_info *oi;
    const void *env;
    bool choose, load, store, del, breakable;
};

struct context {     // context value
    uint64_t name;        // name of method
    uint64_t entry;       // entry point of main method
    uint64_t arg;         // argument provided to spawn
    uint64_t this;        // thread-local state
    uint64_t vars;        // local variables
    uint64_t trap_pc;     // trap program counter
    uint64_t trap_arg;    // trap argument
    uint64_t failure;     // atom value describing failure, or 0 if no failure
    int pc;               // program counter
    int fp;               // frame pointer
    int atomic;           // atomic counter
    int readonly;         // readonly counter
    bool interruptlevel;  // interrupt level
    bool stopped;         // context is stopped
    bool terminated;      // context has terminated
    int sp;               // stack size
    uint64_t stack[0];
};

struct state {
    uint64_t vars;        // shared variables
    uint64_t seqs;        // sequential variables
    uint64_t choosing;    // context that is choosing if non-zero
    uint64_t ctxbag;      // bag of running contexts
    uint64_t stopbag;     // bag of stopped contexts
    uint64_t termbag;     // bag of terminated contexts
    uint64_t invariants;  // set of invariants that must hold
};

struct op_info {
    const char *name;
    void *(*init)(struct dict *);
    void (*op)(const void *env, struct state *state, struct context **pctx);
};

void value_init();
uint64_t value_from_json(struct dict *map);
int value_cmp(uint64_t v1, uint64_t v2);
void *value_get(uint64_t v, int *size);
void *value_copy(uint64_t v, int *size);
uint64_t value_put_atom(const void *p, int size);
uint64_t value_put_set(void *p, int size);
uint64_t value_put_dict(void *p, int size);
uint64_t value_put_address(void *p, int size);
uint64_t value_put_context(struct context *ctx);
char *value_string(uint64_t v);
char *indices_string(const uint64_t *vec, int size);
char *value_json(uint64_t v);

#define VALUE_BITS      3
#define VALUE_MASK      ((uint64_t) ((1 << VALUE_BITS) - 1))

#define VALUE_BOOL      0
#define VALUE_INT       1
#define VALUE_ATOM      2
#define VALUE_PC        3
#define VALUE_DICT      4
#define VALUE_SET       5
#define VALUE_ADDRESS   6
#define VALUE_CONTEXT   7

#define VALUE_FALSE     VALUE_BOOL
#define VALUE_TRUE      ((1 << VALUE_BITS) | VALUE_BOOL)

#define VALUE_MAX   ((int64_t) ((~(uint64_t)0) >> (VALUE_BITS + 1)))
#define VALUE_MIN   ((int64_t) ((~(uint64_t)0) << (64 - (VALUE_BITS + 1))))

uint64_t dict_store(uint64_t dict, uint64_t key, uint64_t value);
uint64_t dict_load(uint64_t dict, uint64_t key);
bool dict_tryload(uint64_t dict, uint64_t key, uint64_t *result);
uint64_t dict_remove(uint64_t dict, uint64_t key);
uint64_t bag_add(uint64_t bag, uint64_t v);
void ctx_push(struct context **pctx, uint64_t v);

struct access_info {
    struct access_info *next; // linked list maintenance
    uint64_t *indices;        // address of load/store
    int n;                    // length of address
    bool load;                // store or del if false
    int pc;                   // for debugging
    int multiplicity;         // #identical contexts
    int atomic;               // atomic counter
};

struct env_Cut {
    uint64_t set, var;
};

struct env_DelVar {
    uint64_t name;
};

struct env_Frame {
    uint64_t name;
    struct var_tree *args;
};

struct env_IncVar {
    uint64_t name;
};

struct env_Invariant {
    int cnt;
};

struct env_Jump {
    int pc;
};

struct env_JumpCond {
    uint64_t cond;
    int pc;
};

struct env_Load {
    uint64_t *indices;
    int n;
};

struct env_LoadVar {
    uint64_t name;
};

struct env_Move {
    int offset;
};

struct env_Nary {
    int arity;
    struct f_info *fi;
};

struct env_Push {
    uint64_t value;
};

struct env_Split {
    int count;
};

struct env_Stop {
    uint64_t *indices;
    int n;
};

struct env_Store {
    uint64_t *indices;
    int n;
};

struct env_StoreVar {
    struct var_tree *args;
};

uint64_t ctx_failure(struct context *ctx, char *fmt, ...);
void panic(char *s);
void ext_Del(const void *env, struct state *state, struct context **pctx,
                                                        struct access_info *ai);
void ext_Load(const void *env, struct state *state, struct context **pctx,
                                                        struct access_info *ai);
void ext_Store(const void *env, struct state *state, struct context **pctx,
                                                        struct access_info *ai);

#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <assert.h>

#ifndef HARMONY_COMBINE
#include "global.h"
#endif

#define CHUNKSIZE   (1 << 12)

struct combined {           // combination of current state and current context
    struct state state;
    struct context context;
};

struct component {
    bool good;              // terminating or out-going edge
    int size;               // #states
    int representative;     // lowest numbered state in the component
};

struct edge {
    struct edge *next;       // linked list maintenance
    uint64_t ctx, choice;    // ctx that made the microstep, choice if any
    bool interrupt;          // set if state change is an interrupt
    struct node *node;       // resulting node (state)
    uint64_t after;          // resulting context
    int weight;              // 1 if context switch; 0 otherwise
    struct access_info *ai;  // to detect data races
};

struct node {
    // Information about state
    struct state *state;    // state corresponding to this node
    int id;                 // nodes are numbered starting from 0
    struct edge *fwd;       // forward edges
    struct edge *bwd;       // backward edges

    // How to get here from parent node
    struct node *parent;    // shortest path to initial state
    int len;                // length of path to initial state
    uint64_t before;        // context before state change
    uint64_t after;         // context after state change (current context)
    uint64_t choice;        // choice made if any
    bool interrupt;         // set if gotten here by interrupt

    // SCC
    bool visited;           // for Kosaraju algorithm
    unsigned int component; // strongly connected component id
};

struct failure {
    enum { FAIL_SAFETY, FAIL_INVARIANT, FAIL_TERMINATION, FAIL_BUSYWAIT, FAIL_RACE } type;
    struct node *node;      // failed state
    uint64_t choice;        // choice if any
    uint64_t address;       // in case of data race
};

struct code *code;
int code_len;
bool has_synch_module = false;

static struct node **graph;         // vector of all nodes
static int graph_size;              // to create node identifiers
static int graph_alloc;             // size allocated
static struct queue *failures;      // queue of "struct failure"  (TODO: make part of struct node "issues")
static struct queue *warnings;      // queue of "struct failure"  (TODO: make part of struct node "issues")
static uint64_t *processes;         // list of contexts of processes
static int nprocesses;              // the number of processes in the list
static double lasttime;             // since last report printed
static int timecnt;                 // to reduce time overhead
static int enqueued;                // #states enqueued
static int dequeued;                // #states dequeued
static bool dumpfirst;              // for json dumping
static struct access_info *ai_free; // free list of access_info structures

static void graph_add(struct node *node){
    node->id = graph_size;
    if (graph_size >= graph_alloc) {
        graph_alloc = (graph_alloc + 1) * 2;
        graph = realloc(graph, (graph_alloc * sizeof(struct node *)));
    }
    graph[graph_size++] = node;
}

static void code_get(struct json_value *jv){
    assert(jv->type == JV_MAP);
    struct json_value *op = dict_lookup(jv->u.map, "op", 2);
    assert(op->type == JV_ATOM);
    struct op_info *oi = ops_get(op->u.atom.base, op->u.atom.len);
    if (oi == NULL) {
        fprintf(stderr, "Unknown HVM instruction: %.*s\n", op->u.atom.len, op->u.atom.base);
        exit(1);
    }
    code = realloc(code, (code_len + 1) * 2 * sizeof(struct code));
    struct code *c = &code[code_len++];
    c->oi = oi;
    c->env = (*oi->init)(jv->u.map);
    c->choose = strcmp(oi->name, "Choose") == 0;
    c->load = strcmp(oi->name, "Load") == 0;
    c->store = strcmp(oi->name, "Store") == 0;
    c->del = strcmp(oi->name, "Del") == 0;
    c->breakable = c->load || c->store || c->del ||
                        strcmp(oi->name, "AtomicInc") == 0;
}

bool invariant_check(struct state *state, struct context **pctx, int end){
    assert((*pctx)->sp == 0);
    assert((*pctx)->failure == 0);
    (*pctx)->pc++;
    while ((*pctx)->pc != end) {
        struct op_info *oi = code[(*pctx)->pc].oi;
        int oldpc = (*pctx)->pc;
        (*oi->op)(code[oldpc].env, state, pctx);
        if ((*pctx)->failure != 0) {
            (*pctx)->sp = 0;
            return false;
        }
        assert((*pctx)->pc != oldpc);
        assert(!(*pctx)->terminated);
    }
    assert((*pctx)->sp == 1);
    (*pctx)->sp = 0;
    assert((*pctx)->fp == 0);
    uint64_t b = (*pctx)->stack[0];
    assert((b & VALUE_MASK) == VALUE_BOOL);
    return b >> VALUE_BITS;
}

void check_invariants(struct node *node, struct context **pctx){
    struct state *state = node->state;
    extern int invariant_cnt(const void *env);

    assert((state->invariants & VALUE_MASK) == VALUE_SET);
    assert((*pctx)->sp == 0);
    int size;
    uint64_t *vals = value_get(state->invariants, &size);
    size /= sizeof(uint64_t);
    for (int i = 0; i < size; i++) {
        assert((vals[i] & VALUE_MASK) == VALUE_PC);
        (*pctx)->pc = vals[i] >> VALUE_BITS;
        assert(strcmp(code[(*pctx)->pc].oi->name, "Invariant") == 0);
        int cnt = invariant_cnt(code[(*pctx)->pc].env);
        bool b = invariant_check(state, pctx, (*pctx)->pc + cnt);
        if ((*pctx)->failure != 0) {
            printf("Invariant failed: %s\n", value_string((*pctx)->failure));
            b = false;
        }
        if (!b) {
            struct failure *f = new_alloc(struct failure);
            f->type = FAIL_INVARIANT;
            f->choice = node->choice;
            f->node = node;
            queue_enqueue(failures, f);
        }
    }
}

// For tracking data races
struct access_info *ai_alloc(int multiplicity, int atomic, int pc){
    struct access_info *ai;

    if ((ai = ai_free) == 0) {
        ai = calloc(1, sizeof(*ai));
    }
    else {
        ai_free = ai->next;
    }
    ai->multiplicity = multiplicity;
    ai->atomic = atomic;
    ai->pc = pc;
    return ai;
}

void onestep(struct node *node, uint64_t ctx, uint64_t choice, bool interrupt,
        struct dict *visited, struct queue *todo, struct context **pinv_ctx,
        bool infloop_detect, int multiplicity, double timeout){
    // Make a copy of the state
    struct state *sc = new_alloc(struct state);
    memcpy(sc, node->state, sizeof(*sc));
    sc->choosing = 0;

    // Make a copy of the context
    struct context *cc = value_copy(ctx, NULL);
    assert(!cc->terminated);
    assert(cc->failure == 0);

    if (false) {
        printf("ONESTEP %"PRIx64" %"PRIx64"\n", ctx, sc->ctxbag);
    }

    // See if we should also try an interrupt.
    if (interrupt) {
        extern void interrupt_invoke(struct context **pctx);
		assert(cc->trap_pc != 0);
        interrupt_invoke(&cc);
    }
    else if (sc->choosing == 0 && cc->trap_pc != 0 && !cc->interruptlevel) {
        onestep(node, ctx, choice, true, visited, todo, pinv_ctx, infloop_detect, multiplicity, timeout);
    }

    // Copy the choice
    uint64_t choice_copy = choice;

    bool choosing = false, infinite_loop = false;
    struct dict *infloop = NULL;        // infinite loop detector
    struct access_info *ai_list = NULL;
    for (int loopcnt = 0;; loopcnt++) {
        int pc = cc->pc;

        if (timecnt-- == 0) {
            struct timeval tv;
            gettimeofday(&tv, NULL);
            double now = tv.tv_sec + (double) tv.tv_usec / 1000000;
            if (now - lasttime > 1) {
                if (lasttime != 0) {
                    char *p = value_string(cc->name);
                    printf("%s pc=%d states=%d queue=%d\n",
                            p, cc->pc, enqueued, enqueued - dequeued);
                    free(p);
                }
                lasttime = now;
                if (now > timeout) {
                    fprintf(stderr, "charm: timeout exceeded\n");
                    exit(1);
                }
            }
            timecnt = 1;
        }

        struct op_info *oi = code[pc].oi;
        if (code[pc].choose) {
            cc->stack[cc->sp - 1] = choice;
            cc->pc++;
        }
        else {
            if (code[pc].load || code[pc].store || code[pc].del) {
                struct access_info *ai = ai_alloc(multiplicity, cc->atomic, pc);
                if (code[pc].load)
                    ext_Load(code[pc].env, sc, &cc, ai);
                else if (code[pc].store)
                    ext_Store(code[pc].env, sc, &cc, ai);
                else
                    ext_Del(code[pc].env, sc, &cc, ai);
                ai->next = ai_list;
                ai_list = ai;
            }
            else {
                (*oi->op)(code[pc].env, sc, &cc);
            }
        }
		assert(cc->pc >= 0);
		assert(cc->pc < code_len);

        if (!cc->terminated && cc->failure == 0 && (infloop_detect || loopcnt > 1000)) {
            if (infloop == NULL) {
                infloop = dict_new(0);
            }

            int stacksize = cc->sp * sizeof(uint64_t);
            int combosize = sizeof(struct combined) + stacksize;
            struct combined *combo = calloc(1, combosize);
            combo->state = *sc;
            memcpy(&combo->context, cc, sizeof(*cc) + stacksize);
            void **p = dict_insert(infloop, combo, combosize);
            free(combo);
            if (*p == (void *) 0) {
                *p = (void *) 1;
            }
            else if (infloop_detect) {
                cc->failure = value_put_atom("infinite loop", 13);
                infinite_loop = true;
            }
            else {
                // start over, as twostep does not have loopcnt optimization
                onestep(node, ctx, choice_copy, interrupt, visited, todo, pinv_ctx, true, multiplicity, timeout);
                free(cc);
                free(sc);
                return;
            }
        }

        if (cc->terminated || cc->failure != 0 || cc->stopped) {
            break;
        }
        if (cc->pc == pc) {
            fprintf(stderr, ">>> %s\n", oi->name);
        }
        assert(cc->pc != pc);
		assert(cc->pc >= 0);
		assert(cc->pc < code_len);

        /* Peek at the next instruction.
         */
        oi = code[cc->pc].oi;
        if (code[cc->pc].choose) {
            assert(cc->sp > 0);
            if (cc->readonly > 0) {
                ctx_failure(cc, "can't choose in assertion or invariant");
                break;
            }
            uint64_t s = cc->stack[cc->sp - 1];
            if ((s & VALUE_MASK) != VALUE_SET) {
                ctx_failure(cc, "choose operation requires a set");
                break;
            }
            int size;
            uint64_t *vals = value_get(s, &size);
            size /= sizeof(uint64_t);
            if (size == 0) {
                ctx_failure(cc, "choose operation requires a non-empty set");
                break;
            }
            if (size == 1) {            // TODO.  This optimization is probably not worth it
                choice = vals[0];
            }
            else {
                choosing = true;
                break;
            }
        }

        if (cc->atomic == 0 && sc->ctxbag != VALUE_DICT &&
                                    code[cc->pc].breakable) {
            break;
        }
    }
    
    if (infloop != NULL) {
        dict_delete(infloop);
    }

    // Remove old context from the bag
    uint64_t count = dict_load(sc->ctxbag, ctx);
    assert((count & VALUE_MASK) == VALUE_INT);
    count -= 1 << VALUE_BITS;
    if (count == VALUE_INT) {
        sc->ctxbag = dict_remove(sc->ctxbag, ctx);
    }
    else {
        sc->ctxbag = dict_store(sc->ctxbag, ctx, count);
    }

    // Store new context in value directory.  Must be immutable now.
    uint64_t after = value_put_context(cc);

    // If choosing, save in state
    if (choosing) {
        assert(!cc->terminated);
        sc->choosing = after;
    }

    // Add new context to state unless it's terminated or stopped
    if (cc->stopped) {
        sc->stopbag = bag_add(sc->stopbag, after);
    }
    else if (!cc->terminated) {
        sc->ctxbag = bag_add(sc->ctxbag, after);
    }

    // Weight of this step
    int weight = ctx == node->after ? 0 : 1;

    // See if this new state was already seen before.
    void **p = dict_insert(visited, sc, sizeof(*sc));
    struct node *next;
    if ((next = *p) == NULL) {
        *p = next = new_alloc(struct node);
        next->parent = node;
        next->state = sc;               // TODO: duplicate value
        next->before = ctx;
        next->choice = choice_copy;
        next->interrupt = interrupt;
        next->after = after;
        next->len = node->len + weight;
        graph_add(next);

        if (sc->choosing == 0 && sc->invariants != VALUE_SET) {
            check_invariants(next, pinv_ctx);
        }

        if (sc->ctxbag != VALUE_DICT && cc->failure == 0
                            && queue_empty(failures)) {
            if (weight == 0) {
                queue_prepend(todo, next);
            }
            else {
                queue_enqueue(todo, next);
            }
            enqueued++;
        }
    }
    else {
        free(sc);

        if (next->len > node->len + weight) {
            next->parent = node;
            next->before = ctx;
            next->after = after;
            next->choice = choice_copy;
            next->len = node->len + weight;
        }
    }

    // Add a forward edge from node to next.
    struct edge *fwd = new_alloc(struct edge);
    fwd->ctx = ctx;
    fwd->choice = choice_copy;
    fwd->interrupt = interrupt;
    fwd->node = next;
    fwd->weight = weight;
    fwd->next = node->fwd;
    fwd->after = after;
    fwd->ai = ai_list;
    node->fwd = fwd;

    // Add a backward edge from next to node.
    struct edge *bwd = new_alloc(struct edge);
    bwd->ctx = ctx;
    bwd->choice = choice_copy;
    fwd->interrupt = interrupt;
    bwd->node = node;
    bwd->weight = weight;
    bwd->next = next->bwd;
    bwd->after = after;
    bwd->ai = ai_list;
    next->bwd = bwd;

    if (cc->failure != 0) {
        struct failure *f = new_alloc(struct failure);
        f->type = infinite_loop ? FAIL_TERMINATION : FAIL_SAFETY;
        f->choice = choice_copy;
        f->node = next;
        queue_enqueue(failures, f);
    }

    free(cc);
}

void print_vars(FILE *file, uint64_t v){
    assert((v & VALUE_MASK) == VALUE_DICT);
    int size;
    uint64_t *vars = value_get(v, &size);
    size /= sizeof(uint64_t);
    fprintf(file, "{");
    for (int i = 0; i < size; i += 2) {
        if (i > 0) {
            fprintf(file, ",");
        }
        char *k = value_string(vars[i]);
        char *v = value_json(vars[i+1]);
        fprintf(file, " \"%s\": %s", k+1, v);
        free(k);
        free(v);
    }
    fprintf(file, " }");
}

bool print_trace(FILE *file, struct context *ctx, int pc, int fp, uint64_t vars){
    if (fp == 0) {
        return false;
    }
    assert(fp >= 4);

	int level = 0, orig_pc = pc;
    if (strcmp(code[pc].oi->name, "Frame") == 0) {
        uint64_t ct = ctx->stack[ctx->sp - 2];
        assert((ct & VALUE_MASK) == VALUE_INT);
        switch (ct >> VALUE_BITS) {
        case CALLTYPE_PROCESS:
            pc++;
            break;
        case CALLTYPE_INTERRUPT:
        case CALLTYPE_NORMAL:
            {
                uint64_t retaddr = ctx->stack[ctx->sp - 3];
                assert((retaddr & VALUE_MASK) == VALUE_PC);
                pc = retaddr >> VALUE_BITS;
            }
            break;
        default:
            fprintf(stderr, "call type: %"PRIx64" %d %d %d\n", ct, ctx->sp, ctx->fp, ctx->pc);
            // panic("print_trace: bad call type 1");
        }
    }
    while (--pc >= 0) {
        if (strcmp(code[pc].oi->name, "Return") == 0) {
			level++;
		}
        else if (strcmp(code[pc].oi->name, "Frame") == 0) {
			if (level == 0) {
				if (fp >= 5) {
                    assert((ctx->stack[fp - 5] & VALUE_MASK) == VALUE_PC);
					int npc = ctx->stack[fp - 5] >> VALUE_BITS;
					uint64_t nvars = ctx->stack[fp - 2];
					int nfp = ctx->stack[fp - 1] >> VALUE_BITS;
					if (print_trace(file, ctx, npc, nfp, nvars)) {
                        fprintf(file, ",\n");
                    }
				}
				fprintf(file, "            {\n");
				fprintf(file, "              \"pc\": \"%d\",\n", orig_pc);
				fprintf(file, "              \"xpc\": \"%d\",\n", pc);

				const struct env_Frame *ef = code[pc].env;
				char *s = value_string(ef->name), *a = NULL;
                a = value_string(ctx->stack[fp - 3]);
				if (*a == '(') {
					fprintf(file, "              \"method\": \"%s%s\",\n", s + 1, a);
				}
				else {
					fprintf(file, "              \"method\": \"%s(%s)\",\n", s + 1, a);
				}

                uint64_t ct = ctx->stack[fp - 4];
                assert((ct & VALUE_MASK) == VALUE_INT);
                switch (ct >> VALUE_BITS) {
                case CALLTYPE_PROCESS:
                    fprintf(file, "              \"calltype\": \"process\",\n");
                    break;
                case CALLTYPE_NORMAL:
                    fprintf(file, "              \"calltype\": \"normal\",\n");
                    break;
                case CALLTYPE_INTERRUPT:
                    fprintf(file, "              \"calltype\": \"interrupt\",\n");
                    break;
                default:
                    panic("print_trace: bad call type 2");
                }

				free(s);
				free(a);
				fprintf(file, "              \"vars\": ");
				print_vars(file, vars);
				fprintf(file, "\n");
				fprintf(file, "            }");
				return true;
			}
            else {
                assert(level > 0);
                level--;
            }
        }
    }
    return false;
}

char *ctx_status(struct node *node, uint64_t ctx) {
    if (node->state->choosing == ctx) {
        return "choosing";
    }
    while (node->state->choosing != 0) {
        node = node->parent;
    }
    struct edge *edge;
    for (edge = node->fwd; edge != NULL; edge = edge->next) {
        if (edge->ctx == ctx) {
            break;
        }
    };
    if (edge != NULL && edge->node == node) {
        return "blocked";
    }
    return "runnable";
}

void print_context(FILE *file, uint64_t ctx, int tid, struct node *node){
    char *s, *a;

    fprintf(file, "        {\n");
    fprintf(file, "          \"tid\": \"%d\",\n", tid);
    fprintf(file, "          \"yhash\": \"%"PRIx64"\",\n", ctx);

    struct context *c = value_get(ctx, NULL);

    s = value_string(c->name);
    a = value_string(c->arg);
    if (*a == '(') {
        fprintf(file, "          \"name\": \"%s%s\",\n", s + 1, a);
    }
    else {
        fprintf(file, "          \"name\": \"%s(%s)\",\n", s + 1, a);
    }
    free(s);
    free(a);

    // assert((c->entry & VALUE_MASK) == VALUE_PC);   TODO
    fprintf(file, "          \"entry\": \"%d\",\n", (int) (c->entry >> VALUE_BITS));

    fprintf(file, "          \"pc\": \"%d\",\n", c->pc);
    fprintf(file, "          \"fp\": \"%d\",\n", c->fp);

#ifdef notdef
    {
        fprintf(file, "STACK %d:\n", c->fp);
        for (int x = 0; x < c->sp; x++) {
            fprintf(file, "    %d: %s\n", x, value_string(c->stack[x]));
        }
    }
#endif

    fprintf(file, "          \"trace\": [\n");
    print_trace(file, c, c->pc, c->fp, c->vars);
    fprintf(file, "\n");
    fprintf(file, "          ],\n");

    if (c->failure != 0) {
        s = value_string(c->failure);
        fprintf(file, "          \"failure\": \"%s\",\n", s + 1);
        free(s);
    }

    if (c->trap_pc != 0) {
        s = value_string(c->trap_pc);
        a = value_string(c->trap_arg);
        if (*a == '(') {
            fprintf(file, "          \"trap\": \"%s%s\",\n", s, a);
        }
        else {
            fprintf(file, "          \"trap\": \"%s(%s)\",\n", s, a);
        }
        free(s);
    }

    if (c->interruptlevel) {
        fprintf(file, "          \"interruptlevel\": \"1\",\n");
    }

    if (c->atomic != 0) {
        fprintf(file, "          \"atomic\": \"%d\",\n", c->atomic);
    }
    if (c->readonly != 0) {
        fprintf(file, "          \"readonly\": \"%d\",\n", c->readonly);
    }

    if (c->terminated) {
        fprintf(file, "          \"mode\": \"terminated\",\n");
    }
    else if (c->failure != 0) {
        fprintf(file, "          \"mode\": \"failed\",\n");
    }
    else if (c->stopped) {
        fprintf(file, "          \"mode\": \"stopped\",\n");
    }
    else {
        fprintf(file, "          \"mode\": \"%s\",\n", ctx_status(node, ctx));
    }

#ifdef notdef
    fprintf(file, "          \"stack\": [\n");
    for (int i = 0; i < c->sp; i++) {
        s = value_string(c->stack[i]);
        if (i < c->sp - 1) {
            fprintf(file, "            \"%s\",\n", s);
        }
        else {
            fprintf(file, "            \"%s\"\n", s);
        }
        free(s);
    }
    fprintf(file, "          ],\n");
#endif

    s = value_json(c->this);
    fprintf(file, "          \"this\": %s\n", s);
    free(s);

    fprintf(file, "        }");
}

void print_state(FILE *file, struct node *node){
#ifdef notdef
    fprintf(file, "      \"shared\": ");
    print_vars(file, node->state->vars);
    fprintf(file, ",\n");
#endif

    struct state *state = node->state;
    extern int invariant_cnt(const void *env);
    struct context *inv_ctx = new_alloc(struct context);
    // uint64_t inv_nv = value_put_atom("name", 4);
    // uint64_t inv_tv = value_put_atom("tag", 3);
    inv_ctx->name = value_put_atom("__invariant__", 13);
    inv_ctx->arg = VALUE_DICT;
    inv_ctx->this = VALUE_DICT;
    inv_ctx->vars = VALUE_DICT;
    inv_ctx->atomic = inv_ctx->readonly = 1;
    inv_ctx->interruptlevel = false;

    fprintf(file, "      \"invfails\": [");
    assert((state->invariants & VALUE_MASK) == VALUE_SET);
    int size;
    uint64_t *vals = value_get(state->invariants, &size);
    size /= sizeof(uint64_t);
    int nfailures = 0;
    for (int i = 0; i < size; i++) {
        assert((vals[i] & VALUE_MASK) == VALUE_PC);
        inv_ctx->pc = vals[i] >> VALUE_BITS;
        assert(strcmp(code[inv_ctx->pc].oi->name, "Invariant") == 0);
        int cnt = invariant_cnt(code[inv_ctx->pc].env);
        bool b = invariant_check(state, &inv_ctx, inv_ctx->pc + cnt);
        if (inv_ctx->failure != 0) {
            b = false;
        }
        if (!b) {
            if (nfailures != 0) {
                fprintf(file, ",");
            }
            fprintf(file, "\n        {\n");
            fprintf(file, "          \"pc\": \"%"PRIu64"\",\n", vals[i] >> VALUE_BITS);
            if (inv_ctx->failure == 0) {
                fprintf(file, "          \"reason\": \"invariant violated\"\n");
            }
            else {
                char *val = value_string(inv_ctx->failure);
                fprintf(file, "          \"reason\": \"%s\"\n", val + 1);
                free(val);
            }
            nfailures++;
            fprintf(file, "        }");
        }
    }
    fprintf(file, "\n      ],\n");
    free(inv_ctx);

    fprintf(file, "      \"contexts\": [\n");
    for (int i = 0; i < nprocesses; i++) {
        print_context(file, processes[i], i, node);
        if (i < nprocesses - 1) {
            fprintf(file, ",");
        }
        fprintf(file, "\n");
    }
    fprintf(file, "      ]\n");
}

void diff_state(FILE *file, struct state *oldstate, struct state *newstate,
                struct context *oldctx, struct context *newctx,
                bool interrupt, bool choose, uint64_t choice){
    if (dumpfirst) {
        dumpfirst = false;
    }
    else {
        fprintf(file, ",");
    }
    fprintf(file, "\n        {\n");
    if (newstate->vars != oldstate->vars) {
        fprintf(file, "          \"shared\": ");
        print_vars(file, newstate->vars);
        fprintf(file, ",\n");
    }
    if (interrupt) {
        fprintf(file, "          \"interrupt\": \"True\",\n");
    }
    if (choose) {
        char *val = value_json(choice);
        fprintf(file, "          \"choose\": %s,\n", val);
        free(val);
    }
    fprintf(file, "          \"npc\": \"%d\",\n", newctx->pc);
    if (newctx->fp != oldctx->fp) {
        fprintf(file, "          \"fp\": \"%d\",\n", newctx->fp);
        fprintf(file, "          \"trace\": [\n");
        print_trace(file, newctx, newctx->pc, newctx->fp, newctx->vars);
        fprintf(file, "\n");
        fprintf(file, "          ],\n");
    }
    if (newctx->this != oldctx->this) {
        char *val = value_json(newctx->this);
        fprintf(file, "          \"this\": %s,\n", val);
        free(val);
    }
    if (newctx->vars != oldctx->vars) {
        fprintf(file, "          \"local\": ");
        print_vars(file, newctx->vars);
        fprintf(file, ",\n");
    }
    if (newctx->atomic != oldctx->atomic) {
        fprintf(file, "          \"atomic\": \"%d\",\n", newctx->atomic);
    }
    if (newctx->readonly != oldctx->readonly) {
        fprintf(file, "          \"readonly\": \"%d\",\n", newctx->readonly);
    }
    if (newctx->interruptlevel != oldctx->interruptlevel) {
        fprintf(file, "          \"interruptlevel\": \"%d\",\n", newctx->interruptlevel ? 1 : 0);
    }
    if (newctx->failure != 0) {
        char *val = value_string(newctx->failure);
        fprintf(file, "          \"failure\": \"%s\",\n", val + 1);
        fprintf(file, "          \"mode\": \"failed\",\n");
        free(val);
    }
    else if (newctx->terminated) {
        fprintf(file, "          \"mode\": \"terminated\",\n");
    }

    int common;
    for (common = 0; common < newctx->sp && common < oldctx->sp; common++) {
        if (newctx->stack[common] != oldctx->stack[common]) {
            break;
        }
    }
    if (common < oldctx->sp) {
        fprintf(file, "          \"pop\": \"%d\",\n", oldctx->sp - common);
    }
    fprintf(file, "          \"push\": [");
    for (int i = common; i < newctx->sp; i++) {
        if (i > common) {
            fprintf(file, ",");
        }
        char *val = value_json(newctx->stack[i]);
        fprintf(file, " %s", val);
        free(val);
    }
    fprintf(file, " ],\n");

    fprintf(file, "          \"pc\": \"%d\"\n", oldctx->pc);

    fprintf(file, "        }");
}

void diff_dump(FILE *file, struct state *oldstate, struct state *newstate,
                struct context **oldctx, struct context *newctx,
                bool interrupt, bool choose, uint64_t choice){
    int newsize = sizeof(*newctx) + (newctx->sp * sizeof(uint64_t));

    if (memcmp(oldstate, newstate, sizeof(struct state)) == 0 &&
            (*oldctx)->sp == newctx->sp &&
            memcmp(*oldctx, newctx, newsize) == 0) {
        return;
    }

    // Keep track of old state and context for taking diffs
    diff_state(file, oldstate, newstate, *oldctx, newctx, interrupt, choose, choice);
    *oldstate = *newstate;
    free(*oldctx);
    *oldctx = malloc(newsize);
    memcpy(*oldctx, newctx, newsize);
}

// similar to onestep.  TODO.  Use flag to onestep?
uint64_t twostep(FILE *file, struct node *node, uint64_t ctx, uint64_t choice,
        bool interrupt, struct state *oldstate, struct context **oldctx, uint64_t nextvars){
    // Make a copy of the state
    struct state *sc = new_alloc(struct state);
    memcpy(sc, node->state, sizeof(*sc));
    sc->choosing = 0;

    // Make a copy of the context
    struct context *cc = value_copy(ctx, NULL);
    // diff_dump(file, oldstate, sc, oldctx, cc, node->interrupt);
    if (cc->terminated || cc->failure != 0) {
        free(cc);
        return ctx;
    }

    if (interrupt) {
        extern void interrupt_invoke(struct context **pctx);
		assert(cc->trap_pc != 0);
        interrupt_invoke(&cc);
        diff_dump(file, oldstate, sc, oldctx, cc, true, false, 0);
    }

    struct dict *infloop = NULL;        // infinite loop detector
    for (int loopcnt = 0;; loopcnt++) {
        int pc = cc->pc;

        struct op_info *oi = code[pc].oi;
        if (code[pc].choose) {
            cc->stack[cc->sp - 1] = choice;
            cc->pc++;
        }
        else {
            (*oi->op)(code[pc].env, sc, &cc);
        }

        if (!cc->terminated && cc->failure == 0) {
            if (infloop == NULL) {
                infloop = dict_new(0);
            }

            int stacksize = cc->sp * sizeof(uint64_t);
            int combosize = sizeof(struct combined) + stacksize;
            struct combined *combo = calloc(1, combosize);
            combo->state = *sc;
            memcpy(&combo->context, cc, sizeof(*cc) + stacksize);
            void **p = dict_insert(infloop, combo, combosize);
            free(combo);
            if (*p == (void *) 0) {
                *p = (void *) 1;
            }
            else {
                cc->failure = value_put_atom("infinite loop", 13);
            }
        }

        diff_dump(file, oldstate, sc, oldctx, cc, false, code[pc].choose, choice);
        if (cc->terminated || cc->failure != 0 || cc->stopped) {
            break;
        }
        if (cc->pc == pc) {
            fprintf(stderr, ">>> %s\n", oi->name);
        }
        assert(cc->pc != pc);

        /* Peek at the next instruction.
         */
        oi = code[cc->pc].oi;
        if (code[cc->pc].choose) {
            assert(cc->sp > 0);
            if (cc->readonly > 0) {
                ctx_failure(cc, "can't choose in assertion or invariant");
                diff_dump(file, oldstate, sc, oldctx, cc, false, code[pc].choose, choice);
                break;
            }
            uint64_t s = cc->stack[cc->sp - 1];
            if ((s & VALUE_MASK) != VALUE_SET) {
                ctx_failure(cc, "choose operation requires a set");
                diff_dump(file, oldstate, sc, oldctx, cc, false, code[pc].choose, choice);
                break;
            }
            int size;
            uint64_t *vals = value_get(s, &size);
            size /= sizeof(uint64_t);
            if (size == 0) {
                ctx_failure(cc, "choose operation requires a non-empty set");
                diff_dump(file, oldstate, sc, oldctx, cc, false, code[pc].choose, choice);
                break;
            }
            if (size == 1) {
                choice = vals[0];
            }
            else {
                break;
            }
        }

        if (cc->atomic == 0 && sc->ctxbag != VALUE_DICT &&
                code[cc->pc].breakable) {
            break;
        }
    }

    // assert(sc->vars == nextvars);
    ctx = value_put_context(cc);

    free(sc);
    free(cc);

    return ctx;
}

void path_dump(FILE *file, struct node *last, uint64_t choice,
            struct state *oldstate, struct context **oldctx, bool interrupt){
    struct node *node = last;

    last = last->parent;
    if (last->parent == NULL) {
        fprintf(file, "\n");
    }
    else {
        path_dump(file, last, last->choice, oldstate, oldctx, last->interrupt);
        fprintf(file, ",\n");
    }

    fprintf(file, "    {\n");
    fprintf(file, "      \"id\": \"%d\",\n", node->id);

    /* Find the starting context in the list of processes.
     */
    uint64_t ctx = node->before;
    int pid;
    for (pid = 0; pid < nprocesses; pid++) {
        if (processes[pid] == ctx) {
            break;
        }
    }

    struct context *context = value_get(ctx, NULL);
    assert(!context->terminated);
    char *name = value_string(context->name);
    char *arg = value_string(context->arg);
    // char *c = value_string(choice);
    fprintf(file, "      \"tid\": \"%d\",\n", pid);
    fprintf(file, "      \"xhash\": \"%"PRIx64"\",\n", ctx);
    if (*arg == '(') {
        fprintf(file, "      \"name\": \"%s%s\",\n", name + 1, arg);
    }
    else {
        fprintf(file, "      \"name\": \"%s(%s)\",\n", name + 1, arg);
    }
    // fprintf(file, "      \"choice\": \"%s\",\n", c);
    dumpfirst = true;
    fprintf(file, "      \"microsteps\": [");
    free(name);
    free(arg);
    // free(c);
    memset(*oldctx, 0, sizeof(**oldctx));
    (*oldctx)->pc = context->pc;

    // Recreate the steps
    assert(pid < nprocesses);
    processes[pid] = twostep(file, last, ctx, choice, interrupt, oldstate, oldctx, node->state->vars);
    fprintf(file, "\n      ],\n");

    /* Match each context to a process.
     */
    bool *matched = calloc(nprocesses, sizeof(bool));
    int nctxs;
    uint64_t *ctxs = value_get(node->state->ctxbag, &nctxs);
    nctxs /= sizeof(uint64_t);
    for (int i = 0; i < nctxs; i += 2) {
        assert((ctxs[i] & VALUE_MASK) == VALUE_CONTEXT);
        assert((ctxs[i+1] & VALUE_MASK) == VALUE_INT);
        int cnt = ctxs[i+1] >> VALUE_BITS;
        for (int j = 0; j < cnt; j++) {
            int k;
            for (k = 0; k < nprocesses; k++) {
                if (!matched[k] && processes[k] == ctxs[i]) {
                    matched[k] = true;
                    break;
                }
            }
            if (k == nprocesses) {
                processes = realloc(processes, (nprocesses + 1) * sizeof(uint64_t));
                matched = realloc(matched, (nprocesses + 1) * sizeof(bool));
                processes[nprocesses] = ctxs[i];
                matched[nprocesses] = true;
                nprocesses++;
            }
        }
    }
    free(matched);
  
    print_state(file, node);
    fprintf(file, "    }");
}

static struct stack {
    struct stack *next;
    struct node *node;
} *stack;

static void kosaraju_visit(struct node *node) {
    if (node->visited) {
        return;
    }
    node->visited = true;

    for (struct edge *edge = node->fwd; edge != NULL; edge = edge->next) {
        kosaraju_visit(edge->node);
    }

    // Push node
    struct stack *s = new_alloc(struct stack);
    s->node = node;
    s->next = stack;
    stack = s;
}

static void kosaraju_assign(struct node *node, int component){
    if (node->visited) {
        return;
    }
    node->visited = true;
    node->component = component;
    for (struct edge *edge = node->bwd; edge != NULL; edge = edge->next) {
        kosaraju_assign(edge->node, component);
    }
}

static int find_scc(void){
    for (int i = 0; i < graph_size; i++) {
        kosaraju_visit(graph[i]);
    }

    // make sure all nodes are marked and on the stack
    // while at it clear all the visited flags
    int count = 0;
    for (struct stack *s = stack; s != NULL; s = s->next) {
        assert(s->node->visited);
        s->node->visited = false;
        count++;
    }
    assert(count == graph_size);

    count = 0;
    while (stack != NULL) {
        // Pop
        struct stack *top = stack;
        stack = top->next;
        struct node *next = top->node;
        free(top);

        if (!next->visited) {
            kosaraju_assign(next, count++);
        }
    }
    for (int i = 0; i < graph_size; i++) {
        assert(graph[i]->visited);
    }

    return count;
}

static char *json_string_encode(char *s, int len){
    char *result = malloc(4 * len), *p = result;

    while (len > 0) {
        switch (*s) {
        case '\r':
            *p++ = '\\'; *p++ = 'r';
            break;
        case '\n':
            *p++ = '\\'; *p++ = 'n';
            break;
        case '\f':
            *p++ = '\\'; *p++ = 'f';
            break;
        case '\t':
            *p++ = '\\'; *p++ = 't';
            break;
        case '"':
            *p++ = '\\'; *p++ = '"';
            break;
        case '\\':
            *p++ = '\\'; *p++ = '\\';
            break;
        default:
            *p++ = *s;
        }
        s++;
        len--;
    }
    *p++ = 0;
    return result;
}
            

static void enum_loc(void *env, const void *key, unsigned int key_size,
                                HASHDICT_VALUE_TYPE value){
    static bool notfirst = false;
    FILE *out = env;

    if (notfirst) {
        fprintf(out, ",\n");
    }
    else {
        notfirst = true;
        fprintf(out, "\n");
    }
    fprintf(out, "    \"%.*s\": { ", key_size, (char *) key);

    struct json_value *jv = value;
    assert(jv->type == JV_MAP);

    struct json_value *file = dict_lookup(jv->u.map, "file", 4);
    assert(file->type == JV_ATOM);
    fprintf(out, "\"file\": \"%.*s\", ", file->u.atom.len, file->u.atom.base);

    struct json_value *line = dict_lookup(jv->u.map, "line", 4);
    assert(line->type == JV_ATOM);
    fprintf(out, "\"line\": \"%.*s\", ", line->u.atom.len, line->u.atom.base);

    struct json_value *code = dict_lookup(jv->u.map, "code", 4);
    assert(code->type == JV_ATOM);
    fprintf(out, "\"code\": \"%s\"", json_string_encode(code->u.atom.base, code->u.atom.len));
    fprintf(out, " }");
}

enum busywait { BW_ESCAPE, BW_RETURN, BW_VISITED };
enum busywait is_stuck(struct node *start, struct node *node, uint64_t ctx, bool change) {
	if (node->component != start->component) {
		return BW_ESCAPE;
	}
	if (node->visited) {
		return BW_VISITED;
	}
    change = change || (node->state->vars != start->state->vars);
	node->visited = true;
	enum busywait result = BW_ESCAPE;
    for (struct edge *edge = node->fwd; edge != NULL; edge = edge->next) {
        if (edge->ctx == ctx) {
			if (edge->node == node) {
				node->visited = false;
				return BW_ESCAPE;
			}
			if (edge->node == start) {
				if (!change) {
					node->visited = false;
					return BW_ESCAPE;
				}
				result = BW_RETURN;
			}
			else {
				enum busywait bw = is_stuck(start, edge->node, edge->after, change);
				switch (bw) {
				case BW_ESCAPE:
					node->visited = false;
					return BW_ESCAPE;
				case BW_RETURN:
					result = BW_RETURN;
					break;
				case BW_VISITED:
					break;
				default:
					assert(false);
				}
			}
        }
    }
	node->visited = false;
    return result;
}

void detect_busywait(struct node *node){
	// Get the contexts
	int size;
	uint64_t *ctxs = value_get(node->state->ctxbag, &size);
	size /= sizeof(uint64_t);

	for (int i = 0; i < size; i += 2) {
		if (is_stuck(node, node, ctxs[i], false) == BW_RETURN) {
			struct failure *f = new_alloc(struct failure);
			f->type = FAIL_BUSYWAIT;
			f->choice = node->choice;
			f->node = node;
			queue_enqueue(failures, f);
			break;
		}
	}
}

void usage(char *prog){
    fprintf(stderr, "Usage: %s [-c] [-t maxtime] file.json\n", prog);
    exit(1);
}

int main(int argc, char **argv){
    bool cflag = false;
    int i, maxtime = 300000000 /* about 10 years */;
    for (i = 1; i < argc; i++) {
        if (*argv[i] != '-') {
            break;
        }
        switch (argv[i][1]) {
        case 'c':
            cflag = true;
            break;
        case 't':
            maxtime = atoi(&argv[i][2]);
            if (maxtime <= 0) {
                fprintf(stderr, "%s: negative timeout\n", argv[0]);
                exit(1);
            }
            break;
        default:
            usage(argv[0]);
        }
    }
    if (argc - i > 1) {
        usage(argv[0]);
    }
    char *fname = i == argc ? "harmony.json" : argv[i];

    struct timeval tv;
    gettimeofday(&tv, NULL);
    double now = tv.tv_sec + (double) tv.tv_usec / 1000000;
    double timeout = now + maxtime;

    failures = queue_init();
    warnings = queue_init();

    // initialize modules
    value_init();
    ops_init();

    // open the file
    FILE *fp = fopen(fname, "r");
    if (fp == NULL) {
        fprintf(stderr, "%s: can't open %s\n", argv[0], fname);
        exit(1);
    }

    // read the file
    json_buf_t buf;
    buf.base = malloc(CHUNKSIZE);
    buf.len = 0;
    int n;
    while ((n = fread(&buf.base[buf.len], 1, CHUNKSIZE, fp)) > 0) {
        buf.len += n;
        buf.base = realloc(buf.base, buf.len + CHUNKSIZE);
    }
    fclose(fp);

    // parse the contents
    struct json_value *jv = json_parse_value(&buf);
    assert(jv->type == JV_MAP);

    // travel through the json code contents to create the code array
    struct json_value *jc = dict_lookup(jv->u.map, "code", 4);
    assert(jc->type == JV_LIST);
    for (int i = 0; i < jc->u.list.nvals; i++) {
        // printf("Line %d\n", i);
        code_get(jc->u.list.vals[i]);
    }

    // Create an initial state
	uint64_t this = value_put_atom("this", 4);
    struct context *init_ctx = new_alloc(struct context);;
    // uint64_t nv = value_put_atom("name", 4);
    // uint64_t tv = value_put_atom("tag", 3);
    init_ctx->name = value_put_atom("__init__", 8);
    init_ctx->arg = VALUE_DICT;
    init_ctx->this = VALUE_DICT;
    init_ctx->vars = dict_store(VALUE_DICT, this, VALUE_DICT);
    init_ctx->atomic = 1;
    ctx_push(&init_ctx, (CALLTYPE_PROCESS << VALUE_BITS) | VALUE_INT);
    ctx_push(&init_ctx, VALUE_DICT);
    struct state *state = new_alloc(struct state);
    state->vars = VALUE_DICT;
    state->seqs = VALUE_SET;
    uint64_t ictx = value_put_context(init_ctx);
    state->ctxbag = dict_store(VALUE_DICT, ictx, (1 << VALUE_BITS) | VALUE_INT);
    state->stopbag = VALUE_DICT;
    state->invariants = VALUE_SET;
    processes = new_alloc(uint64_t);
    *processes = ictx;
    nprocesses = 1;

    // Put the initial state in the visited map
    struct dict *visited = dict_new(0);
    struct node *node = new_alloc(struct node);
    node->state = state;
    node->after = ictx;
    graph_add(node);
    void **p = dict_insert(visited, state, sizeof(*state));
    assert(*p == NULL);
    *p = node;

    // Put the initial state on the queue
    struct queue *todo = queue_init();
    queue_enqueue(todo, node);
    enqueued++;

    // Create a context for evaluating invariants
    struct context *inv_ctx = new_alloc(struct context);
    // uint64_t inv_nv = value_put_atom("name", 4);
    // uint64_t inv_tv = value_put_atom("tag", 3);
    inv_ctx->name = value_put_atom("__invariant__", 13);
    inv_ctx->arg = VALUE_DICT;
    inv_ctx->this = VALUE_DICT;
    inv_ctx->vars = VALUE_DICT;
    inv_ctx->atomic = inv_ctx->readonly = 1;
    inv_ctx->interruptlevel = false;

    void *next;
    int state_counter = 1;
    while (queue_dequeue(todo, &next)) {
        state_counter++;
        dequeued++;

        node = next;
        state = node->state;

        if (state->choosing != 0) {
            assert((state->choosing & VALUE_MASK) == VALUE_CONTEXT);
            if (false) {
                printf("CHOOSING %"PRIx64"\n", state->choosing);
            }

            struct context *cc = value_get(state->choosing, NULL);
            assert(cc != NULL);
            assert(cc->sp > 0);
            uint64_t s = cc->stack[cc->sp - 1];
            assert((s & VALUE_MASK) == VALUE_SET);
            int size;
            uint64_t *vals = value_get(s, &size);
            size /= sizeof(uint64_t);
            assert(size > 0);
            for (int i = 0; i < size; i++) {
                onestep(node, state->choosing, vals[i], false, visited, todo,
                                &inv_ctx, false, 1, timeout);
            }
        }
        else {
            int size;
            uint64_t *ctxs = value_get(state->ctxbag, &size);
            size /= sizeof(uint64_t);
            assert(size > 0);
            for (int i = 0; i < size; i += 2) {
                assert((ctxs[i] & VALUE_MASK) == VALUE_CONTEXT);
                assert((ctxs[i+1] & VALUE_MASK) == VALUE_INT);
                onestep(node, ctxs[i], 0, false, visited, todo, &inv_ctx,
                                false, ctxs[i+1] >> VALUE_BITS, timeout);
            }

            // Check for data race
            // TODO.  We're checking both if x and y conflict and y and x conflict for any two x and y
            if (queue_empty(warnings) && !cflag) {
                for (struct edge *edge = node->fwd; edge != NULL; edge = edge->next) {
                    for (struct access_info *ai = edge->ai; ai != NULL; ai = ai->next) {
                        if (ai->indices != NULL) {
                            assert(ai->n > 0);
                            if (ai->multiplicity > 1 && !ai->load && ai->atomic == 0) {
                                struct failure *f = new_alloc(struct failure);
                                f->type = FAIL_RACE;
                                f->choice = node->choice;
                                f->node = node;
                                f->address = value_put_address(ai->indices, ai->n * sizeof(uint64_t));
                                queue_enqueue(warnings, f);
                            }
                            else {
                                for (struct edge *edge2 = edge->next; edge2 != NULL; edge2 = edge2->next) {
                                    for (struct access_info *ai2 = edge2->ai; ai2 != NULL; ai2 = ai2->next) {
                                        if (ai2->indices != NULL && !(ai->load && ai2->load) &&
                                                                (ai->atomic == 0 || ai2->atomic == 0)) {
                                            int min = ai->n < ai2->n ? ai->n : ai2->n;
                                            assert(min > 0);
                                            if (memcmp(ai->indices, ai2->indices,
                                                                min * sizeof(uint64_t)) == 0) {
                                                struct failure *f = new_alloc(struct failure);
                                                f->type = FAIL_RACE;
                                                f->choice = node->choice;
                                                f->node = node;
                                                f->address = value_put_address(ai->indices, min * sizeof(uint64_t));
                                                queue_enqueue(warnings, f);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                // Put access_info structs back on the free list
                for (struct edge *edge = node->fwd; edge != NULL; edge = edge->next) {
                    struct access_info *ai = edge->ai;
                    if (ai != NULL) {
                        while (ai->next != NULL) {
                            ai = ai->next;
                        }
                        ai->next = ai_free;
                        ai_free = edge->ai;
                        edge->ai = NULL;
                    }
                }
            }
        }
    }

    printf("#states %d\n", graph_size);

    if (queue_empty(failures)) {
        // find the strongly connected components
        int ncomponents = find_scc();

        // mark the ones that are good
        struct component *components = calloc(ncomponents, sizeof(*components));
        for (int i = 0; i < graph_size; i++) {
            struct node *node = graph[i];
			assert(node->component < ncomponents);
            struct component *comp = &components[node->component];
            if (comp->size == 0) {
                comp->representative = i;
            }
            comp->size++;
            if (comp->good) {
                continue;
            }
            if (node->state->ctxbag == VALUE_DICT && node->state->stopbag == VALUE_DICT) {
                comp->good = true;
                continue;
            }
            for (struct edge *edge = node->fwd;
                            edge != NULL && !comp->good; edge = edge->next) {
                if (edge->node->component != node->component) {
                    comp->good = true;
                }
            }
        }

        // now count the nodes that are in bad components
        int nbad = 0;
        for (int i = 0; i < graph_size; i++) {
            struct node *node = graph[i];
            if (!components[node->component].good) {
                nbad++;
                struct failure *f = new_alloc(struct failure);
                f->type = FAIL_TERMINATION;
                f->choice = node->choice;
                f->node = node;
                queue_enqueue(failures, f);
            }
        }

        if (nbad == 0 && !cflag) {
            for (int i = 0; i < graph_size; i++) {
				graph[i]->visited = false;
			}
            for (int i = 0; i < graph_size; i++) {
                struct node *node = graph[i];
                if (components[node->component].size > 1) {
                    detect_busywait(node);
                }
            }
        }

        printf("%d components, %d bad states\n", ncomponents, nbad);
    }

    if (false) {
        FILE *df = fopen("charm.dump", "w");
        assert(df != NULL);
        for (int i = 0; i < graph_size; i++) {
            struct node *node = graph[i];
            assert(node->id == i);
            fprintf(df, "\nNode %d:\n", node->id);
            fprintf(df, "    component: %d\n", node->component);
            if (node->parent != NULL) {
                fprintf(df, "    parent: %d\n", node->parent->id);
            }
            fprintf(df, "    vars: %s\n", value_string(node->state->vars));
            fprintf(df, "    fwd:\n");
            int eno = 0;
            for (struct edge *edge = node->fwd; edge != NULL; edge = edge->next, eno++) {
                fprintf(df, "        %d:\n", eno);
                struct context *ctx = value_get(edge->ctx, NULL);
                fprintf(df, "            context: %s %s %d\n", value_string(ctx->name), value_string(ctx->arg), ctx->pc);
                fprintf(df, "            choice: %s\n", value_string(edge->choice));
                fprintf(df, "            node: %d (%d)\n", edge->node->id, edge->node->component);
            }
        }
        fclose(df);
    }

    FILE *out = fopen("charm.json", "w");
    if (out == NULL) {
        fprintf(stderr, "charm: can't create charm.json\n");
        exit(1);
    }
    fprintf(out, "{\n");

    if (queue_empty(failures) && queue_empty(warnings)) {
        printf("No issues\n");
        fprintf(out, "  \"issue\": \"No issues\"\n");
        fprintf(out, "}\n");
        exit(0);
    }

    struct failure *bad = NULL;
    while (queue_dequeue(failures, &next)) {
        struct failure *f = next;

        if (bad == NULL || f->node->len < bad->node->len) {
            bad = f;
        }
    }
    if (bad == NULL) {
        while (queue_dequeue(warnings, &next)) {
            struct failure *f = next;

            if (bad == NULL || f->node->len < bad->node->len) {
                bad = f;
            }
        }
    }

    switch (bad->type) {
    case FAIL_SAFETY:
        printf("Safety Violation\n");
        fprintf(out, "  \"issue\": \"Safety violation\",\n");
        break;
    case FAIL_INVARIANT:
        printf("Invariant Violation\n");
        fprintf(out, "  \"issue\": \"Invariant violation\",\n");
        break;
    case FAIL_TERMINATION:
        printf("Non-terminating state\n");
        fprintf(out, "  \"issue\": \"Non-terminating state\",\n");
        break;
    case FAIL_BUSYWAIT:
        printf("Active busy waiting\n");
        fprintf(out, "  \"issue\": \"Active busy waiting\",\n");
		break;
    case FAIL_RACE:
        assert(bad->address != VALUE_ADDRESS);
        char *addr = value_string(bad->address);
        char *json = json_string_encode(addr, strlen(addr));
        printf("Data race (%s)\n", json);
        fprintf(out, "  \"issue\": \"Data race (%s)\",\n", json);
        free(json);
        free(addr);
        break;
    default:
        panic("main: bad fail type");
    }

    fprintf(out, "  \"macrosteps\": [");
    struct state oldstate;
	memset(&oldstate, 0, sizeof(oldstate));
    struct context *oldctx = calloc(1, sizeof(*oldctx));
    dumpfirst = true;
    path_dump(out, bad->node, bad->choice, &oldstate, &oldctx, false);
    fprintf(out, "\n");
    free(oldctx);
    fprintf(out, "  ],\n");

    fprintf(out, "  \"code\": [\n");
    jc = dict_lookup(jv->u.map, "pretty", 6);
    assert(jc->type == JV_LIST);
    for (int i = 0; i < jc->u.list.nvals; i++) {
        struct json_value *next = jc->u.list.vals[i];
        assert(next->type == JV_LIST);
        assert(next->u.list.nvals == 2);
        struct json_value *codestr = next->u.list.vals[0];
        assert(codestr->type == JV_ATOM);
        fprintf(out, "    \"%.*s\"", codestr->u.atom.len, codestr->u.atom.base);
        if (i < jc->u.list.nvals - 1) {
            fprintf(out, ",");
        }
        fprintf(out, "\n");
    }
    fprintf(out, "  ],\n");

    fprintf(out, "  \"explain\": [\n");
    for (int i = 0; i < jc->u.list.nvals; i++) {
        struct json_value *next = jc->u.list.vals[i];
        assert(next->type == JV_LIST);
        assert(next->u.list.nvals == 2);
        struct json_value *codestr = next->u.list.vals[1];
        assert(codestr->type == JV_ATOM);
        fprintf(out, "    \"%.*s\"", codestr->u.atom.len, codestr->u.atom.base);
        if (i < jc->u.list.nvals - 1) {
            fprintf(out, ",");
        }
        fprintf(out, "\n");
    }
    fprintf(out, "  ],\n");

    fprintf(out, "  \"locations\": {");
    jc = dict_lookup(jv->u.map, "locations", 9);
    assert(jc->type == JV_MAP);
    dict_iter(jc->u.map, enum_loc, out);
    fprintf(out, "\n  }\n");

    fprintf(out, "}\n");
	fclose(out);

    return 0;
}

#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <assert.h>

#ifndef HARMONY_COMBINE
#include "global.h"
#endif

#define CHUNK_SIZE	4096

/* Return current time.
 */
double timer_now(void){
    struct timeval now;

    gettimeofday(&now, 0);
	return now.tv_sec + (double) now.tv_usec / 1000000;
}

unsigned long to_ulong(const char *p, int len){
	unsigned long r = 0;

	while (len > 0) {
		assert(isdigit(*p));
		r *= 10;
		r += *p - '0';
		len--;
		p++;
	}
	return r;
}

void panic(char *s){
    fprintf(stderr, "Panic: %s\n", s);
    exit(1);
}

#ifdef notdef
bool file_read(char *filename, /* OUT */ json_buf_t *buf){
	FILE *fp;

	if ((fp = fopen(filename, "r")) == NULL) {
		perror(filename);
		return false;
	}

	*buf = uv_buf_init(0, 0);
	int n;
	for (;;) {
		buf->base = realloc(buf->base, buf->len + CHUNK_SIZE);
		n = fread(buf->base + buf->len, 1, CHUNK_SIZE, fp);
		if (n < CHUNK_SIZE) {
			if (ferror(fp)) {
				perror(filename);
				fclose(fp);
				return false;
			}
			assert(feof(fp));
			assert(n >= 0);
			fclose(fp);
			buf->len += n;
			break;
		}
		assert(n == CHUNK_SIZE);
		buf->len += CHUNK_SIZE;
	}
	return true;
}
#endif // notdef

#include <assert.h>

#ifndef HARMONY_COMBINE
#include "hashdict.h"
#endif

#define hash_func meiyan

static inline uint32_t meiyan(const char *key, int count) {
	typedef uint32_t *P;
	uint32_t h = 0x811c9dc5;
	while (count >= 8) {
		h = (h ^ ((((*(P)key) << 5) | ((*(P)key) >> 27)) ^ *(P)(key + 4))) * 0xad3e7;
		count -= 8;
		key += 8;
	}
	#define tmp h = (h ^ *(uint16_t*)key) * 0xad3e7; key += 2;
	if (count & 4) { tmp tmp }
	if (count & 2) { tmp }
	if (count & 1) { h = (h ^ *key) * 0xad3e7; }
	#undef tmp
	return h ^ (h >> 16);
}

struct keynode *keynode_new(char*k, int l) {
	struct keynode *node = malloc(sizeof(struct keynode));
	node->len = l;
	node->key = malloc(l);
	memcpy(node->key, k, l);
	node->next = 0;
	node->value = 0;
	return node;
}

void keynode_delete(struct keynode *node) {
	free(node->key);
	if (node->next) keynode_delete(node->next);
	free(node);
}

struct dict *dict_new(int initial_size) {
	struct dict *dict = malloc(sizeof(struct dict));
	if (initial_size == 0) initial_size = 1024;
	dict->length = initial_size;
	dict->count = 0;
	dict->table = calloc(sizeof(struct keynode*), initial_size);
	dict->growth_treshold = 2.0;
	dict->growth_factor = 10;
	return dict;
}

void dict_delete(struct dict *dict) {
	for (int i = 0; i < dict->length; i++) {
		if (dict->table[i])
			keynode_delete(dict->table[i]);
	}
	free(dict->table);
	dict->table = 0;
	free(dict);
}

void dict_reinsert_when_resizing(struct dict *dict, struct keynode *k2) {
	int n = hash_func(k2->key, k2->len) % dict->length;
	if (dict->table[n] == 0) {
		dict->table[n] = k2;
		return;
	}
	struct keynode *k = dict->table[n];
	k2->next = k;
	dict->table[n] = k2;
}

void dict_resize(struct dict *dict, int newsize) {
	int o = dict->length;
	struct keynode **old = dict->table;
	dict->table = calloc(sizeof(struct keynode*), newsize);
	dict->length = newsize;
	for (int i = 0; i < o; i++) {
		struct keynode *k = old[i];
		while (k) {
			struct keynode *next = k->next;
			k->next = 0;
			dict_reinsert_when_resizing(dict, k);
			k = next;
		}
	}
	free(old);
}

void *dict_find(struct dict *dict, const void *key, unsigned int keyn) {
	assert(keyn > 0);
	int n = hash_func((const char*)key, keyn) % dict->length;
	if (dict->table[n] == 0) {
		double f = (double)dict->count / (double)dict->length;
		if (f > dict->growth_treshold) {
			dict_resize(dict, dict->length * dict->growth_factor);
			return dict_find(dict, key, keyn);
		}
		dict->table[n] = keynode_new((char*)key, keyn);
		dict->count++;
		return dict->table[n];
	}
	struct keynode *k = dict->table[n];
	while (k) {
		if (k->len == keyn && memcmp(k->key, key, keyn) == 0) {
			return k;
		}
		k = k->next;
	}
	dict->count++;
	struct keynode *k2 = keynode_new((char*)key, keyn);
	k2->next = dict->table[n];
	dict->table[n] = k2;
	return k2;
}

void **dict_insert(struct dict *dict, const void *key, unsigned int keyn){
    struct keynode *k = dict_find(dict, key, keyn);
    return &k->value;
}

void *dict_retrieve(const void *p, int *psize){
    const struct keynode *k = p;
    if (psize != NULL) {
        *psize = k->len;
    }
    return k->key;
}

void *dict_lookup(struct dict *dict, const void *key, unsigned int keyn) {
	int n = hash_func((const char*)key, keyn) % dict->length;
	// __builtin_prefetch(dict->table[n]);
	struct keynode *k = dict->table[n];
	if (!k) return 0;
	while (k) {
		if (k->len == keyn && !memcmp(k->key, key, keyn)) {
			return k->value;
		}
		k = k->next;
	}
	return 0;
}

void dict_iter(struct dict *dict, enumFunc f, void *env) {
	for (int i = 0; i < dict->length; i++) {
		if (dict->table[i] != 0) {
			struct keynode *k = dict->table[i];
			while (k) {
				(*f)(env, k->key, k->len, k->value);
				k = k->next;
			}
		}
	}
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#ifndef HARMONY_COMBINE
#include "global.h"
#endif

#define buf_adv(b)		do { assert((b)->len > 0); (b)->base++; (b)->len--; } while (false)

static void json_map_cleanup(void *env, const void *key, unsigned int keylen, void *val){
	json_value_free(val);
}

void json_value_free(struct json_value *jv){
	switch (jv->type) {
	case JV_ATOM:
		free(jv->u.atom.base);
		break;
	case JV_MAP:
		dict_iter(jv->u.map, json_map_cleanup, jv);
		dict_delete(jv->u.map);
		break;
	case JV_LIST:
		{
			int i;

			for (i = 0; i < jv->u.list.nvals; i++) {
				json_value_free(jv->u.list.vals[i]);
			}
			free(jv->u.list.vals);
		}
		break;
	default:
		assert(0);
	}
	free(jv);
}

static void json_string_add(json_buf_t *buf, char c){
	/* Grow efficiently, doubling at powers of 2.
	 */
	if (((buf->len + 1) & buf->len) == 0) {
		buf->base = realloc(buf->base, (buf->len + 1) * 2);
	}
	buf->base[buf->len++] = c;
}

static void json_skip_blanks(json_buf_t *buf){
	while (buf->len > 0) {
		if (!isspace(*buf->base)) {
			return;
		}
		buf_adv(buf);
	}
}

static bool is_atom_char(char c){
	return isalnum(c) || c == '.' || c == '-' || c == '_' || c == '/';
}

static void json_parse_atom(json_buf_t *buf, json_buf_t *atom){
	assert(buf->len > 0);
	assert(is_atom_char(*buf->base));
	while (buf->len > 0) {
		if (!is_atom_char(*buf->base)) {
			return;
		}
		json_string_add(atom, *buf->base);
		buf_adv(buf);
	}
}

void json_map_append(struct json_value *map, json_buf_t key, struct json_value *jv){
	assert(map->type == JV_MAP);
	void **p = dict_insert(map->u.map, key.base, key.len);
	if (*p != 0) {
		fprintf(stderr, "json_map_append: duplicate key: '%.*s'\n",
							(int) key.len, key.base);
	}
	assert(*p == 0);
	*p = jv;
}

static struct json_value *json_parse_struct(json_buf_t *buf){
	assert(buf->len > 0);
	assert(*buf->base == '{');
	buf_adv(buf);

	struct json_value *jv = new_alloc(struct json_value);
	jv->type = JV_MAP;
	jv->u.map = dict_new(0);
	for (;;) {
		json_skip_blanks(buf);
		assert(buf->len > 0);
		if (*buf->base == '}') {
			buf_adv(buf);
			return jv;
		}

		struct json_value *key = json_parse_value(buf);
		assert(key->type == JV_ATOM);
		json_skip_blanks(buf);
		assert(buf->len > 0);
		assert(*buf->base == '=' || *buf->base == ':');
		buf_adv(buf);
		struct json_value *val = json_parse_value(buf);
		json_map_append(jv, key->u.atom, val);
		json_value_free(key);

		json_skip_blanks(buf);
		assert(buf->len > 0);
		if (*buf->base == ',' || *buf->base == ';') {
			buf_adv(buf);
		}
	}
}

/* Append a value to the list.
 */
void json_list_append(struct json_value *list, struct json_value *jv){
	assert(list->type == JV_LIST);
	list->u.list.vals = realloc(list->u.list.vals,
				(list->u.list.nvals + 1) * sizeof(*list->u.list.vals));
	list->u.list.vals[list->u.list.nvals++] = jv;
}

static struct json_value *json_parse_list(json_buf_t *buf){
	assert(buf->len > 0);
	assert(*buf->base == '[');
	buf_adv(buf);

	struct json_value *jv = new_alloc(struct json_value);
	jv->type = JV_LIST;
	unsigned int index;
	for (index = 0;; index++) {
		json_skip_blanks(buf);
		assert(buf->len > 0);
		if (*buf->base == ']') {
			buf_adv(buf);
			return jv;
		}
		json_list_append(jv, json_parse_value(buf));
		json_skip_blanks(buf);
		assert(buf->len > 0);
		if (*buf->base == ',' || *buf->base == ';') {
			buf_adv(buf);
		}
	}
}

static struct json_value *json_parse_string(json_buf_t *buf){
	assert(buf->len > 0);
	assert(*buf->base == '"' || *buf->base == '\'');
	char delim = *buf->base;
	buf_adv(buf);

	struct json_value *jv = new_alloc(struct json_value);
	jv->type = JV_ATOM;

	while (buf->len > 0) {
		if (*buf->base == '\\') {
			buf_adv(buf);
			assert(buf->len > 0);
			switch (*buf->base) {
			case 0:
				json_string_add(&jv->u.atom, 0);
				break;
			case '\\':
				json_string_add(&jv->u.atom, '\\');
				break;
			case '\'':
				json_string_add(&jv->u.atom, '\'');
				break;
			case '\"':
				json_string_add(&jv->u.atom, '\"');
				break;
			case '\?':
				json_string_add(&jv->u.atom, '\?');
				break;
			case 'a':
				json_string_add(&jv->u.atom, '\a');
				break;
			case 'b':
				json_string_add(&jv->u.atom, '\b');
				break;
			case 'e':
				json_string_add(&jv->u.atom, '\e');
				break;
			case 'f':
				json_string_add(&jv->u.atom, '\f');
				break;
			case 'n':
				json_string_add(&jv->u.atom, '\n');
				break;
			case 'r':
				json_string_add(&jv->u.atom, '\r');
				break;
			case 't':
				json_string_add(&jv->u.atom, '\t');
				break;
			case 'v':
				json_string_add(&jv->u.atom, '\v');
				break;
			default:
				json_string_add(&jv->u.atom, *buf->base);
			}
		}
		else if (*buf->base == delim) {
			buf_adv(buf);
			return jv;
		}
		else {
			json_string_add(&jv->u.atom, *buf->base);
		}
		buf_adv(buf);
	}
	assert(0);
	return 0;
}

struct json_value *json_parse_value(json_buf_t *buf){
	json_skip_blanks(buf);
	assert(buf->len > 0);
	switch (*buf->base) {
	case '{':
		return json_parse_struct(buf);
	case '[':
		return json_parse_list(buf);
	case '"': case '\'':
		return json_parse_string(buf);
	default:
		if (!is_atom_char(*buf->base)) {
			fprintf(stderr, "--> '%.*s'\n", (int) buf->len, buf->base);
		}
		assert(is_atom_char(*buf->base));
		struct json_value *jv = new_alloc(struct json_value);
		jv->type = JV_ATOM;
		json_parse_atom(buf, &jv->u.atom);
		return jv;
	}
}

struct json_value *json_string(char *s, unsigned int len){
	struct json_value *jv = new_alloc(struct json_value);
	jv->type = JV_ATOM;
	jv->u.atom.len = len;
	jv->u.atom.base = malloc(len);
	memcpy(jv->u.atom.base, s, len);
	return jv;
}

static void json_indent(unsigned int ind){
	while (ind > 0) {
		putchar(' ');
		ind--;
	}
}

static void json_dump_ind(struct json_value *jv, unsigned int ind);

static void json_dump_map(void *env, const void *key, unsigned int keylen, void *val){
	unsigned int ind = (size_t) env;
	json_indent(ind);
	printf("%.*s: ", keylen, (char *) key);
	json_dump_ind(val, ind + 2);
}

static void json_dump_string(json_buf_t buf){
	int i;

	/* See if we should quote it.
	 */
	for (i = 0; i < buf.len; i++) {
		if (!is_atom_char(buf.base[i])) {
			break;
		}
	}
	if (i == buf.len) {
		printf("%.*s\n", (int) buf.len, buf.base);
		return;
	}

	putchar('"');
	for (i = 0; i < buf.len; i++) {
		switch (buf.base[i]) {
		case 0:
			printf("\\0");
			break;
		case '"':
			printf("\\\"");
			break;
		default:
			putchar(buf.base[i]);
		}
	}
	printf("\"\n");
}

static void json_dump_ind(struct json_value *jv, unsigned int ind){
	switch (jv->type) {
	case JV_ATOM:
		json_dump_string(jv->u.atom);
		break;
	case JV_MAP:
		printf("{\n");
		dict_iter(jv->u.map, json_dump_map, (void *) (size_t) (ind + 2));
		json_indent(ind); printf("}\n");
		break;
	case JV_LIST:
		printf("[\n");
		int i;
		for (i = 0; i < jv->u.list.nvals; i++) {
			json_indent(ind + 2);
			json_dump_ind(jv->u.list.vals[i], ind + 4);
		}
		json_indent(ind); printf("]\n");
		break;
	default:
		assert(0);
	}
}

void json_dump(struct json_value *jv){
	json_dump_ind(jv, 0);
}

/* Allocate and get a string out of an atom identified by string key.
 */
char *json_lookup_string(struct dict *map, char *key){
	struct json_value *jv = dict_lookup(map, key, strlen(key));
	if (jv == 0) {
		return 0;
	}
	assert(jv->type == JV_ATOM);
	char *p = malloc(jv->u.atom.len + 1);
	memcpy(p, jv->u.atom.base, jv->u.atom.len);
	p[jv->u.atom.len] = 0;
	return p;
}

/* Find a map inside the map by string key.
 */
struct json_value *json_lookup_map(struct dict *map, char *key){
	struct json_value *jv = dict_lookup(map, key, strlen(key));
	if (jv == 0) {
		return 0;
	}
	assert(jv->type == JV_MAP);
	return jv;
}

/* Find a json_value (can be either a JV_MAP or JV_ATOM) 
 * inside the map by string key.
 */
struct json_value *json_lookup_value(struct dict *map, char *key){
	struct json_value *jv = dict_lookup(map, key, strlen(key));
	if (jv == 0) {
		return 0;
	}
	return jv;
}

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <ctype.h>
#include <assert.h>

#ifndef HARMONY_COMBINE
#include "global.h"
#endif

#define MAX_ARITY   16

struct val_info {
    int size, index;
    uint64_t *vals;
};

struct f_info {
    char *name;
    uint64_t (*f)(struct state *state, struct context *ctx, uint64_t *args, int n);
};

struct var_tree {
    enum { VT_NAME, VT_TUPLE } type;
    union {
        uint64_t name;
        struct {
            int n;
            struct var_tree **elements;
        } tuple;
    } u;
};

static uint64_t this;
static struct dict *ops_map, *f_map;
extern struct code *code;

bool is_sequential(uint64_t seqvars, uint64_t *indices, int n){
    assert((seqvars & VALUE_MASK) == VALUE_SET);
    int size;
    uint64_t *seqs = value_get(seqvars, &size);
    size /= sizeof(uint64_t);

    n *= sizeof(uint64_t);
    for (int i = 0; i < size; i++) {
        assert((seqs[i] & VALUE_MASK) == VALUE_ADDRESS);
        int sn;
        uint64_t *inds = value_get(seqs[i], &sn);
        if (n >= sn && sn >= 0 && memcmp(indices, inds, sn) == 0) {
            return true;
        }
    }
    return false;
}

uint64_t ctx_failure(struct context *ctx, char *fmt, ...){
    char *r;
    va_list args;

    assert(ctx->failure == 0);

    va_start(args, fmt);
    if (vasprintf(&r, fmt, args) < 0) {
		panic("ctx_failure: vasprintf");
	}
    va_end(args);

    ctx->failure = value_put_atom(r, strlen(r));
    free(r);

    return 0;
}

uint64_t var_match_rec(struct context *ctx, struct var_tree *vt,
                            uint64_t arg, uint64_t vars){
    switch (vt->type) {
    case VT_NAME:
        return dict_store(vars, vt->u.name, arg);
    case VT_TUPLE:
        if ((arg & VALUE_MASK) != VALUE_DICT) {
            if (vt->u.tuple.n == 0) {
                return ctx_failure(ctx, "match: expected ()");
            }
            else {
                return ctx_failure(ctx, "match: expected a tuple");
            }
        }
        if (arg == VALUE_DICT) {
            if (vt->u.tuple.n != 0) {
                return ctx_failure(ctx, "match: expected a %d-tuple",
                                                vt->u.tuple.n);
            }
            return vars;
        }
        if (vt->u.tuple.n == 0) {
            return ctx_failure(ctx, "match: expected an empty tuple");
        }
        int size;
        uint64_t *vals = value_get(arg, &size);
        size /= 2 * sizeof(uint64_t);
        if (vt->u.tuple.n != size) {
            return ctx_failure(ctx, "match: tuple size mismatch");
        }
        for (int i = 0; i < size; i++) {
            if (vals[2*i] != ((i << VALUE_BITS) | VALUE_INT)) {
                return ctx_failure(ctx, "match: not a tuple");
            }
            vars = var_match_rec(ctx, vt->u.tuple.elements[i], vals[2*i+1], vars);
        }
        return vars;
    default:
        panic("var_tree_rec: bad vartree type");
        return 0;
    }
}

void var_match(struct context *ctx, struct var_tree *vt, uint64_t arg){
    uint64_t vars = var_match_rec(ctx, vt, arg, ctx->vars);
    if (ctx->failure == 0) {
        ctx->vars = vars;
    }
}

// for debugging only
void var_dump(struct var_tree *vt){
    switch (vt->type) {
    case VT_NAME:
        printf("%"PRIx64"", vt->u.name);
        break;
    case VT_TUPLE:
        printf("(");
        for (int i = 0; i < vt->u.tuple.n; i++) {
            printf(" ");
            var_dump(vt->u.tuple.elements[i]);
        }
        printf(" )");
        break;
    default:
        panic("var_dump: bad vartree type");
    }
}

static void skip_blanks(char *s, int len, int *index){
    while (*index < len && s[*index] == ' ') {
        (*index)++;
    }
}

struct var_tree *var_parse(char *s, int len, int *index){
    assert(*index < len);
    struct var_tree *vt = new_alloc(struct var_tree);

    skip_blanks(s, len, index);
    if (s[*index] == '(') {
        vt->type = VT_TUPLE;
        (*index)++;
        skip_blanks(s, len, index);
        assert(*index < len);
        if (s[*index] == ')') {
            (*index)++;
        }
        else {
            while (true) {
                struct var_tree *elt = var_parse(s, len, index);
                vt->u.tuple.elements = realloc(vt->u.tuple.elements,
                        (vt->u.tuple.n + 1) * sizeof(elt));
                vt->u.tuple.elements[vt->u.tuple.n++] = elt;
                skip_blanks(s, len, index);
                assert(*index < len);
                if (s[*index] == ')') {
                    (*index)++;
                    break;
                }
                assert(s[*index] == ',');
                (*index)++;
            }
        }
    }
    else if (s[*index] == '[') {
        vt->type = VT_TUPLE;
        (*index)++;
        panic("var_parse: TODO");
    }
    else {
        vt->type = VT_NAME;
        int i = *index;
        assert(isalpha(s[i]) || s[i] == '_' || s[i] == '$');
        i++;
        while (i < len && (isalpha(s[i]) || s[i] == '_' || isdigit(s[i]))) {
            i++;
        }
        vt->u.name = value_put_atom(&s[*index], i - *index);
        *index = i;
    }
    return vt;
}

void ctx_push(struct context **pctx, uint64_t v){
	assert(*pctx != NULL);
    struct context *ctx = realloc(*pctx, sizeof(struct context) + 
                ((*pctx)->sp + 1) * sizeof(uint64_t));

    ctx->stack[ctx->sp++] = v;
    *pctx = ctx;
}

uint64_t ctx_pop(struct context **pctx){
    struct context *ctx = *pctx;

    assert(ctx->sp > 0);
    return ctx->stack[--ctx->sp];
}

void interrupt_invoke(struct context **pctx){
    assert(!(*pctx)->interruptlevel);
	assert(((*pctx)->trap_pc & VALUE_MASK) == VALUE_PC);
    ctx_push(pctx, ((*pctx)->pc << VALUE_BITS) | VALUE_PC);
    ctx_push(pctx, (CALLTYPE_INTERRUPT << VALUE_BITS) | VALUE_INT);
    ctx_push(pctx, (*pctx)->trap_arg);
    (*pctx)->pc = (*pctx)->trap_pc >> VALUE_BITS;
    (*pctx)->trap_pc = 0;
    (*pctx)->interruptlevel = true;
}

uint64_t dict_load(uint64_t dict, uint64_t key){
    assert((dict & VALUE_MASK) == VALUE_DICT);

    uint64_t *vals;
    int size;
    if (dict == VALUE_DICT) {
        vals = NULL;
        size = 0;
    }
    else {
        vals = value_get(dict & ~VALUE_MASK, &size);
        size /= sizeof(uint64_t);
        assert(size % 2 == 0);
    }

    int i;
    for (i = 0; i < size; i += 2) {
        if (vals[i] == key) {
            return vals[i + 1];
        }
        /* 
            if (value_cmp(vals[i], key) > 0) {
                break;
            }
        */
    }

	printf("CAN'T FIND %s in %s\n", value_string(key), value_string(dict));
    panic("dict_load");
    return 0;
}

uint64_t dict_remove(uint64_t dict, uint64_t key){
    assert((dict & VALUE_MASK) == VALUE_DICT);

    uint64_t *vals;
    int size;
    if (dict == VALUE_DICT) {
        return VALUE_DICT;
    }
    vals = value_get(dict & ~VALUE_MASK, &size);
    size /= sizeof(uint64_t);
    assert(size % 2 == 0);

    if (size == 2) {
        return vals[0] == key ? VALUE_DICT : dict;
    }

    int i;
    for (i = 0; i < size; i += 2) {
        if (vals[i] == key) {
            int n = (size - 2) * sizeof(uint64_t);
            uint64_t *copy = malloc(n);
            memcpy(copy, vals, i * sizeof(uint64_t));
            memcpy(&copy[i], &vals[i+2],
                (size - i - 2) * sizeof(uint64_t));
            uint64_t v = value_put_dict(copy, n);
            free(copy);
            return v;
        }
        /* 
            if (value_cmp(vals[i], key) > 0) {
                assert(false);
            }
        */
    }

    return dict;
}

bool dict_tryload(uint64_t dict, uint64_t key, uint64_t *result){
    if ((dict & VALUE_MASK) != VALUE_DICT) {
        return false;
    }

    uint64_t *vals;
    int size;
    if (dict == VALUE_DICT) {
        vals = NULL;
        size = 0;
    }
    else {
        vals = value_get(dict & ~VALUE_MASK, &size);
        size /= sizeof(uint64_t);
        assert(size % 2 == 0);
    }

    int i;
    for (i = 0; i < size; i += 2) {
        if (vals[i] == key) {
            *result = vals[i + 1];
            return true;
        }
        /* 
            if (value_cmp(vals[i], key) > 0) {
                break;
            }
        */
    }
    return false;
}

// Store key:value in the given dictionary and returns its value code
uint64_t dict_store(uint64_t dict, uint64_t key, uint64_t value){
    assert((dict & VALUE_MASK) == VALUE_DICT);

    if (false) {
        char *p = value_string(value);
        char *q = value_string(dict);
        char *r = value_string(key);
        printf("DICT_STORE %s %s %s\n", p, q, r);
        free(p);
        free(q);
        free(r);
    }

    uint64_t *vals;
    int size;
    if (dict == VALUE_DICT) {
        vals = NULL;
        size = 0;
    }
    else {
        vals = value_get(dict & ~VALUE_MASK, &size);
        size /= sizeof(uint64_t);
        assert(size % 2 == 0);
    }

    int i;
    for (i = 0; i < size; i += 2) {
        if (vals[i] == key) {
            if (vals[i + 1] == value) {
                return dict;
            }
            int n = size * sizeof(uint64_t);
            uint64_t *copy = malloc(n);
            memcpy(copy, vals, n);
            copy[i + 1] = value;
            uint64_t v = value_put_dict(copy, n);
            free(copy);
            return v;
        }
        if (value_cmp(vals[i], key) > 0) {
            break;
        }
    }

    int n = (size + 2) * sizeof(uint64_t);
    uint64_t *nvals = malloc(n);
    memcpy(nvals, vals, i * sizeof(uint64_t));
    nvals[i] = key;
    nvals[i+1] = value;
    memcpy(&nvals[i+2], &vals[i], (size - i) * sizeof(uint64_t));
    uint64_t v = value_put_dict(nvals, n);
    free(nvals);
    return v;
}

bool ind_tryload(uint64_t dict, uint64_t *indices, int n, uint64_t *result){
    uint64_t d = dict;
    for (int i = 0; i < n; i++) {
        if (!dict_tryload(d, indices[i], &d)) {
            return false;
        }
    }
    *result = d;
    return true;
}

bool ind_trystore(uint64_t dict, uint64_t *indices, int n, uint64_t value, uint64_t *result){
    assert((dict & VALUE_MASK) == VALUE_DICT);
    assert(n > 0);

    if (n == 1) {
        *result = dict_store(dict, indices[0], value);
        return true;
    }
    else {
        uint64_t *vals;
        int size;
        if (dict == VALUE_DICT) {
            vals = NULL;
            size = 0;
        }
        else {
            vals = value_get(dict & ~VALUE_MASK, &size);
            size /= sizeof(uint64_t);
            assert(size % 2 == 0);
        }

        int i;
        for (i = 0; i < size; i += 2) {
            if (vals[i] == indices[0]) {
                uint64_t d = vals[i+1];
                if ((d & VALUE_MASK) != VALUE_DICT) {
                    return false;
                }
                uint64_t nd;
                if (!ind_trystore(d, indices + 1, n - 1, value, &nd)) {
                    return false;
                }
                if (d == nd) {
                    *result = dict;
                    return true;
                }
                int n = size * sizeof(uint64_t);
                uint64_t *copy = malloc(n);
                memcpy(copy, vals, n);
                copy[i + 1] = nd;
                uint64_t v = value_put_dict(copy, n);
                free(copy);
                *result = v;
                return true;
            }
            /* 
                if (value_cmp(vals[i], key) > 0) {
                    assert(false);
                }
            */
        }
    }
    return false;
}

bool ind_remove(uint64_t dict, uint64_t *indices, int n,
                                        uint64_t *result) {
    assert((dict & VALUE_MASK) == VALUE_DICT);
    assert(n > 0);

    if (n == 1) {
        *result = dict_remove(dict, indices[0]);
        return true;
    }
    else {
        uint64_t *vals;
        int size;
        if (dict == VALUE_DICT) {
            vals = NULL;
            size = 0;
        }
        else {
            vals = value_get(dict & ~VALUE_MASK, &size);
            size /= sizeof(uint64_t);
            assert(size % 2 == 0);
        }

        int i;
        for (i = 0; i < size; i += 2) {
            if (vals[i] == indices[0]) {
                uint64_t d = vals[i+1];
                if ((d & VALUE_MASK) != VALUE_DICT) {
                    return false;
                }
                uint64_t nd;
                if (!ind_remove(d, indices + 1, n - 1, &nd)) {
                    return false;
                }
                if (d == nd) {
                    *result = dict;
                    return true;
                }
                int n = size * sizeof(uint64_t);
                uint64_t *copy = malloc(n);
                memcpy(copy, vals, n);
                copy[i + 1] = nd;
                uint64_t v = value_put_dict(copy, n);
                free(copy);
                *result = v;
                return true;
            }
            /* 
                if (value_cmp(vals[i], key) > 0) {
                    assert(false);
                }
            */
        }
        return false;
    }
}

void op_Address(const void *env, struct state *state, struct context **pctx){
    uint64_t index = ctx_pop(pctx);
    uint64_t av = ctx_pop(pctx);
    if ((av & VALUE_MASK) != VALUE_ADDRESS) {
        char *p = value_string(av);
        ctx_failure(*pctx, "%s: not an address", p);
        free(p);
        return;
    }
    if (av == VALUE_ADDRESS) {
        ctx_failure(*pctx, "None unexpected");
        return;
    }
    if (false) {
        printf("ADDRESS %"PRIx64"\n", index);
    }

    int size;
    uint64_t *indices = value_copy(av, &size);
    indices = realloc(indices, size + sizeof(index));
    indices[size / sizeof(uint64_t)] = index;
    ctx_push(pctx, value_put_address(indices, size + sizeof(index)));
    free(indices);
    (*pctx)->pc++;
}

void op_Apply(const void *env, struct state *state, struct context **pctx){
    uint64_t method = ctx_pop(pctx);
    uint64_t e = ctx_pop(pctx);

    uint64_t type = method & VALUE_MASK;
    switch (type) {
    case VALUE_DICT:
        {
            uint64_t v;
            if (!dict_tryload(method, e, &v)) {
                char *m = value_string(method);
                char *x = value_string(e);
                ctx_failure(*pctx, "Bad index %s: not in %s", x, m);
                free(m);
                free(x);
                return;
            }
            ctx_push(pctx, v);
            (*pctx)->pc++;
        }
        return;
    case VALUE_PC:
        ctx_push(pctx, (((*pctx)->pc + 1) << VALUE_BITS) | VALUE_PC);
        ctx_push(pctx, (CALLTYPE_NORMAL << VALUE_BITS) | VALUE_INT);
        ctx_push(pctx, e);
        assert((method >> VALUE_BITS) != (*pctx)->pc);
        (*pctx)->pc = method >> VALUE_BITS;
        return;
    default:
        {
            char *x = value_string(method);
            ctx_failure(*pctx, "Can only apply to methods or dictionaries, not to: %s", x);
            free(x);
        }
    }
}

void op_Assert(const void *env, struct state *state, struct context **pctx){
    uint64_t v = ctx_pop(pctx);
    if ((v & VALUE_MASK) != VALUE_BOOL) {
        ctx_failure(*pctx, "assert can only be applied to bool values");
    }
    if (v == VALUE_FALSE) {
        ctx_failure(*pctx, "Harmony assertion failed");
    }
    else {
        (*pctx)->pc++;
    }
}

void op_Assert2(const void *env, struct state *state, struct context **pctx){
    uint64_t e = ctx_pop(pctx);
    uint64_t v = ctx_pop(pctx);
    if ((v & VALUE_MASK) != VALUE_BOOL) {
        ctx_failure(*pctx, "assert2 can only be applied to bool values");
    }
    if (v == VALUE_FALSE) {
        char *p = value_string(e);
        ctx_failure(*pctx, "Harmony assertion failed: %s", p);
        free(p);
    }
    else {
        (*pctx)->pc++;
    }
}

void op_AtomicDec(const void *env, struct state *state, struct context **pctx){
    struct context *ctx = *pctx;

    assert(ctx->atomic > 0);
    ctx->atomic--;
    ctx->pc++;
}

void op_AtomicInc(const void *env, struct state *state, struct context **pctx){
    struct context *ctx = *pctx;

    ctx->atomic++;
    ctx->pc++;
}

void op_Choose(const void *env, struct state *state, struct context **pctx){
    panic("op_Choose: should not be called");
}

void op_Continue(const void *env, struct state *state, struct context **pctx){
    (*pctx)->pc++;
}

void op_Cut(const void *env, struct state *state, struct context **pctx){
    const struct env_Cut *ec = env;
    struct context *ctx = *pctx;

    uint64_t v = dict_load(ctx->vars, ec->set);
    if ((v & VALUE_MASK) == VALUE_SET) {
        assert(v != VALUE_SET);
        void *p = (void *) (v & ~VALUE_MASK);

        int size;
        uint64_t *vals = dict_retrieve(p, &size);
        assert(size > 0);

        ctx->vars = dict_store(ctx->vars, ec->set, value_put_set(&vals[1], size - sizeof(uint64_t)));
        ctx->vars = dict_store(ctx->vars, ec->var, vals[0]);
        (*pctx)->pc++;
        return;
    }
    if ((v & VALUE_MASK) == VALUE_DICT) {
        assert(v != VALUE_DICT);
        void *p = (void *) (v & ~VALUE_MASK);

        int size;
        uint64_t *vals = dict_retrieve(p, &size);
        assert(size > 0);

        ctx->vars = dict_store(ctx->vars, ec->set, value_put_dict(&vals[2], size - 2 * sizeof(uint64_t)));
        ctx->vars = dict_store(ctx->vars, ec->var, vals[1]);
        (*pctx)->pc++;
        return;
    }
    panic("op_Cut: not a set or dict");
}

void ext_Del(const void *env, struct state *state, struct context **pctx,
                                                        struct access_info *ai){
    assert((state->vars & VALUE_MASK) == VALUE_DICT);

    if ((*pctx)->readonly > 0) {
        ctx_failure(*pctx, "Can't update state in assert or invariant");
        return;
    }

    uint64_t av = ctx_pop(pctx);
    if ((av & VALUE_MASK) != VALUE_ADDRESS) {
        char *p = value_string(av);
        ctx_failure(*pctx, "Del %s: not an address", p);
        free(p);
        return;
    }
    if (av == VALUE_ADDRESS) {
        ctx_failure(*pctx, "Del: address is None");
        return;
    }

    int size;
    uint64_t *indices = value_get(av, &size);
    size /= sizeof(uint64_t);
    if (ai != NULL) {
        ai->indices = indices;
        ai->n = size;
        ai->load = false;
    }
    uint64_t nd;
    if (!ind_remove(state->vars, indices, size, &nd)) {
        ctx_failure(*pctx, "Del: no such variable");
    }
    else {
        state->vars = nd;
        (*pctx)->pc++;
    }
}

void op_Del(const void *env, struct state *state, struct context **pctx){
    ext_Del(env, state, pctx, NULL);
}

void op_DelVar(const void *env, struct state *state, struct context **pctx){
    const struct env_DelVar *ed = env;
    (*pctx)->vars = dict_remove((*pctx)->vars, ed->name);
    (*pctx)->pc++;
}

void op_Dup(const void *env, struct state *state, struct context **pctx){
    uint64_t v = ctx_pop(pctx);
    ctx_push(pctx, v);
    ctx_push(pctx, v);
    (*pctx)->pc++;
}

void op_Frame(const void *env, struct state *state, struct context **pctx){
    static uint64_t result = 0;

    if (result == 0) {
        result = value_put_atom("result", 6);
    }

    const struct env_Frame *ef = env;
    if (false) {
        printf("FRAME %d %d %"PRIx64" ", (*pctx)->pc, (*pctx)->sp, ef->name);
        var_dump(ef->args);
        printf("\n");
    }

    // peek at argument
    uint64_t arg = ctx_pop(pctx);
    ctx_push(pctx, arg);

    uint64_t oldvars = (*pctx)->vars;
    uint64_t thisval = dict_load(oldvars, this);

    // try to match against parameters
    (*pctx)->vars = dict_store(dict_store(VALUE_DICT, this, thisval),
				result, VALUE_DICT);
    var_match(*pctx, ef->args, arg);
    if ((*pctx)->failure != 0) {
        return;
    }
 
    ctx_push(pctx, dict_remove(oldvars, this));
    ctx_push(pctx, ((*pctx)->fp << VALUE_BITS) | VALUE_INT);

    struct context *ctx = *pctx;
    ctx->fp = ctx->sp;
    ctx->pc += 1;
}

void op_Go(const void *env, struct state *state, struct context **pctx){
    uint64_t ctx = ctx_pop(pctx);
    if ((ctx & VALUE_MASK) != VALUE_CONTEXT) {
        ctx_failure(*pctx, "Go: not a context");
        return;
    }

    // Remove from stopbag if it's there
    uint64_t count;
    if (dict_tryload(state->stopbag, ctx, &count)) {
        assert((count & VALUE_MASK) == VALUE_INT);
        assert(count != VALUE_INT);
        count -= 1 << VALUE_BITS;
        if (count != VALUE_INT) {
            state->stopbag = dict_store(state->stopbag, ctx, count);
        }
        else {
            state->stopbag = dict_remove(state->stopbag, ctx);
        }
    }

    uint64_t result = ctx_pop(pctx);
    struct context *copy = value_copy(ctx, NULL);
    ctx_push(&copy, result);
    copy->stopped = false;
    uint64_t v = value_put_context(copy);
    free(copy);
    state->ctxbag = bag_add(state->ctxbag, v);
    (*pctx)->pc++;
}

void op_IncVar(const void *env, struct state *state, struct context **pctx){
    const struct env_IncVar *ei = env;
    struct context *ctx = *pctx;

    assert((ctx->vars & VALUE_MASK) == VALUE_DICT);

    uint64_t v = dict_load(ctx->vars, ei->name);
    assert((v & VALUE_MASK) == VALUE_INT);
    v += 1 << VALUE_BITS;
    ctx->vars = dict_store(ctx->vars, ei->name, v);
    (*pctx)->pc++;
}

void op_Invariant(const void *env, struct state *state, struct context **pctx){
    const struct env_Invariant *ei = env;

    assert((state->invariants & VALUE_MASK) == VALUE_SET);
    int size;
    uint64_t *vals;
    if (state->invariants == VALUE_SET) {
        size = 0;
        vals = NULL;
    }
    else {
        vals = value_get(state->invariants, &size);
    }
    vals = realloc(vals, size + sizeof(uint64_t));
    * (uint64_t *) ((char *) vals + size) = ((*pctx)->pc << VALUE_BITS) | VALUE_PC;
    state->invariants = value_put_set(vals, size + sizeof(uint64_t));
    (*pctx)->pc += ei->cnt + 1;
}

int invariant_cnt(const void *env){
    const struct env_Invariant *ei = env;

    return ei->cnt;
}

void op_Jump(const void *env, struct state *state, struct context **pctx){
    const struct env_Jump *ej = env;

    if (false) {
        printf("JUMP %d\n", ej->pc);
    }
    (*pctx)->pc = ej->pc;
}

void op_JumpCond(const void *env, struct state *state, struct context **pctx){
    const struct env_JumpCond *ej = env;

    if (false) {
        printf("JUMPCOND %d\n", ej->pc);
    }
    uint64_t v = ctx_pop(pctx);
    if (v == ej->cond) {
        assert((*pctx)->pc != ej->pc);
        (*pctx)->pc = ej->pc;
    }
    else {
        (*pctx)->pc++;
    }
}

void ext_Load(const void *env, struct state *state, struct context **pctx,
                                                        struct access_info *ai){
    const struct env_Load *el = env;

    assert((state->vars & VALUE_MASK) == VALUE_DICT);

    uint64_t v;
    if (el == 0) {
        uint64_t av = ctx_pop(pctx);
        if ((av & VALUE_MASK) != VALUE_ADDRESS) {
            char *p = value_string(av);
            ctx_failure(*pctx, "Load %s: not an address", p);
            free(p);
            return;
        }
        if (av == VALUE_ADDRESS) {
            ctx_failure(*pctx, "Load: can't load from None");
            return;
        }

        int size;
        uint64_t *indices = value_get(av, &size);
        size /= sizeof(uint64_t);
        if (ai != NULL) {
            ai->indices = indices;
            ai->n = size;
            ai->load = true;
        }

        if (!ind_tryload(state->vars, indices, size, &v)) {
            char *x = indices_string(indices, size);
            ctx_failure(*pctx, "Load: unknown address %s", x);
            free(x);
            return;
        }
        ctx_push(pctx, v);
    }
    else {
        if (ai != NULL) {
            ai->indices = el->indices;
            ai->n = el->n;
            ai->load = true;
        }
        if (!ind_tryload(state->vars, el->indices, el->n, &v)) {
            char *x = indices_string(el->indices, el->n);
            ctx_failure(*pctx, "Load: unknown variable %s", x+1);
            free(x);
            return;
        }
        ctx_push(pctx, v);
    }
    (*pctx)->pc++;
}

void op_Load(const void *env, struct state *state, struct context **pctx){
    ext_Load(env, state, pctx, NULL);
}

void op_LoadVar(const void *env, struct state *state, struct context **pctx){
    const struct env_LoadVar *el = env;
    assert(((*pctx)->vars & VALUE_MASK) == VALUE_DICT);

    uint64_t v;
    if (el == NULL) {
        uint64_t av = ctx_pop(pctx);
        assert((av & VALUE_MASK) == VALUE_ADDRESS);
        assert(av != VALUE_ADDRESS);

        int size;
        uint64_t *indices = value_get(av, &size);
        size /= sizeof(uint64_t);

        if (!ind_tryload((*pctx)->vars, indices, size, &v)) {
            ctx_failure(*pctx, "Loadvar: unknown address");
            return;
        }
        ctx_push(pctx, v);
    }
    else {
        if (!dict_tryload((*pctx)->vars, el->name, &v)) {
            char *p = value_string(el->name);
            ctx_failure(*pctx, "Loadvar: unknown variable %s", p + 1);
            free(p);
            return;
        }
        ctx_push(pctx, v);
    }
    (*pctx)->pc++;
}

void op_Move(const void *env, struct state *state, struct context **pctx){
    const struct env_Move *em = env;
    struct context *ctx = *pctx;
    int offset = ctx->sp - em->offset;

    uint64_t v = ctx->stack[offset];
    memmove(&ctx->stack[offset], &ctx->stack[offset + 1],
                (em->offset - 1) * sizeof(uint64_t));
    ctx->stack[ctx->sp - 1] = v;
    ctx->pc++;
}

void op_Nary(const void *env, struct state *state, struct context **pctx){
    const struct env_Nary *en = env;
    uint64_t args[MAX_ARITY];

    for (int i = 0; i < en->arity; i++) {
        args[i] = ctx_pop(pctx);
    }
    uint64_t result = (*en->fi->f)(state, *pctx, args, en->arity);
    if ((*pctx)->failure == 0) {
        ctx_push(pctx, result);
        (*pctx)->pc++;
    }
}

void op_Pop(const void *env, struct state *state, struct context **pctx){
    assert((*pctx)->sp > 0);
    (*pctx)->sp--;
    (*pctx)->pc++;
}

void op_Push(const void *env, struct state *state, struct context **pctx){
    const struct env_Push *ep = env;

    if (false) {
        char *p = value_string(ep->value);
        printf("PUSH %s\n", p);
        free(p);
    }

    ctx_push(pctx, ep->value);
    (*pctx)->pc++;
}

void op_ReadonlyDec(const void *env, struct state *state, struct context **pctx){
    struct context *ctx = *pctx;

    assert(ctx->readonly > 0);
    ctx->readonly--;
    ctx->pc++;
}

void op_ReadonlyInc(const void *env, struct state *state, struct context **pctx){
    struct context *ctx = *pctx;

    ctx->readonly++;
    ctx->pc++;
}

void op_Return(const void *env, struct state *state, struct context **pctx){
    if ((*pctx)->sp == 0) {     // __init__    TODO: no longer the case
        assert(false);
        (*pctx)->terminated = true;
        if (false) {
            printf("RETURN INIT\n");
        }
    }
    else {
        uint64_t result = dict_load((*pctx)->vars, value_put_atom("result", 6));
        uint64_t fp = ctx_pop(pctx);
        if ((fp & VALUE_MASK) != VALUE_INT) {
            printf("XXX %d %d %s\n", (*pctx)->pc, (*pctx)->sp, value_string(fp));
            ctx_failure(*pctx, "XXX");
            return;
            // exit(1);
        }
        assert((fp & VALUE_MASK) == VALUE_INT);
        (*pctx)->fp = fp >> VALUE_BITS;
        uint64_t thisval = dict_load((*pctx)->vars, this);
        uint64_t oldvars = ctx_pop(pctx);
        assert((oldvars & VALUE_MASK) == VALUE_DICT);
        (*pctx)->vars = dict_store(oldvars, this, thisval);
        (void) ctx_pop(pctx);   // argument saved for stack trace
        if ((*pctx)->sp == 0) {     // __init__
            (*pctx)->terminated = true;
            if (false) {
                printf("RETURN INIT\n");
            }
            return;
        }
        uint64_t calltype = ctx_pop(pctx);
        assert((calltype & VALUE_MASK) == VALUE_INT);
        switch (calltype >> VALUE_BITS) {
        case CALLTYPE_PROCESS:
            (*pctx)->terminated = true;
            break;
        case CALLTYPE_NORMAL:
            {
                uint64_t pc = ctx_pop(pctx);
                assert((pc & VALUE_MASK) == VALUE_PC);
                pc >>= VALUE_BITS;
                assert(pc != (*pctx)->pc);
                ctx_push(pctx, result);
                (*pctx)->pc = pc;
            }
            break;
		case CALLTYPE_INTERRUPT:
			assert((*pctx)->interruptlevel);
			(*pctx)->interruptlevel = false;
			uint64_t pc = ctx_pop(pctx);
			assert((pc & VALUE_MASK) == VALUE_PC);
			pc >>= VALUE_BITS;
			assert(pc != (*pctx)->pc);
			(*pctx)->pc = pc;
			break;
        default:
            panic("op_Return: bad call type");
        }
    }
}

void op_Sequential(const void *env, struct state *state, struct context **pctx){
    uint64_t addr = ctx_pop(pctx);
    if ((addr & VALUE_MASK) != VALUE_ADDRESS) {
        char *p = value_string(addr);
        ctx_failure(*pctx, "Sequential %s: not an address", p);
        free(p);
        return;
    }

    /* Insert in state's set of sequential variables.
     */
    int size;
    uint64_t *seqs = value_copy(state->seqs, &size);
    size /= sizeof(uint64_t);
    int i;
    for (i = 0; i < size; i++) {
        int k = value_cmp(seqs[i], addr);
        if (k == 0) {
            free(seqs);
            (*pctx)->pc++;
            return;
        }
        if (k > 0) {
            break;
        }
    }
    seqs = realloc(seqs, (size + 1) * sizeof(uint64_t));
    memmove(&seqs[i + 1], &seqs[i], (size - i) * sizeof(uint64_t));
    seqs[i] = addr;
    state->seqs = value_put_set(seqs, (size + 1) * sizeof(uint64_t));
    free(seqs);
    (*pctx)->pc++;
}

// sort two key/value pairs
static int q_kv_cmp(const void *e1, const void *e2){
    const uint64_t *kv1 = (const uint64_t *) e1;
    const uint64_t *kv2 = (const uint64_t *) e2;

    int k = value_cmp(kv1[0], kv2[0]);
    if (k != 0) {
        return k;
    }
    return value_cmp(kv1[1], kv2[1]);
}

static int q_value_cmp(const void *v1, const void *v2){
    return value_cmp(* (const uint64_t *) v1, * (const uint64_t *) v2);
}

// Sort the resulting set and remove duplicates
static int sort(uint64_t *vals, int n){
    qsort(vals, n, sizeof(uint64_t), q_value_cmp);

    uint64_t *p = vals, *q = vals + 1;
    for (int i = 1; i < n; i++, q++) {
        if (*q != *p) {
            *++p = *q;
        }
    }
    p++;
    return p - vals;
}

void op_SetIntLevel(const void *env, struct state *state, struct context **pctx){
	bool oldlevel = (*pctx)->interruptlevel;
	uint64_t newlevel =  ctx_pop(pctx);
    if ((newlevel & VALUE_MASK) != VALUE_BOOL) {
        ctx_failure(*pctx, "setintlevel can only be set to a boolean");
        return;
    }
    (*pctx)->interruptlevel = newlevel >> VALUE_BITS;
	ctx_push(pctx, (oldlevel << VALUE_BITS) | VALUE_BOOL);
    (*pctx)->pc++;
}

uint64_t bag_add(uint64_t bag, uint64_t v){
    uint64_t count;
    if (dict_tryload(bag, v, &count)) {
        assert((count & VALUE_MASK) == VALUE_INT);
        assert(count != VALUE_INT);
        count += 1 << VALUE_BITS;
        return dict_store(bag, v, count);
    }
    else {
        return dict_store(bag, v, (1 << VALUE_BITS) | VALUE_INT);
    }
}

void op_Spawn(const void *env, struct state *state, struct context **pctx){
    extern int code_len;

    uint64_t pc = ctx_pop(pctx);
    if ((pc & VALUE_MASK) != VALUE_PC) {
        ctx_failure(*pctx, "spawn: not a method");
        return;
    }
    pc >>= VALUE_BITS;

    assert(pc < code_len);
    assert(strcmp(code[pc].oi->name, "Frame") == 0);
    uint64_t arg = ctx_pop(pctx);
    uint64_t thisval = ctx_pop(pctx);

    struct context *ctx = new_alloc(struct context);

    const struct env_Frame *ef = code[pc].env;
    ctx->name = ef->name;
    ctx->arg = arg;
    ctx->this = thisval;
    ctx->entry = (pc << VALUE_BITS) | VALUE_PC;
    ctx->pc = pc;
    ctx->vars = VALUE_DICT;
    ctx->vars = dict_store(VALUE_DICT, this, thisval);
    ctx->interruptlevel = VALUE_FALSE;
    ctx_push(&ctx, (CALLTYPE_PROCESS << VALUE_BITS) | VALUE_INT);
    ctx_push(&ctx, arg);
    uint64_t v = value_put_context(ctx);

    state->ctxbag = bag_add(state->ctxbag, v);

    if (false) {
        char *p = value_string(state->ctxbag);
        printf("SPAWN --> %s\n", p);
        free(p);
    }

    (*pctx)->pc++;
}

void op_Split(const void *env, struct state *state, struct context **pctx){
    const struct env_Split *es = env;

    uint64_t v = ctx_pop(pctx);
    uint64_t type = v & VALUE_MASK;
    if (type != VALUE_DICT && type != VALUE_SET) {
        ctx_failure(*pctx, "Can only split tuples or sets");
        return;
    }
    if (v == VALUE_DICT || v == VALUE_SET) {
        if (es->count != 0) {
            ctx_failure(*pctx, "Split: empty set or tuple");
        }
        else {
            (*pctx)->pc++;
        }
        return;
    }

    int size;
    uint64_t *vals = value_get(v, &size);

    if (type == VALUE_DICT) {
        size /= 2 * sizeof(uint64_t);
        if (size != es->count) {
            ctx_failure(*pctx, "Split: list of wrong size");
            return;
        }
        for (int i = 0; i < size; i++) {
            ctx_push(pctx, vals[2*i + 1]);
        }
        (*pctx)->pc++;
        return;
    }
    if (type == VALUE_SET) {
        size /= sizeof(uint64_t);
        if (size != es->count) {
            ctx_failure(*pctx, "Split: set of wrong size");
            return;
        }
        for (int i = 0; i < size; i++) {
            ctx_push(pctx, vals[i]);
        }
        (*pctx)->pc++;
        return;
    }
    panic("op_Split: not a set or dict");
}

void op_Stop(const void *env, struct state *state, struct context **pctx){
    const struct env_Stop *es = env;

    assert((state->vars & VALUE_MASK) == VALUE_DICT);

    if ((*pctx)->readonly > 0) {
        ctx_failure(*pctx, "Stop: in read-only mode");
        return;
    }

    if (es == 0) {
        uint64_t av = ctx_pop(pctx);
        if ((av & VALUE_MASK) != VALUE_ADDRESS) {
            char *p = value_string(av);
            ctx_failure(*pctx, "Stop %s: not an address", p);
            free(p);
            return;
        }
        if (av == VALUE_ADDRESS) {
            ctx_failure(*pctx, "Stop: address is None");
            return;
        }

        int size;
        uint64_t *indices = value_get(av, &size);
        size /= sizeof(uint64_t);

        (*pctx)->stopped = true;
        (*pctx)->pc++;
        uint64_t v = value_put_context(*pctx);

        if (!ind_trystore(state->vars, indices, size, v, &state->vars)) {
            char *x = indices_string(indices, size);
            ctx_failure(*pctx, "Stop: bad address: %s", x);
            free(x);
            return;
        }
    }
    else {
        (*pctx)->stopped = true;
        (*pctx)->pc++;
        uint64_t v = value_put_context(*pctx);

        if (!ind_trystore(state->vars, es->indices, es->n, v, &state->vars)) {
            ctx_failure(*pctx, "Store: bad variable");
            return;
        }
    }
}

void ext_Store(const void *env, struct state *state, struct context **pctx,
                                                        struct access_info *ai){
    const struct env_Store *es = env;

    assert((state->vars & VALUE_MASK) == VALUE_DICT);

    if ((*pctx)->readonly > 0) {
        ctx_failure(*pctx, "Can't update state in assert or invariant (including acquiring locks)");
        return;
    }

    uint64_t v = ctx_pop(pctx);

    if (es == 0) {
        uint64_t av = ctx_pop(pctx);
        if ((av & VALUE_MASK) != VALUE_ADDRESS) {
            char *p = value_string(av);
            ctx_failure(*pctx, "Store %s: not an address", p);
            free(p);
            return;
        }
        if (av == VALUE_ADDRESS) {
            ctx_failure(*pctx, "Store: address is None");
            return;
        }

        int size;
        uint64_t *indices = value_get(av, &size);
        size /= sizeof(uint64_t);
        if (ai != NULL) {
            ai->indices = indices;
            ai->n = size;
            ai->load = is_sequential(state->seqs, ai->indices, ai->n);
        }

        if (false) {
            printf("STORE IND %d %d %d %"PRIx64" %s %s\n", (*pctx)->pc, (*pctx)->sp, size, v,
                    value_string((*pctx)->stack[(*pctx)->sp - 1]),
                    value_string(av));
            for (int i = 0; i < size; i++) {
                char *index = value_string(indices[i]);
                printf(">> %s\n", index);
                free(index);
            }
        }

        if (!ind_trystore(state->vars, indices, size, v, &state->vars)) {
            char *x = indices_string(indices, size);
            ctx_failure(*pctx, "Store: bad address: %s", x);
            free(x);
            return;
        }
    }
    else {
        if (ai != NULL) {
            ai->indices = es->indices;
            ai->n = es->n;
            ai->load = is_sequential(state->seqs, ai->indices, ai->n);
        }
        if (!ind_trystore(state->vars, es->indices, es->n, v, &state->vars)) {
            ctx_failure(*pctx, "Store: bad variable");
            return;
        }
    }
    (*pctx)->pc++;
}

void op_Store(const void *env, struct state *state, struct context **pctx){
    ext_Store(env, state, pctx, NULL);
}

void op_StoreVar(const void *env, struct state *state, struct context **pctx){
    const struct env_StoreVar *es = env;
    uint64_t v = ctx_pop(pctx);

    assert(((*pctx)->vars & VALUE_MASK) == VALUE_DICT);
    if (es == NULL) {
        uint64_t av = ctx_pop(pctx);
        assert((av & VALUE_MASK) == VALUE_ADDRESS);
        assert(av != VALUE_ADDRESS);

        int size;
        uint64_t *indices = value_get(av, &size);
        size /= sizeof(uint64_t);

        if (!ind_trystore((*pctx)->vars, indices, size, v, &(*pctx)->vars)) {
            char *x = indices_string(indices, size);
            ctx_failure(*pctx, "StoreVar: bad address: %s", x);
            free(x);
            return;
        }
        (*pctx)->pc++;
    }
    else {
        var_match(*pctx, es->args, v);
        if ((*pctx)->failure == 0) {
            (*pctx)->pc++;
        }
    }
}

void op_Trap(const void *env, struct state *state, struct context **pctx){
    extern int code_len;

    (*pctx)->trap_pc = ctx_pop(pctx);
    if (((*pctx)->trap_pc & VALUE_MASK) != VALUE_PC) {
        ctx_failure(*pctx, "trap: not a method");
        return;
    }
    assert(((*pctx)->trap_pc >> VALUE_BITS) < code_len);
    assert(strcmp(code[(*pctx)->trap_pc >> VALUE_BITS].oi->name, "Frame") == 0);
    (*pctx)->trap_arg = ctx_pop(pctx);
    (*pctx)->pc++;
}

void *init_Address(struct dict *map){ return NULL; }
void *init_Apply(struct dict *map){ return NULL; }
void *init_Assert(struct dict *map){ return NULL; }
void *init_Assert2(struct dict *map){ return NULL; }
void *init_AtomicDec(struct dict *map){ return NULL; }
void *init_AtomicInc(struct dict *map){ return NULL; }
void *init_Choose(struct dict *map){ return NULL; }
void *init_Continue(struct dict *map){ return NULL; }
void *init_Del(struct dict *map){ return NULL; }
void *init_Dup(struct dict *map){ return NULL; }
void *init_Go(struct dict *map){ return NULL; }
void *init_Pop(struct dict *map){ return NULL; }
void *init_ReadonlyDec(struct dict *map){ return NULL; }
void *init_ReadonlyInc(struct dict *map){ return NULL; }
void *init_Return(struct dict *map){ return NULL; }
void *init_Sequential(struct dict *map){ return NULL; }
void *init_SetIntLevel(struct dict *map){ return NULL; }
void *init_Spawn(struct dict *map){ return NULL; }
void *init_Trap(struct dict *map){ return NULL; }

void *init_Cut(struct dict *map){
    struct env_Cut *env = new_alloc(struct env_Cut);
    struct json_value *set = dict_lookup(map, "set", 3);
    assert(set->type == JV_ATOM);
    env->set = value_put_atom(set->u.atom.base, set->u.atom.len);
    struct json_value *var = dict_lookup(map, "var", 3);
    assert(var->type == JV_ATOM);
    env->var = value_put_atom(var->u.atom.base, var->u.atom.len);
    return env;
}

void *init_DelVar(struct dict *map){
    struct env_DelVar *env = new_alloc(struct env_DelVar);
    struct json_value *name = dict_lookup(map, "value", 5);
    assert(name->type == JV_ATOM);
    env->name = value_put_atom(name->u.atom.base, name->u.atom.len);
    return env;
}

void *init_Frame(struct dict *map){
    struct env_Frame *env = new_alloc(struct env_Frame);

    struct json_value *name = dict_lookup(map, "name", 4);
    assert(name->type == JV_ATOM);
    env->name = value_put_atom(name->u.atom.base, name->u.atom.len);

    struct json_value *args = dict_lookup(map, "args", 4);
    assert(args->type == JV_ATOM);
    int index = 0;
    env->args = var_parse(args->u.atom.base, args->u.atom.len, &index);

    return env;
}

void *init_IncVar(struct dict *map){
    struct env_IncVar *env = new_alloc(struct env_IncVar);
    struct json_value *name = dict_lookup(map, "value", 5);
    assert(name->type == JV_ATOM);
    env->name = value_put_atom(name->u.atom.base, name->u.atom.len);
    return env;
}

void *init_Load(struct dict *map){
    struct json_value *jv = dict_lookup(map, "value", 5);
    if (jv == NULL) {
        return NULL;
    }
    assert(jv->type == JV_LIST);
    struct env_Load *env = new_alloc(struct env_Load);
    env->n = jv->u.list.nvals;
    env->indices = malloc(env->n * sizeof(uint64_t));
    for (int i = 0; i < env->n; i++) {
        struct json_value *index = jv->u.list.vals[i];
        assert(index->type == JV_MAP);
        env->indices[i] = value_from_json(index->u.map);
    }
    return env;
}

void *init_LoadVar(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    if (value == NULL) {
        return NULL;
    }
    else {
        struct env_LoadVar *env = new_alloc(struct env_LoadVar);
        assert(value->type == JV_ATOM);
        env->name = value_put_atom(value->u.atom.base, value->u.atom.len);
        return env;
    }
}

void *init_Move(struct dict *map){
    struct env_Move *env = new_alloc(struct env_Move);

    struct json_value *offset = dict_lookup(map, "offset", 6);
    assert(offset->type == JV_ATOM);
    char *copy = malloc(offset->u.atom.len + 1);
    memcpy(copy, offset->u.atom.base, offset->u.atom.len);
    copy[offset->u.atom.len] = 0;
    env->offset = atoi(copy);
    free(copy);

    return env;
}

void *init_Nary(struct dict *map){
    struct env_Nary *env = new_alloc(struct env_Nary);

    struct json_value *arity = dict_lookup(map, "arity", 5);
    assert(arity->type == JV_ATOM);
    char *copy = malloc(arity->u.atom.len + 1);
    memcpy(copy, arity->u.atom.base, arity->u.atom.len);
    copy[arity->u.atom.len] = 0;
    env->arity = atoi(copy);
    free(copy);

    struct json_value *op = dict_lookup(map, "value", 5);
    assert(op->type == JV_ATOM);
    struct f_info *fi = dict_lookup(f_map, op->u.atom.base, op->u.atom.len);
    if (fi == NULL) {
        fprintf(stderr, "Nary: unknown function '%.*s'\n", op->u.atom.len, op->u.atom.base);
        exit(1);
    }
    env->fi = fi;

    return env;
}

void *init_Invariant(struct dict *map){
    struct env_Invariant *env = new_alloc(struct env_Invariant);

    struct json_value *cnt = dict_lookup(map, "cnt", 3);
    assert(cnt->type == JV_ATOM);
    char *copy = malloc(cnt->u.atom.len + 1);
    memcpy(copy, cnt->u.atom.base, cnt->u.atom.len);
    copy[cnt->u.atom.len] = 0;
    env->cnt = atoi(copy);
    free(copy);
    return env;
}

void *init_Jump(struct dict *map){
    struct env_Jump *env = new_alloc(struct env_Jump);

    struct json_value *pc = dict_lookup(map, "pc", 2);
    assert(pc->type == JV_ATOM);
    char *copy = malloc(pc->u.atom.len + 1);
    memcpy(copy, pc->u.atom.base, pc->u.atom.len);
    copy[pc->u.atom.len] = 0;
    env->pc = atoi(copy);
    free(copy);
    return env;
}

void *init_JumpCond(struct dict *map){
    struct env_JumpCond *env = new_alloc(struct env_JumpCond);

    struct json_value *pc = dict_lookup(map, "pc", 2);
    assert(pc->type == JV_ATOM);
    char *copy = malloc(pc->u.atom.len + 1);
    memcpy(copy, pc->u.atom.base, pc->u.atom.len);
    copy[pc->u.atom.len] = 0;
    env->pc = atoi(copy);
    free(copy);

    struct json_value *cond = dict_lookup(map, "cond", 4);
    assert(cond->type == JV_MAP);
    env->cond = value_from_json(cond->u.map);

    return env;
}

void *init_Push(struct dict *map){
    struct json_value *jv = dict_lookup(map, "value", 5);
    assert(jv->type == JV_MAP);
    struct env_Push *env = new_alloc(struct env_Push);
    env->value = value_from_json(jv->u.map);
    return env;
}

void *init_Split(struct dict *map){
    struct env_Split *env = new_alloc(struct env_Split);

    struct json_value *count = dict_lookup(map, "count", 5);
    assert(count->type == JV_ATOM);
    char *copy = malloc(count->u.atom.len + 1);
    memcpy(copy, count->u.atom.base, count->u.atom.len);
    copy[count->u.atom.len] = 0;
    env->count = atoi(copy);
    free(copy);
    return env;
}

void *init_Stop(struct dict *map){
    struct json_value *jv = dict_lookup(map, "value", 5);
    if (jv == NULL) {
        return NULL;
    }
    assert(jv->type == JV_LIST);
    struct env_Stop *env = new_alloc(struct env_Stop);
    env->n = jv->u.list.nvals;
    env->indices = malloc(env->n * sizeof(uint64_t));
    for (int i = 0; i < env->n; i++) {
        struct json_value *index = jv->u.list.vals[i];
        assert(index->type == JV_MAP);
        env->indices[i] = value_from_json(index->u.map);
    }
    return env;
}

void *init_Store(struct dict *map){
    struct json_value *jv = dict_lookup(map, "value", 5);
    if (jv == NULL) {
        return NULL;
    }
    assert(jv->type == JV_LIST);
    struct env_Store *env = new_alloc(struct env_Store);
    env->n = jv->u.list.nvals;
    env->indices = malloc(env->n * sizeof(uint64_t));
    for (int i = 0; i < env->n; i++) {
        struct json_value *index = jv->u.list.vals[i];
        assert(index->type == JV_MAP);
        env->indices[i] = value_from_json(index->u.map);
    }
    return env;
}

void *init_StoreVar(struct dict *map){
    struct json_value *jv = dict_lookup(map, "value", 5);
    if (jv == NULL) {
        return NULL;
    }
    else {
        assert(jv->type == JV_ATOM);
        struct env_StoreVar *env = new_alloc(struct env_StoreVar);
        int index = 0;
        env->args = var_parse(jv->u.atom.base, jv->u.atom.len, &index);
        return env;
    }
}

uint64_t f_abs(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    int64_t e = args[0];
    if ((e & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "abs() can only be applied to integers");
    }
    e >>= VALUE_BITS;
    return e >= 0 ? args[0] : (((-e) << VALUE_BITS) | VALUE_INT);
}

uint64_t f_all(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
	if (e == VALUE_SET || e == VALUE_DICT) {
		return VALUE_TRUE;
    }
    if ((e & VALUE_MASK) == VALUE_SET) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= sizeof(uint64_t);
        for (int i = 0; i < size; i++) {
            if ((v[i] & VALUE_MASK) != VALUE_BOOL) {
                return ctx_failure(ctx, "set.all() can only be applied to booleans");
            }
            if (v[i] == VALUE_FALSE) {
                return VALUE_FALSE;
            }
        }
		return VALUE_TRUE;
    }
    if ((e & VALUE_MASK) == VALUE_DICT) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= 2 * sizeof(uint64_t);
        for (int i = 0; i < size; i++) {
            if ((v[2*i+1] & VALUE_MASK) != VALUE_BOOL) {
                return ctx_failure(ctx, "dict.all() can only be applied to booleans");
            }
            if (v[2*i+1] == VALUE_FALSE) {
                return VALUE_FALSE;
            }
        }
		return VALUE_TRUE;
    }
    return ctx_failure(ctx, "all() can only be applied to sets or dictionaries");
}

uint64_t f_any(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
	if (e == VALUE_SET || e == VALUE_DICT) {
		return VALUE_FALSE;
    }
    if ((e & VALUE_MASK) == VALUE_SET) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= sizeof(uint64_t);
        for (int i = 0; i < size; i++) {
            if ((v[i] & VALUE_MASK) != VALUE_BOOL) {
                return ctx_failure(ctx, "set.any() can only be applied to booleans");
            }
            if (v[i] != VALUE_FALSE) {
                return VALUE_TRUE;
            }
        }
		return VALUE_FALSE;
    }
    if ((e & VALUE_MASK) == VALUE_DICT) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= 2 * sizeof(uint64_t);
        for (int i = 0; i < size; i++) {
            if ((v[2*i+1] & VALUE_MASK) != VALUE_BOOL) {
                return ctx_failure(ctx, "dict.any() can only be applied to booleans");
            }
            if (v[2*i+1] != VALUE_FALSE) {
                return VALUE_TRUE;
            }
        }
		return VALUE_FALSE;
    }
    return ctx_failure(ctx, "any() can only be applied to sets or dictionaries");
}

uint64_t nametag(struct context *ctx){
    uint64_t nt = dict_store(VALUE_DICT,
            (0 << VALUE_BITS) | VALUE_INT, ctx->entry);
    return dict_store(nt,
            (1 << VALUE_BITS) | VALUE_INT, ctx->arg);
}

uint64_t f_atLabel(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    if (ctx->atomic == 0) {
        return ctx_failure(ctx, "atLabel: can only be called in atomic mode");
    }
    uint64_t e = args[0];
    if ((e & VALUE_MASK) != VALUE_PC) {
        return ctx_failure(ctx, "atLabel: not a method");
    }
    e >>= VALUE_BITS;

    int size;
    uint64_t *vals = value_get(state->ctxbag, &size);
    size /= sizeof(uint64_t);
    assert(size > 0);
    assert(size % 2 == 0);
    uint64_t bag = VALUE_DICT;
    for (int i = 0; i < size; i += 2) {
        assert((vals[i] & VALUE_MASK) == VALUE_CONTEXT);
        assert((vals[i+1] & VALUE_MASK) == VALUE_INT);
        struct context *ctx = value_get(vals[i], NULL);
        if (ctx->pc == e) {
            bag = bag_add(bag, nametag(ctx));
        }
    }
    return bag;
}

uint64_t f_div(struct state *state, struct context *ctx, uint64_t *args, int n){
    int64_t e1 = args[0], e2 = args[1];
    if ((e1 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "right argument to / not an integer");
    }
    if ((e2 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "left argument to / not an integer");
    }
    e1 >>= VALUE_BITS;
    if (e1 == 0) {
        return ctx_failure(ctx, "divide by zero");
    }
    int64_t result = (e2 >> VALUE_BITS) / e1;
    return (result << VALUE_BITS) | VALUE_INT;
}

uint64_t f_eq(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    return ((args[0] == args[1]) << VALUE_BITS) | VALUE_BOOL;
}

uint64_t f_ge(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int cmp = value_cmp(args[1], args[0]);
    return ((cmp >= 0) << VALUE_BITS) | VALUE_BOOL;
}

uint64_t f_gt(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int cmp = value_cmp(args[1], args[0]);
    return ((cmp > 0) << VALUE_BITS) | VALUE_BOOL;
}

uint64_t f_ne(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    return ((args[0] != args[1]) << VALUE_BITS) | VALUE_BOOL;
}

uint64_t f_in(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    uint64_t s = args[0], e = args[1];
	if (s == VALUE_SET || s == VALUE_DICT) {
		return VALUE_FALSE;
	}
    if ((s & VALUE_MASK) == VALUE_SET) {
        int size;
        uint64_t *v = value_get(s, &size);
        size /= sizeof(uint64_t);
        for (int i = 0; i < size; i++) {
            if (v[i] == e) {
                return VALUE_TRUE;
            }
        }
        return VALUE_FALSE;
    }
    if ((s & VALUE_MASK) == VALUE_DICT) {
        int size;
        uint64_t *v = value_get(s, &size);
        size /= 2 * sizeof(uint64_t);
        for (int i = 0; i < size; i++) {
            if (v[2*i+1] == e) {
                return VALUE_TRUE;
            }
        }
        return VALUE_FALSE;
    }
    return ctx_failure(ctx, "'in' can only be applied to sets or dictionaries");
}

uint64_t f_intersection(struct state *state, struct context *ctx, uint64_t *args, int n){
    uint64_t e1 = args[0];

    if ((e1 & VALUE_MASK) == VALUE_INT) {
        for (int i = 1; i < n; i++) {
            uint64_t e2 = args[i];
            if ((e2 & VALUE_MASK) != VALUE_INT) {
                return ctx_failure(ctx, "'&' applied to mix of ints and other types");
            }
            e1 &= e2;
        }
        return e1;
    }
	if (e1 == VALUE_SET) {
		return VALUE_SET;
	}
    if ((e1 & VALUE_MASK) == VALUE_SET) {
        // get all the sets
		assert(n > 0);
        struct val_info *vi = malloc(n * sizeof(*vi));
		vi[0].vals = value_get(args[0], &vi[0].size); 
		vi[0].index = 0;
        int min_size = vi[0].size;              // minimum set size
        uint64_t max_val = vi[0].vals[0];       // maximum value over the minima of all sets
        for (int i = 1; i < n; i++) {
            if ((args[i] & VALUE_MASK) != VALUE_SET) {
                return ctx_failure(ctx, "'&' applied to mix of sets and other types");
            }
            if (args[i] == VALUE_SET) {
                min_size = 0;
            }
            else {
                vi[i].vals = value_get(args[i], &vi[i].size); 
                vi[i].index = 0;
				if (vi[i].size < min_size) {
					min_size = vi[i].size;
				}
				if (value_cmp(vi[i].vals[0], max_val) > 0) {
					max_val = vi[i].vals[0];
				}
            }
        }

        // If any are empty lists, we're done.
        if (min_size == 0) {
            return VALUE_SET;
        }

        // Allocate sufficient memory.
        uint64_t *vals = malloc((size_t) min_size), *v = vals;

        bool done = false;
        for (int i = 0; i < min_size; i++) {
            uint64_t old_max = max_val;
            for (int j = 0; j < n; j++) {
                int k, size = vi[j].size / sizeof(uint64_t);
                while ((k = vi[j].index) < size) {
                    uint64_t v = vi[j].vals[k];
                    int cmp = value_cmp(v, max_val);
                    if (cmp > 0) {
                        max_val = v;
                    }
                    if (cmp >= 0) {
                        break;
                    }
                    vi[j].index++;
                }
                if (vi[j].index == size) {
                    done = true;
                    break;
                }
            }
            if (done) {
                break;
            }
            if (old_max == max_val) {
                *v++ = max_val;
                for (int j = 0; j < n; j++) {
                    assert(vi[j].index < vi[j].size / sizeof(uint64_t));
                    vi[j].index++;
                    int k, size = vi[j].size / sizeof(uint64_t);
                    if ((k = vi[j].index) == size) {
                        done = true;
                        break;
                    }
                    if (value_cmp(vi[j].vals[k], max_val) > 0) {
                        max_val = vi[j].vals[k];
                    }
                }
            }
            if (done) {
                break;
            }
        }

        uint64_t result = value_put_set(vals, (char *) v - (char *) vals);
        free(vi);
        free(vals);
        return result;
    }

	if (e1 == VALUE_DICT) {
		return VALUE_DICT;
	}
    if ((e1 & VALUE_MASK) != VALUE_DICT) {
        return ctx_failure(ctx, "'&' can only be applied to ints and dicts");
    }
    // get all the dictionaries
    struct val_info *vi = malloc(n * sizeof(*vi));
    int total = 0;
    for (int i = 0; i < n; i++) {
        if ((args[i] & VALUE_MASK) != VALUE_DICT) {
            return ctx_failure(ctx, "'&' applied to mix of dictionaries and other types");
        }
        if (args[i] == VALUE_DICT) {
            vi[i].vals = NULL;
            vi[i].size = 0;
        }
        else {
            vi[i].vals = value_get(args[i], &vi[i].size); 
            total += vi[i].size;
        }
    }

    // If all are empty dictionaries, we're done.
    if (total == 0) {
        return VALUE_DICT;
    }

    // Concatenate the dictionaries
    uint64_t *vals = malloc(total);
    total = 0;
    for (int i = 0; i < n; i++) {
        memcpy((char *) vals + total, vi[i].vals, vi[i].size);
        total += vi[i].size;
    }

    // sort lexicographically, leaving duplicate keys
    int cnt = total / (2 * sizeof(uint64_t));
    qsort(vals, cnt, 2 * sizeof(uint64_t), q_kv_cmp);

    // now only leave the min value for duplicate keys
    int in = 0, out = 0;
    for (;;) {
        // if there are fewer than n copies of the key, then it's out
        if (in + n > cnt) {
            break;
        }
        int i;
        for (i = in + 1; i < in + n; i++) {
            if (vals[2*i] != vals[2*in]) {
                break;
            }
        }
        if (i == in + n) {
            // copy over the first value
            vals[2*out] = vals[2*in];
            vals[2*out+1] = vals[2*in+1];
            out++;
        }
        in = i;
    }

    uint64_t result = value_put_dict(vals, 2 * out * sizeof(uint64_t));
    free(vi);
    free(vals);
    return result;
}

uint64_t f_invert(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    int64_t e = args[0];
    if ((e & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "~ can only be applied to ints");
    }
    e >>= VALUE_BITS;
    return ((~e) << VALUE_BITS) | VALUE_INT;
}

uint64_t f_isEmpty(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
    if ((e & VALUE_MASK) == VALUE_DICT) {
        return ((e == VALUE_DICT) << VALUE_BITS) | VALUE_BOOL;
    }
    if ((e & VALUE_MASK) == VALUE_SET) {
        return ((e == VALUE_SET) << VALUE_BITS) | VALUE_BOOL;
    }
    panic("op_isEmpty: not a set or dict");
    return 0;
}

uint64_t f_keys(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t v = args[0];
    if ((v & VALUE_MASK) != VALUE_DICT) {
        return ctx_failure(ctx, "keys() can only be applied to dictionaries");
    }
    if (v == VALUE_DICT) {
        return VALUE_SET;
    }

    int size;
    uint64_t *vals = value_get(v, &size);
    uint64_t *keys = malloc(size / 2);
    size /= 2 * sizeof(uint64_t);
    for (int i = 0; i < size; i++) {
        keys[i] = vals[2*i];
    }
    uint64_t result = value_put_set(keys, size * sizeof(uint64_t));
    free(keys);
    return result;
}

uint64_t f_len(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
	if (e == VALUE_SET || e == VALUE_DICT) {
		return VALUE_INT;
	}
    if ((e & VALUE_MASK) == VALUE_SET) {
        int size;
        (void) value_get(e, &size);
        size /= sizeof(uint64_t);
        return (size << VALUE_BITS) | VALUE_INT;
    }
    if ((e & VALUE_MASK) == VALUE_DICT) {
        int size;
        (void) value_get(e, &size);
        size /= 2 * sizeof(uint64_t);
        return (size << VALUE_BITS) | VALUE_INT;
    }
    return ctx_failure(ctx, "len() can only be applied to sets or dictionaries");
}

uint64_t f_le(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int cmp = value_cmp(args[1], args[0]);
    return ((cmp <= 0) << VALUE_BITS) | VALUE_BOOL;
}

uint64_t f_lt(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int cmp = value_cmp(args[1], args[0]);
    return ((cmp < 0) << VALUE_BITS) | VALUE_BOOL;
}

uint64_t f_max(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
	if (e == VALUE_SET) {
        return ctx_failure(ctx, "can't apply max() to empty set");
    }
    if (e == VALUE_DICT) {
        return ctx_failure(ctx, "can't apply max() to empty list");
    }
    if ((e & VALUE_MASK) == VALUE_SET) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= sizeof(uint64_t);
        uint64_t max = v[0];
        for (int i = 1; i < size; i++) {
            if (value_cmp(v[i], max) > 0) {
                max = v[i];
            }
        }
		return max;
    }
    if ((e & VALUE_MASK) == VALUE_DICT) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= 2 * sizeof(uint64_t);
        uint64_t max = v[1];
        for (int i = 0; i < size; i++) {
            if (value_cmp(v[2*i+1], max) > 0) {
                max = v[2*i+1];
            }
        }
		return max;
    }
    return ctx_failure(ctx, "max() can only be applied to sets or lists");
}

uint64_t f_min(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
	if (e == VALUE_SET) {
        return ctx_failure(ctx, "can't apply min() to empty set");
    }
    if (e == VALUE_DICT) {
        return ctx_failure(ctx, "can't apply min() to empty list");
    }
    if ((e & VALUE_MASK) == VALUE_SET) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= sizeof(uint64_t);
        uint64_t min = v[0];
        for (int i = 1; i < size; i++) {
            if (value_cmp(v[i], min) < 0) {
                min = v[i];
            }
        }
		return min;
    }
    if ((e & VALUE_MASK) == VALUE_DICT) {
        int size;
        uint64_t *v = value_get(e, &size);
        size /= 2 * sizeof(uint64_t);
        uint64_t min = v[1];
        for (int i = 0; i < size; i++) {
            if (value_cmp(v[2*i+1], min) < 0) {
                min = v[2*i+1];
            }
        }
		return min;
    }
    return ctx_failure(ctx, "min() can only be applied to sets or lists");
}

uint64_t f_minus(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1 || n == 2);
    if (n == 1) {
        int64_t e = args[0];
        if ((e & VALUE_MASK) != VALUE_INT) {
            return ctx_failure(ctx, "unary minus can only be applied to ints");
        }
        e >>= VALUE_BITS;
        if (e == VALUE_MAX) {
            return ((uint64_t) VALUE_MIN << VALUE_BITS) | VALUE_INT;
        }
        if (e == VALUE_MIN) {
            return (VALUE_MAX << VALUE_BITS) | VALUE_INT;
        }
        if (-e <= VALUE_MIN || -e >= VALUE_MAX) {
            return ctx_failure(ctx, "unary minus overflow (model too large)");
        }
        return ((-e) << VALUE_BITS) | VALUE_INT;
    }
    else {
        if ((args[0] & VALUE_MASK) == VALUE_INT) {
            int64_t e1 = args[0], e2 = args[1];
            if ((e2 & VALUE_MASK) != VALUE_INT) {
                return ctx_failure(ctx, "minus applied to int and non-int");
            }
            e1 >>= VALUE_BITS;
            e2 >>= VALUE_BITS;
            int64_t result = e2 - e1;
            if (result <= VALUE_MIN || result >= VALUE_MAX) {
                return ctx_failure(ctx, "minus overflow (model too large)");
            }
            return (result << VALUE_BITS) | VALUE_INT;
        }

        uint64_t e1 = args[0], e2 = args[1];
        if ((e1 & VALUE_MASK) != VALUE_SET || (e2 & VALUE_MASK) != VALUE_SET) {
            return ctx_failure(ctx, "minus can only be applied to ints or sets");
        }
        int size1, size2;
        uint64_t *vals1, *vals2;
        if (e1 == VALUE_SET) {
            size1 = 0;
            vals1 = NULL;
        }
        else {
            vals1 = value_get(e1, &size1);
        }
        if (e2 == VALUE_SET) {
            size2 = 0;
            vals2 = NULL;
        }
        else {
            vals2 = value_get(e2, &size2);
        }
        uint64_t *vals = malloc(size2);
        size1 /= sizeof(uint64_t);
        size2 /= sizeof(uint64_t);

        uint64_t *p1 = vals1, *p2 = vals2, *q = vals;
        while (size1 > 0 && size2 > 0) {
            if (*p1 == *p2) {
                p1++; size1--;
                p2++; size2--;
            }
            else {
                int cmp = value_cmp(*p1, *p2);
                if (cmp < 0) {
                    p1++; size1--;
                }
                else {
                    assert(cmp > 0);
                    *q++ = *p2++; size2--;
                }
            }
        }
        while (size2 > 0) {
            *q++ = *p2++; size2--;
        }
        uint64_t result = value_put_set(vals, (char *) q - (char *) vals);
        free(vals);
        return result;
    }
}

uint64_t f_mod(struct state *state, struct context *ctx, uint64_t *args, int n){
    int64_t e1 = args[0], e2 = args[1];
    if ((e1 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "right argument to mod not an integer");
    }
    if ((e2 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "left argument to mod not an integer");
    }
    int64_t mod = (e1 >> VALUE_BITS);
    int64_t result = (e2 >> VALUE_BITS) % mod;
    if (result < 0) {
        result += mod;
    }
    return (result << VALUE_BITS) | VALUE_INT;
}

uint64_t f_get_context(struct state *state, struct context *ctx, uint64_t *args, int n){
    return value_put_context(ctx);
}

uint64_t f_not(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 1);
    uint64_t e = args[0];
    if ((e & VALUE_MASK) != VALUE_BOOL) {
        return ctx_failure(ctx, "not can only be applied to booleans");
    }
    return e ^ (1 << VALUE_BITS);
}

uint64_t f_plus(struct state *state, struct context *ctx, uint64_t *args, int n){
    int64_t e1 = args[0];
    if ((e1 & VALUE_MASK) == VALUE_INT) {
        e1 >>= VALUE_BITS;
        for (int i = 1; i < n; i++) {
            int64_t e2 = args[i];
            if ((e2 & VALUE_MASK) != VALUE_INT) {
                return ctx_failure(ctx,
                    "+: applied to mix of integers and other values");
            }
            e2 >>= VALUE_BITS;
            int64_t sum = e1 + e2;
            if (sum <= VALUE_MIN || sum >= VALUE_MAX) {
                return ctx_failure(ctx,
                    "+: integer overflow (model too large)");
            }
            e1 = sum;
        }
        return (e1 << VALUE_BITS) | VALUE_INT;
    }

    // get all the lists
    struct val_info *vi = malloc(n * sizeof(*vi));
    int total = 0;
    for (int i = 0; i < n; i++) {
        if ((args[i] & VALUE_MASK) != VALUE_DICT) {
            ctx_failure(ctx, "+: applied to mix of value types");
            free(vi);
            return 0;
        }
        if (args[i] == VALUE_DICT) {
            vi[i].vals = NULL;
            vi[i].size = 0;
        }
        else {
            vi[i].vals = value_get(args[i], &vi[i].size); 
            total += vi[i].size;
        }
    }

    // If all are empty lists, we're done.
    if (total == 0) {
        return VALUE_DICT;
    }

    // Concatenate the sets
    uint64_t *vals = malloc(total);
    total = 0;
    for (int i = n; --i >= 0;) {
        memcpy((char *) vals + total, vi[i].vals, vi[i].size);
        total += vi[i].size;
    }

    // Update the indices
    n = total / (2 * sizeof(uint64_t));
    for (int i = 0; i < n; i++) {
        vals[2*i] = (i << VALUE_BITS) | VALUE_INT;
    }
    uint64_t result = value_put_dict(vals, total);

    free(vi);
    free(vals);
    return result;
}

uint64_t f_power(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int64_t e1 = args[0], e2 = args[1];

    if ((e1 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "right argument to ** not an integer");
    }
    if ((e2 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "left argument to ** not an integer");
    }
    int64_t base = e2 >> VALUE_BITS;
    int64_t exp = e1 >> VALUE_BITS;
    if (exp == 0) {
        return (1 << VALUE_BITS) | VALUE_INT;
    }
    if (exp < 0) {
        return ctx_failure(ctx, "**: negative exponent");
    }

    int64_t result = 1, orig = base;
    for (;;) {
        if (exp & 1) {
            result *= base;
        }
        exp >>= 1;
        if (exp == 0) {
            break;
        }
        base *= base;
    }
    if (result < orig) {
        // TODO.  Improve overflow detection
        return ctx_failure(ctx, "**: overflow (model too large)");
    }

    return (result << VALUE_BITS) | VALUE_INT;
}

uint64_t f_range(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int64_t e1 = args[0], e2 = args[1];

    if ((e1 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "right argument to .. not an integer");
    }
    if ((e2 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "left argument to .. not an integer");
    }
    int64_t start = e2 >> VALUE_BITS;
    int64_t finish = e1 >> VALUE_BITS;
	if (finish < start) {
		return VALUE_SET;
	}
    int cnt = (finish - start) + 1;
	assert(cnt > 0);
	assert(cnt < 1000);		// seems unlikely...
    uint64_t *v = malloc(cnt * sizeof(uint64_t));
    for (int i = 0; i < cnt; i++) {
        v[i] = ((start + i) << VALUE_BITS) | VALUE_INT;
    }
    uint64_t result = value_put_set(v, cnt * sizeof(uint64_t));
    free(v);
    return result;
}

uint64_t f_dict_add(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 3);
    int64_t value = args[0], key = args[1], dict = args[2];
    assert((dict & VALUE_MASK) == VALUE_DICT);
    int size;
    uint64_t *vals = value_get(dict, &size), *v;

    int i = 0, cmp = 1;
    for (v = vals; i < size; i += 2 * sizeof(uint64_t), v += 2) {
        cmp = value_cmp(key, *v);
        if (cmp <= 0) {
            break;
        }
    }

    // See if we found the key.  In that case, we take the bigger value.
    if (cmp == 0) {
        cmp = value_cmp(value, v[1]);
        if (cmp <= 0) {
            return dict;
        }
        uint64_t *nvals = malloc(size);
        memcpy(nvals, vals, size);
        * (uint64_t *) ((char *) nvals + (i + sizeof(uint64_t))) = value;

        uint64_t result = value_put_dict(nvals, size);
        free(nvals);
        return result;
    }
    else {
        uint64_t *nvals = malloc(size + 2*sizeof(uint64_t));
        memcpy(nvals, vals, i);
        * (uint64_t *) ((char *) nvals + i) = key;
        * (uint64_t *) ((char *) nvals + (i + sizeof(uint64_t))) = value;
        memcpy((char *) nvals + i + 2*sizeof(uint64_t), v, size - i);

        uint64_t result = value_put_dict(nvals, size + 2*sizeof(uint64_t));
        free(nvals);
        return result;
    }
}

uint64_t f_set_add(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int64_t elt = args[0], set = args[1];
    assert((set & VALUE_MASK) == VALUE_SET);
    int size;
    uint64_t *vals = value_get(set, &size), *v;

    int i = 0;
    for (v = vals; i < size; i += sizeof(uint64_t), v++) {
        int cmp = value_cmp(elt, *v);
        if (cmp == 0) {
            return set;
        }
        if (cmp < 0) {
            break;
        }
    }

    uint64_t *nvals = malloc(size + sizeof(uint64_t));
    memcpy(nvals, vals, i);
    * (uint64_t *) ((char *) nvals + i) = elt;
    memcpy((char *) nvals + i + sizeof(uint64_t), v, size - i);

    uint64_t result = value_put_set(nvals, size + sizeof(uint64_t));
    free(nvals);
    return result;
}

uint64_t f_bag_add(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int64_t elt = args[0], dict = args[1];
    assert((dict & VALUE_MASK) == VALUE_DICT);
    int size;
    uint64_t *vals = value_get(dict, &size), *v;

    int i = 0, cmp = 1;
    for (v = vals; i < size; i += 2 * sizeof(uint64_t), v++) {
        cmp = value_cmp(elt, *v);
        if (cmp <= 0) {
            break;
        }
    }

    if (cmp == 0) {
        assert((v[1] & VALUE_MASK) == VALUE_INT);
        int cnt = (v[1] >> VALUE_BITS) + 1;
        uint64_t *nvals = malloc(size);
        memcpy(nvals, vals, size);
        * (uint64_t *) ((char *) nvals + (i + sizeof(uint64_t))) =
                                        (cnt << VALUE_BITS) | VALUE_INT;

        uint64_t result = value_put_dict(nvals, size);
        free(nvals);
        return result;
    }
    else {
        uint64_t *nvals = malloc(size + 2*sizeof(uint64_t));
        memcpy(nvals, vals, i);
        * (uint64_t *) ((char *) nvals + i) = elt;
        * (uint64_t *) ((char *) nvals + (i + sizeof(uint64_t))) =
                                        (1 << VALUE_BITS) | VALUE_INT;
        memcpy((char *) nvals + i + 2*sizeof(uint64_t), v, size - i);

        uint64_t result = value_put_dict(nvals, size + 2*sizeof(uint64_t));
        free(nvals);
        return result;
    }
}

uint64_t f_shiftleft(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int64_t e1 = args[0], e2 = args[1];

    if ((e1 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "right argument to << not an integer");
    }
    if ((e2 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "left argument to << not an integer");
    }
    e1 >>= VALUE_BITS;
    if (e1 < 0) {
        return ctx_failure(ctx, "<<: negative shift count");
    }
    e2 >>= VALUE_BITS;
    int64_t result = e2 << e1;
    if (((result << VALUE_BITS) >> VALUE_BITS) != result) {
        return ctx_failure(ctx, "<<: overflow (model too large)");
    }
    if (result <= VALUE_MIN || result >= VALUE_MAX) {
        return ctx_failure(ctx, "<<: overflow (model too large)");
    }
    return (result << VALUE_BITS) | VALUE_INT;
}

uint64_t f_shiftright(struct state *state, struct context *ctx, uint64_t *args, int n){
    assert(n == 2);
    int64_t e1 = args[0], e2 = args[1];

    if ((e1 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "right argument to >> not an integer");
    }
    if ((e2 & VALUE_MASK) != VALUE_INT) {
        return ctx_failure(ctx, "left argument to >> not an integer");
    }
    if (e1 < 0) {
        return ctx_failure(ctx, ">>: negative shift count");
    }
    e1 >>= VALUE_BITS;
    e2 >>= VALUE_BITS;
    return ((e2 >> e1) << VALUE_BITS) | VALUE_INT;
}

uint64_t f_times(struct state *state, struct context *ctx, uint64_t *args, int n){
    int64_t result = 1;
    int list = -1;
    for (int i = 0; i < n; i++) {
        int64_t e = args[i];
        if ((e & VALUE_MASK) == VALUE_DICT) {
            if (list >= 0) {
                return ctx_failure(ctx, "* can only have at most one list");
            }
            list = i;
        }
        else {
            if ((e & VALUE_MASK) != VALUE_INT) {
                return ctx_failure(ctx,
                    "* can only be applied to integers and at most one list");
            }
            e >>= VALUE_BITS;
            if (e == 0) {
                result = 0;
            }
            else {
                int64_t product = result * e;
                if (product / result != e) {
                    return ctx_failure(ctx, "*: overflow (model too large)");
                }
                result = product;
            }
        }
    }
    if (list < 0) {
        if (result != (result << VALUE_BITS) >> VALUE_BITS) {
            return ctx_failure(ctx, "*: overflow (model too large)");
        }
        return (result << VALUE_BITS) | VALUE_INT;
    }
    if (result == 0) {
        return VALUE_DICT;
    }
    int size;
    uint64_t *vals = value_get(args[list], &size);
    if (size == 0) {
        return VALUE_DICT;
    }
    uint64_t *r = malloc(result * size);
    unsigned int cnt = size / (2 * sizeof(uint64_t));
    int index = 0;
    for (int i = 0; i < result; i++) {
        for (int j = 0; j < cnt; j++) {
            r[2*index] = (index << VALUE_BITS) | VALUE_INT;
            r[2*index+1] = vals[2*j+1];
            index++;
        }
    }
    uint64_t v = value_put_dict(r, result * size);
    free(r);
    return v;
}

uint64_t f_union(struct state *state, struct context *ctx, uint64_t *args, int n){
    uint64_t e1 = args[0];

    if ((e1 & VALUE_MASK) == VALUE_INT) {
        for (int i = 1; i < n; i++) {
            uint64_t e2 = args[i];
            if ((e2 & VALUE_MASK) != VALUE_INT) {
                return ctx_failure(ctx, "'|' applied to mix of ints and other types");
            }
            e1 |= e2;
        }
        return e1;
    }

    if ((e1 & VALUE_MASK) == VALUE_SET) {
        // get all the sets
        struct val_info *vi = malloc(n * sizeof(*vi));
        int total = 0;
        for (int i = 0; i < n; i++) {
            if ((args[i] & VALUE_MASK) != VALUE_SET) {
                return ctx_failure(ctx, "'|' applied to mix of sets and other types");
            }
            if (args[i] == VALUE_SET) {
                vi[i].vals = NULL;
                vi[i].size = 0;
            }
            else {
                vi[i].vals = value_get(args[i], &vi[i].size); 
                total += vi[i].size;
            }
        }

        // If all are empty lists, we're done.
        if (total == 0) {
            return VALUE_SET;
        }

        // Concatenate the sets
        uint64_t *vals = malloc(total);
        total = 0;
        for (int i = 0; i < n; i++) {
            memcpy((char *) vals + total, vi[i].vals, vi[i].size);
            total += vi[i].size;
        }

        n = sort(vals, total / sizeof(uint64_t));
        uint64_t result = value_put_set(vals, n * sizeof(uint64_t));
        free(vi);
        free(vals);
        return result;
    }

    if ((e1 & VALUE_MASK) != VALUE_DICT) {
        return ctx_failure(ctx, "'|' can only be applied to ints and dicts");
    }
    // get all the dictionaries
    struct val_info *vi = malloc(n * sizeof(*vi));
    int total = 0;
    for (int i = 0; i < n; i++) {
        if ((args[i] & VALUE_MASK) != VALUE_DICT) {
            return ctx_failure(ctx, "'|' applied to mix of dictionaries and other types");
        }
        if (args[i] == VALUE_DICT) {
            vi[i].vals = NULL;
            vi[i].size = 0;
        }
        else {
            vi[i].vals = value_get(args[i], &vi[i].size); 
            total += vi[i].size;
        }
    }

    // If all are empty dictionaries, we're done.
    if (total == 0) {
        return VALUE_DICT;
    }

    // Concatenate the dictionaries
    uint64_t *vals = malloc(total);
    total = 0;
    for (int i = 0; i < n; i++) {
        memcpy((char *) vals + total, vi[i].vals, vi[i].size);
        total += vi[i].size;
    }

    // sort lexicographically, leaving duplicate keys
    int cnt = total / (2 * sizeof(uint64_t));
    qsort(vals, cnt, 2 * sizeof(uint64_t), q_kv_cmp);

    // now only leave the max value for duplicate keys
    n = 0;
    for (int i = 1; i < cnt; i++) {
        if (vals[2*i] != vals[2*n]) {
            n++;
        }
        vals[2*n] = vals[2*i];
        vals[2*n+1] = vals[2*i+1];
    }
    n++;

    uint64_t result = value_put_dict(vals, 2 * n * sizeof(uint64_t));
    free(vi);
    free(vals);
    return result;
}

uint64_t f_xor(struct state *state, struct context *ctx, uint64_t *args, int n){
    uint64_t e1 = args[0];

    if ((e1 & VALUE_MASK) == VALUE_INT) {
        for (int i = 1; i < n; i++) {
            uint64_t e2 = args[i];
            if ((e2 & VALUE_MASK) != VALUE_INT) {
                return ctx_failure(ctx, "'^' applied to mix of ints and other types");
            }
            e1 ^= e2;
        }
        return e1 | VALUE_INT;
    }

    // get all the sets
    struct val_info *vi = malloc(n * sizeof(*vi));
    int total = 0;
    for (int i = 0; i < n; i++) {
        if ((args[i] & VALUE_MASK) != VALUE_SET) {
            return ctx_failure(ctx, "'^' applied to mix of value types");
        }
        if (args[i] == VALUE_SET) {
            vi[i].vals = NULL;
            vi[i].size = 0;
        }
        else {
            vi[i].vals = value_get(args[i], &vi[i].size); 
            total += vi[i].size;
        }
    }

    // If all are empty lists, we're done.
    if (total == 0) {
        return VALUE_SET;
    }

    // Concatenate the sets
    uint64_t *vals = malloc(total);
    total = 0;
    for (int i = 0; i < n; i++) {
        memcpy((char *) vals + total, vi[i].vals, vi[i].size);
        total += vi[i].size;
    }

    // sort the values, but retain duplicates
    int cnt = total / sizeof(uint64_t);
    qsort(vals, cnt, sizeof(uint64_t), q_value_cmp);

    // Now remove the values that have an even number
    int i = 0, j = 0, k = 0;
    while (i < cnt) {
        while (i < cnt && vals[i] == vals[j]) {
            i++;
        }
        if ((i - j) % 2 != 0) {
            vals[k++] = vals[j];
        }
        j = i;
    }

    uint64_t result = value_put_set(vals, k * sizeof(uint64_t));
    free(vi);
    free(vals);
    return result;
}

struct op_info op_table[] = {
	{ "Address", init_Address, op_Address },
	{ "Apply", init_Apply, op_Apply },
	{ "Assert", init_Assert, op_Assert },
	{ "Assert2", init_Assert2, op_Assert2 },
	{ "AtomicDec", init_AtomicDec, op_AtomicDec },
	{ "AtomicInc", init_AtomicInc, op_AtomicInc },
	{ "Choose", init_Choose, op_Choose },
	{ "Continue", init_Continue, op_Continue },
	{ "Cut", init_Cut, op_Cut },
	{ "Del", init_Del, op_Del },
	{ "DelVar", init_DelVar, op_DelVar },
	{ "Dup", init_Dup, op_Dup },
	{ "Frame", init_Frame, op_Frame },
	{ "Go", init_Go, op_Go },
	{ "IncVar", init_IncVar, op_IncVar },
	{ "Invariant", init_Invariant, op_Invariant },
	{ "Jump", init_Jump, op_Jump },
	{ "JumpCond", init_JumpCond, op_JumpCond },
	{ "Load", init_Load, op_Load },
	{ "LoadVar", init_LoadVar, op_LoadVar },
	{ "Move", init_Move, op_Move },
	{ "Nary", init_Nary, op_Nary },
	{ "Pop", init_Pop, op_Pop },
	{ "Push", init_Push, op_Push },
	{ "ReadonlyDec", init_ReadonlyDec, op_ReadonlyDec },
	{ "ReadonlyInc", init_ReadonlyInc, op_ReadonlyInc },
	{ "Return", init_Return, op_Return },
	{ "Sequential", init_Sequential, op_Sequential },
	{ "SetIntLevel", init_SetIntLevel, op_SetIntLevel },
	{ "Spawn", init_Spawn, op_Spawn },
	{ "Split", init_Split, op_Split },
	{ "Stop", init_Stop, op_Stop },
	{ "Store", init_Store, op_Store },
	{ "StoreVar", init_StoreVar, op_StoreVar },
	{ "Trap", init_Trap, op_Trap },
    { NULL, NULL, NULL }
};

struct f_info f_table[] = {
	{ "+", f_plus },
	{ "-", f_minus },
	{ "~", f_invert },
	{ "*", f_times },
	{ "/", f_div },
	{ "//", f_div },
	{ "%", f_mod },
	{ "**", f_power },
	{ "<<", f_shiftleft },
	{ ">>", f_shiftright },
    { "<", f_lt },
    { "<=", f_le },
    { ">=", f_ge },
    { ">", f_gt },
    { "|", f_union },
    { "&", f_intersection },
    { "^", f_xor },
    { "..", f_range },
    { "==", f_eq },
    { "!=", f_ne },
    { "abs", f_abs },
    { "all", f_all },
    { "any", f_any },
    { "atLabel", f_atLabel },
    { "BagAdd", f_bag_add },
    { "DictAdd", f_dict_add },
    { "get_context", f_get_context },
    { "in", f_in },
    { "IsEmpty", f_isEmpty },
    { "keys", f_keys },
    { "len", f_len },
    { "max", f_max },
    { "min", f_min },
	{ "mod", f_mod },
    { "not", f_not },
    { "SetAdd", f_set_add },
    { NULL, NULL }
};

struct op_info *ops_get(char *opname, int size){
    return dict_lookup(ops_map, opname, size);
}

void ops_init(){
    ops_map = dict_new(0);
    f_map = dict_new(0);

    for (struct op_info *oi = op_table; oi->name != NULL; oi++) {
        void **p = dict_insert(ops_map, oi->name, strlen(oi->name));
        *p = oi;
    }
    for (struct f_info *fi = f_table; fi->name != NULL; fi++) {
        void **p = dict_insert(f_map, fi->name, strlen(fi->name));
        *p = fi;
    }
    this = value_put_atom("this", 4);
}

#include <stdlib.h>
#include <assert.h>

#ifndef HARMONY_COMBINE
#include "global.h"
#endif

#define MAX_CACHE	5000

static struct q_elt *queue_cache;
static unsigned int queue_csize;

struct q_elt {
	struct q_elt *next;
	void *item;
};

struct queue {
	struct q_elt *first, **last;
};

void queue_enqueue(struct queue *queue, void *item){
	struct q_elt *qe;

	if ((qe = queue_cache) == 0) {
		assert(queue_csize == 0);
		qe = new_alloc(struct q_elt);
	}
	else {
		assert(queue_csize > 0);
		queue_csize--;
		queue_cache = qe->next;
		qe->next = 0;
	}

	qe->item = item;
	*queue->last = qe;
	queue->last = &qe->next;
}

void queue_prepend(struct queue *queue, void *item){
	struct q_elt *qe;

	if ((qe = queue_cache) == 0) {
		assert(queue_csize == 0);
		qe = new_alloc(struct q_elt);
	}
	else {
		assert(queue_csize > 0);
		queue_csize--;
		queue_cache = qe->next;
	}

	qe->item = item;
    if ((qe->next = queue->first) == 0) {
        queue->last = &qe->next;
    }
    queue->first = qe;
}

bool queue_dequeue(struct queue *queue, void **item){
	struct q_elt *qe;

	if ((qe = queue->first) == 0) {
		return false;
	}
	if ((queue->first = qe->next) == 0) {
		queue->last = &queue->first;
	}
	*item = qe->item;

	if (queue_csize >= MAX_CACHE) {
		assert(queue_csize == MAX_CACHE);
		free(qe);
	}
	else {
		qe->next = queue_cache;
		queue_cache = qe;
		queue_csize++;
	}
	return true;
}

bool queue_empty(struct queue *queue){
    return queue->first == 0;
}

struct queue *queue_init(void){
	struct queue *q = new_alloc(struct queue);

	q->last = &q->first;
	return q;
}

void queue_release(struct queue *queue){
	assert(queue->last == &queue->first);
	free(queue);
}

void queue_cleanup(void){
	struct q_elt *qe;

	while ((qe = queue_cache) != 0) {
		assert(queue_csize > 0);
		queue_csize--;
		queue_cache = qe->next;
		free(qe);
	}
	assert(queue_csize == 0);
}

#define _GNU_SOURCE

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#ifndef HARMONY_COMBINE
#include "global.h"
#endif

static struct dict *atom_map;
static struct dict *dict_map;
static struct dict *set_map;
static struct dict *address_map;
static struct dict *context_map;

void *value_get(uint64_t v, int *psize){
    v &= ~VALUE_MASK;
    if (v == 0) {
        *psize = 0;
        return NULL;
    }
    return dict_retrieve((void *) v, psize);
}

void *value_copy(uint64_t v, int *psize){
    v &= ~VALUE_MASK;
    if (v == 0) {
        *psize = 0;
        return NULL;
    }
    int size;
    void *p = dict_retrieve((void *) v, &size);
    void *r = malloc(size);
    memcpy(r, p, size);
    if (psize != NULL) {
        *psize = size;
    }
    return r;
}

uint64_t value_put_atom(const void *p, int size){
    assert(size > 0);
    void *q = dict_find(atom_map, p, size);
    return (uint64_t) q | VALUE_ATOM;
}

uint64_t value_put_set(void *p, int size){
    if (size == 0) {
        return VALUE_SET;
    }
    void *q = dict_find(set_map, p, size);
    return (uint64_t) q | VALUE_SET;
}

uint64_t value_put_dict(void *p, int size){
    if (size == 0) {
        return VALUE_DICT;
    }
    void *q = dict_find(dict_map, p, size);
    return (uint64_t) q | VALUE_DICT;
}

uint64_t value_put_address(void *p, int size){
    if (size == 0) {
        return VALUE_ADDRESS;
    }
    void *q = dict_find(address_map, p, size);
    return (uint64_t) q | VALUE_ADDRESS;
}

uint64_t value_put_context(struct context *ctx){
	assert(ctx->pc >= 0);
    int size = sizeof(*ctx) + (ctx->sp * sizeof(uint64_t));
    void *q = dict_find(context_map, ctx, size);
    return (uint64_t) q | VALUE_CONTEXT;
}

int value_cmp_bool(uint64_t v1, uint64_t v2){
    return v1 == 0 ? -1 : 1;
}

int value_cmp_int(uint64_t v1, uint64_t v2){
    return (int64_t) v1 < (int64_t) v2 ? -1 : 1;
}

int value_cmp_atom(uint64_t v1, uint64_t v2){
    void *p1 = (void *) v1, *p2 = (void *) v2;
    int size1, size2;
    char *s1 = dict_retrieve(p1, &size1);
    char *s2 = dict_retrieve(p2, &size2);
    int size = size1 < size2 ? size1 : size2;
    int cmp = strncmp(s1, s2, size);
    if (cmp != 0) {
        return cmp;
    }
    return size1 < size2 ? -1 : 1;
}

int value_cmp_pc(uint64_t v1, uint64_t v2){
    panic("value_cmp_pc: not yet implemented");
    return 0;
}

int value_cmp_dict(uint64_t v1, uint64_t v2){
    if (v1 == 0) {
        return v2 == 0 ? 0 : -1;
    }
    if (v2 == 0) {
        return 1;
    }
    void *p1 = (void *) v1, *p2 = (void *) v2;
    int size1, size2;
    uint64_t *vals1 = dict_retrieve(p1, &size1);
    uint64_t *vals2 = dict_retrieve(p2, &size2);
    size1 /= sizeof(uint64_t);
    size2 /= sizeof(uint64_t);
    int size = size1 < size2 ? size1 : size2;
    for (int i = 0; i < size; i++) {
        int cmp = value_cmp(vals1[i], vals2[i]);
        if (cmp != 0) {
            return cmp;
        }
    }
    return size1 < size2 ? -1 : 1;
}

int value_cmp_set(uint64_t v1, uint64_t v2){
    if (v1 == 0) {
        return v2 == 0 ? 0 : -1;
    }
    if (v2 == 0) {
        return 1;
    }
    void *p1 = (void *) v1, *p2 = (void *) v2;
    int size1, size2;
    uint64_t *vals1 = dict_retrieve(p1, &size1);
    uint64_t *vals2 = dict_retrieve(p2, &size2);
    size1 /= sizeof(uint64_t);
    size2 /= sizeof(uint64_t);
    int size = size1 < size2 ? size1 : size2;
    for (int i = 0; i < size; i++) {
        int cmp = value_cmp(vals1[i], vals2[i]);
        if (cmp != 0) {
            return cmp;
        }
    }
    return size1 < size2 ? -1 : 1;
}

int value_cmp_address(uint64_t v1, uint64_t v2){
    if (v1 == 0) {
        return v2 == 0 ? 0 : -1;
    }
    if (v2 == 0) {
        return 1;
    }
    void *p1 = (void *) v1, *p2 = (void *) v2;
    int size1, size2;
    uint64_t *vals1 = dict_retrieve(p1, &size1);
    uint64_t *vals2 = dict_retrieve(p2, &size2);
    size1 /= sizeof(uint64_t);
    size2 /= sizeof(uint64_t);
    int size = size1 < size2 ? size1 : size2;
    for (int i = 0; i < size; i++) {
        int cmp = value_cmp(vals1[i], vals2[i]);
        if (cmp != 0) {
            return cmp;
        }
    }
    return size1 < size2 ? -1 : 1;
}

// TODO.  Maybe should compare name tag, pc, ...
int value_cmp_context(uint64_t v1, uint64_t v2){
    void *p1 = (void *) v1, *p2 = (void *) v2;
    int size1, size2;
    char *s1 = dict_retrieve(p1, &size1);
    char *s2 = dict_retrieve(p2, &size2);
    int size = size1 < size2 ? size1 : size2;
    int cmp = memcmp(s1, s2, size);
    if (cmp != 0) {
        return cmp < 0 ? -1 : 1;
    }
    return size1 < size2 ? -1 : 1;
}

int value_cmp(uint64_t v1, uint64_t v2){
    if (v1 == v2) {
        return 0;
    }
    int t1 = v1 & VALUE_MASK;
    int t2 = v2 & VALUE_MASK;
    if (t1 != t2) {
        return t1 < t2 ? -1 : 1;
    }
    switch (t1) {
    case VALUE_BOOL:
        return value_cmp_bool(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_INT:
        return value_cmp_int(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_ATOM:
        return value_cmp_atom(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_PC:
        return value_cmp_pc(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_DICT:
        return value_cmp_dict(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_SET:
        return value_cmp_set(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_ADDRESS:
        return value_cmp_address(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    case VALUE_CONTEXT:
        return value_cmp_context(v1 & ~VALUE_MASK, v2 & ~VALUE_MASK);
    default:
        panic("value_cmp: bad value type");
        return 0;
    }
}

void alloc_printf(char **r, char *fmt, ...){
    va_list args;

    va_start(args, fmt);
    if (vasprintf(r, fmt, args) < 0) {
		panic("alloc_printf: vasprintf");
	}
    va_end(args);
}

void append_printf(char **p, char *fmt, ...){
    char *r;
    va_list args;

    va_start(args, fmt);
    if (vasprintf(&r, fmt, args) < 0) {
		panic("append_printf: vasprintf");
	}
    va_end(args);

    if (*p == 0) {
        *p = r;
    }
    else {
        int n = strlen(*p);
        int m = strlen(r);
        *p = realloc(*p, n + m + 1);
        strcpy(*p + n, r);
        free(r);
    }
}

static char *value_string_bool(uint64_t v) {
    char *r;
    if (v != 0 && v != (1 << VALUE_BITS)) {
        fprintf(stderr, "value_string_bool %"PRIu64"\n", v);
        panic("value_string_bool: bad value");
    }
    assert(v == 0 || v == (1 << VALUE_BITS));
    alloc_printf(&r, v == 0 ? "False" : "True");
    return r;
}

static char *value_json_bool(uint64_t v) {
    char *r;
    if (v != 0 && v != (1 << VALUE_BITS)) {
        fprintf(stderr, "value_json_bool %"PRIu64"\n", v);
        panic("value_json_bool: bad value");
    }
    assert(v == 0 || v == (1 << VALUE_BITS));
    alloc_printf(&r, "{ \"type\": \"bool\", \"value\": \"%s\" }", v == 0 ? "False" : "True");
    return r;
}

static char *value_string_int(uint64_t v) {
    int64_t w = ((int64_t) v) >> VALUE_BITS;
    char *r;

    if (w == VALUE_MAX) {
        alloc_printf(&r, "inf");
    }
    else if (w == VALUE_MIN) {
        alloc_printf(&r, "-inf");
    }
    else {
        alloc_printf(&r, "%"PRId64"", w);
    }
    return r;
}

static char *value_json_int(uint64_t v) {
    int64_t w = ((int64_t) v) >> VALUE_BITS;
    char *r;

    if (w == VALUE_MAX) {
        alloc_printf(&r, "{ \"type\": \"int\", \"value\": \"inf\" }");
    }
    else if (w == VALUE_MIN) {
        alloc_printf(&r, "{ \"type\": \"int\", \"value\": \"-inf\" }");
    }
    else {
        alloc_printf(&r, "{ \"type\": \"int\", \"value\": \"%"PRId64"\" }", w);
    }
    return r;
}

static char *value_string_atom(uint64_t v) {
    void *p = (void *) v;
    int size;
    char *s = dict_retrieve(p, &size), *r;
    alloc_printf(&r, ".%.*s", size, s);
    return r;
}

static char *value_json_atom(uint64_t v) {
    void *p = (void *) v;
    int size;
    char *s = dict_retrieve(p, &size), *r;
    assert(size > 0);
    if (size > 1 || (isprint(s[0]) && s[0] != '"' && s[0] != '\\')) {
        alloc_printf(&r, "{ \"type\": \"atom\", \"value\": \"%.*s\" }", size, s);
    }
    else {
        alloc_printf(&r, "{ \"type\": \"char\", \"value\": \"%02x\" }", s[0]);
    }
    return r;
}

static char *value_string_pc(uint64_t v) {
    char *r;
    assert((v >> VALUE_BITS) < 10000);      // debug
    alloc_printf(&r, "PC(%"PRIu64")", v >> VALUE_BITS);
    return r;
}

static char *value_json_pc(uint64_t v) {
    char *r;
    alloc_printf(&r, "{ \"type\": \"pc\", \"value\": \"%"PRIu64"\" }", v >> VALUE_BITS);
    return r;
}

static char *value_string_dict(uint64_t v) {
    char *r;

    if (v == 0) {
        alloc_printf(&r, "()");
        return r;
    }

    void *p = (void *) v;
    int size;
    uint64_t *vals = dict_retrieve(p, &size);
    size /= 2 * sizeof(uint64_t);

    bool islist = true;
    for (uint64_t i = 0; i < size; i++) {
        if (vals[2*i] != ((i << VALUE_BITS) | VALUE_INT)) {
            islist = false;
            break;
        }
    }

    if (islist) {
        alloc_printf(&r, "(");
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                append_printf(&r, ", ");
            }
            char *val = value_string(vals[2*i+1]);
            append_printf(&r, "%s", val);
            free(val);
        }
        append_printf(&r, ")");
    }
    else {
        alloc_printf(&r, "{ ");
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                append_printf(&r, ", ");
            }
            char *key = value_string(vals[2*i]);
            char *val = value_string(vals[2*i+1]);
            append_printf(&r, "%s: %s", key, val);
            free(key);
            free(val);
        }
        append_printf(&r, " }");
    }
    return r;
}

static char *value_json_dict(uint64_t v) {
    char *r;

    if (v == 0) {
        alloc_printf(&r, "{ \"type\": \"dict\", \"value\": [] }");
        return r;
    }

    void *p = (void *) v;
    int size;
    uint64_t *vals = dict_retrieve(p, &size);
    size /= 2 * sizeof(uint64_t);

    alloc_printf(&r, "{ \"type\": \"dict\", \"value\": [");
    for (int i = 0; i < size; i++) {
        if (i != 0) {
            append_printf(&r, ", ");
        }
        char *key = value_json(vals[2*i]);
        char *val = value_json(vals[2*i+1]);
        append_printf(&r, "{ \"key\": %s, \"value\": %s }", key, val);
        free(key);
        free(val);
    }
    append_printf(&r, " ] }");
    return r;
}

static char *value_string_set(uint64_t v) {
    char *r;

    if (v == 0) {
        alloc_printf(&r, "{}");
        return r;
    }

    void *p = (void *) v;
    int size;
    uint64_t *vals = dict_retrieve(p, &size);
    size /= sizeof(uint64_t);

    alloc_printf(&r, "{ ");
    for (int i = 0; i < size; i++) {
        char *val = value_string(vals[i]);
        if (i == 0) {
            append_printf(&r, "%s", val);
        }
        else {
            append_printf(&r, ", %s", val);
        }
        free(val);
    }
    append_printf(&r, " }");
    return r;
}

static char *value_json_set(uint64_t v) {
    char *r;

    if (v == 0) {
        alloc_printf(&r, "{ \"type\": \"set\", \"value\": [] }");
        return r;
    }

    void *p = (void *) v;
    int size;
    uint64_t *vals = dict_retrieve(p, &size);
    size /= sizeof(uint64_t);

    alloc_printf(&r, "{ \"type\": \"set\", \"value\": [");
    for (int i = 0; i < size; i++) {
        char *val = value_json(vals[i]);
        if (i == 0) {
            append_printf(&r, "%s", val);
        }
        else {
            append_printf(&r, ", %s", val);
        }
        free(val);
    }
    append_printf(&r, " ] }");
    return r;
}

char *indices_string(const uint64_t *vec, int size) {
    char *r;
    if (size == 0) {
        alloc_printf(&r, "None");
        return r;
    }
    char *s = value_string(vec[0]);
    assert(s[0] == '.');
    alloc_printf(&r, "?%s", s + 1);
    free(s);

    for (int i = 1; i < size; i++) {
        s = value_string(vec[i]);
        if (*s == '.') {
            append_printf(&r, "%s", s);
        }
        else {
            append_printf(&r, "[%s]", s);
        }
    }

    return r;
}

static char *value_string_address(uint64_t v) {
    if (v == 0) {
        char *r;
        alloc_printf(&r, "None");
        return r;
    }

    void *p = (void *) v;
    int size;
    uint64_t *indices = dict_retrieve(p, &size);
    size /= sizeof(uint64_t);
    assert(size > 0);
    return indices_string(indices, size);
}

static char *value_json_address(uint64_t v) {
    char *r;
    if (v == 0) {
        alloc_printf(&r, "{ \"type\": \"address\", \"value\": [] }");
        return r;
    }

    void *p = (void *) v;
    int size;
    uint64_t *vals = dict_retrieve(p, &size);
    size /= sizeof(uint64_t);
    assert(size > 0);
    alloc_printf(&r, "{ \"type\": \"address\", \"value\": [");
    for (int i = 0; i < size; i++) {
        char *val = value_json(vals[i]);
        if (i == 0) {
            append_printf(&r, "%s", val);
        }
        else {
            append_printf(&r, ", %s", val);
        }
        free(val);
    }

    append_printf(&r, " ] }");
    return r;
}

static char *value_string_context(uint64_t v) {
    struct context *ctx = value_get(v, NULL);
    char *name = value_string(ctx->name);
    char *r;
    alloc_printf(&r, "CONTEXT(%s, %d)", name, ctx->pc);
    free(name);
    return r;
}

static char *value_json_context(uint64_t v) {
    struct context *ctx = value_get(v, NULL);
    char *r, *val;
    alloc_printf(&r, "{ \"type\": \"context\", \"value\": {");

    val = value_json(ctx->name);
    append_printf(&r, "\"name\": %s", val);
    free(val);

    val = value_json(ctx->arg);
    append_printf(&r, ", \"arg\": %s", val);
    free(val);

    append_printf(&r, ", \"pc\": { \"type\": \"pc\", \"value\": \"%d\" }", ctx->pc);

    append_printf(&r, " } }");
    return r;
}

char *value_string(uint64_t v){
    switch (v & VALUE_MASK) {
    case VALUE_BOOL:
        return value_string_bool(v & ~VALUE_MASK);
    case VALUE_INT:
        return value_string_int(v & ~VALUE_MASK);
    case VALUE_ATOM:
        return value_string_atom(v & ~VALUE_MASK);
    case VALUE_PC:
        return value_string_pc(v & ~VALUE_MASK);
    case VALUE_DICT:
        return value_string_dict(v & ~VALUE_MASK);
    case VALUE_SET:
        return value_string_set(v & ~VALUE_MASK);
    case VALUE_ADDRESS:
        return value_string_address(v & ~VALUE_MASK);
    case VALUE_CONTEXT:
        return value_string_context(v & ~VALUE_MASK);
    default:
        panic("value_string: bad value type");
        return NULL;
    }
}

char *value_json(uint64_t v){
    switch (v & VALUE_MASK) {
    case VALUE_BOOL:
        return value_json_bool(v & ~VALUE_MASK);
    case VALUE_INT:
        return value_json_int(v & ~VALUE_MASK);
    case VALUE_ATOM:
        return value_json_atom(v & ~VALUE_MASK);
    case VALUE_PC:
        return value_json_pc(v & ~VALUE_MASK);
    case VALUE_DICT:
        return value_json_dict(v & ~VALUE_MASK);
    case VALUE_SET:
        return value_json_set(v & ~VALUE_MASK);
    case VALUE_ADDRESS:
        return value_json_address(v & ~VALUE_MASK);
    case VALUE_CONTEXT:
        return value_json_context(v & ~VALUE_MASK);
    default:
        panic("value_json: bad value type");
        return NULL;
    }
}

bool atom_cmp(json_buf_t buf, char *s){
    int n = strlen(s);
    if (n != buf.len) {
        return false;
    }
    return strncmp(buf.base, s, n) == 0;
}

uint64_t value_bool(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_ATOM);
    if (atom_cmp(value->u.atom, "False")) {
        return VALUE_BOOL;
    }
    if (atom_cmp(value->u.atom, "True")) {
        return (1 << VALUE_BITS) | VALUE_BOOL;
    }
    panic("value_bool: bad value");
    return 0;
}

uint64_t value_int(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_ATOM);
    uint64_t v;
    if (atom_cmp(value->u.atom, "inf")) {
        v = VALUE_MAX;
    }
    else if (atom_cmp(value->u.atom, "-inf")) {
        v = VALUE_MIN;
    }
    else {
        char *copy = malloc(value->u.atom.len + 1);
        memcpy(copy, value->u.atom.base, value->u.atom.len);
        copy[value->u.atom.len] = 0;
        v = atol(copy);
        free(copy);
    }
    return (v << VALUE_BITS) | VALUE_INT;
}

uint64_t value_pc(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_ATOM);
    char *copy = malloc(value->u.atom.len + 1);
    memcpy(copy, value->u.atom.base, value->u.atom.len);
    copy[value->u.atom.len] = 0;
    long v = atol(copy);
    free(copy);
    return (v << VALUE_BITS) | VALUE_PC;
}

uint64_t value_atom(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_ATOM);
	assert(value->u.atom.len > 0);
    void *p = dict_find(atom_map, value->u.atom.base, value->u.atom.len);
    return (uint64_t) p | VALUE_ATOM;
}

uint64_t value_char(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_ATOM);
    char *copy = malloc(value->u.atom.len + 1);
    memcpy(copy, value->u.atom.base, value->u.atom.len);
    copy[value->u.atom.len] = 0;
    unsigned long x;
    sscanf(copy, "%lx", &x);
    free(copy);
    if (x == 0) {
        printf("value_char: can't handle null characters yet\n");
    }
    else if (x != (x & 0x7F)) {
        printf("value_char: can only handle ASCII characters right now\n");
    }
    char v = x & 0x7F;
    void *p = dict_find(atom_map, &v, 1);
    return (uint64_t) p | VALUE_ATOM;
}

uint64_t value_dict(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_LIST);
    if (value->u.list.nvals == 0) {
        return VALUE_DICT;
    }
    uint64_t *vals = malloc(value->u.list.nvals * sizeof(uint64_t) * 2);
    for (int i = 0; i < value->u.list.nvals; i++) {
        struct json_value *jv = value->u.list.vals[i];
        assert(jv->type == JV_MAP);
        struct json_value *k = dict_lookup(jv->u.map, "key", 3);
        assert(k->type == JV_MAP);
        struct json_value *v = dict_lookup(jv->u.map, "value", 5);
        assert(v->type == JV_MAP);
        vals[2*i] = value_from_json(k->u.map);
        vals[2*i+1] = value_from_json(v->u.map);
    }

    // vals is sorted already by harmony compiler
    void *p = dict_find(dict_map, vals,
                    value->u.list.nvals * sizeof(uint64_t) * 2);
    free(vals);
    return (uint64_t) p | VALUE_DICT;
}

uint64_t value_set(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_LIST);
    if (value->u.list.nvals == 0) {
        return (uint64_t) VALUE_SET;
    }
    uint64_t *vals = malloc(value->u.list.nvals * sizeof(uint64_t));
    for (int i = 0; i < value->u.list.nvals; i++) {
        struct json_value *jv = value->u.list.vals[i];
        assert(jv->type == JV_MAP);
        vals[i] = value_from_json(jv->u.map);
    }

    // vals is sorted already by harmony compiler
    void *p = dict_find(set_map, vals, value->u.list.nvals * sizeof(uint64_t));
    free(vals);
    return (uint64_t) p | VALUE_SET;
}

uint64_t value_address(struct dict *map){
    struct json_value *value = dict_lookup(map, "value", 5);
    assert(value->type == JV_LIST);
    if (value->u.list.nvals == 0) {
        return (uint64_t) VALUE_ADDRESS;
    }
    uint64_t *vals = malloc(value->u.list.nvals * sizeof(uint64_t));
    for (int i = 0; i < value->u.list.nvals; i++) {
        struct json_value *jv = value->u.list.vals[i];
        assert(jv->type == JV_MAP);
        vals[i] = value_from_json(jv->u.map);
    }
    void *p = dict_find(address_map, vals,
                            value->u.list.nvals * sizeof(uint64_t));
    free(vals);
    return (uint64_t) p | VALUE_ADDRESS;
}

uint64_t value_from_json(struct dict *map){
    struct json_value *type = dict_lookup(map, "type", 4);
    assert(type != 0);
    assert(type->type == JV_ATOM);
    if (atom_cmp(type->u.atom, "bool")) {
        return value_bool(map);
    }
    else if (atom_cmp(type->u.atom, "int")) {
        return value_int(map);
    }
    else if (atom_cmp(type->u.atom, "atom")) {
        return value_atom(map);
    }
    else if (atom_cmp(type->u.atom, "char")) {
        return value_char(map);
    }
    else if (atom_cmp(type->u.atom, "dict")) {
        return value_dict(map);
    }
    else if (atom_cmp(type->u.atom, "set")) {
        return value_set(map);
    }
    else if (atom_cmp(type->u.atom, "pc")) {
        return value_pc(map);
    }
    else if (atom_cmp(type->u.atom, "address")) {
        return value_address(map);
    }
    else {
        panic("value_from_json: bad type");
        return 0;
    }
}

void value_init(){
    atom_map = dict_new(0);
    dict_map = dict_new(0);
    set_map = dict_new(0);
    address_map = dict_new(0);
    context_map = dict_new(0);
}

"""

import sys
import os
import pathlib
import tempfile
import getopt
import traceback
import collections
import time
import math
import html
import queue
import functools
import json

# TODO.  These should not be global ideally
files = {}              # files that have been read already
constants = {}          # constants modified with -c
modules = {}            # modules modified with -m
namestack = []          # stack of module names being compiled
node_uid = 1            # unique node identifier
silent = False          # not printing periodic status updates
lasttime = 0            # last time status update was printed
imported = {}           # imported modules

def brief_kv(js):
    return (brief_string(js["key"]), brief_string(js["value"]))

def brief_idx(js):
    if js["type"] == "atom":
        return brief_string(js)
    return "[" + brief_string(js) + "]"

def brief_string(js):
    type = js["type"]
    v = js["value"]
    if type in { "bool", "int" }:
        return v
    if type == "atom":
        return "." + v
    if type == "set":
        if v == []:
            return "{}"
        lst = [ brief_string(val) for val in v ]
        return "{ " + ", ".join(lst) + " }"
    if type == "dict":
        if v == []:
            return "()"
        lst = [ brief_kv(kv) for kv in v ]
        keys = [ k for k,v in lst ]
        if keys == [str(i) for i in range(len(v))]:
            return "[ " + ", ".join([v for k,v in lst]) + " ]" 
        else:
            return "{ " + ", ".join([k + ": " + v for k,v in lst]) + " }" 
    if type == "pc":
        return "PC(%s)"%v
    if type == "address":
        if v == []:
            return "None"
        return "?" + v[0]["value"] + "".join([ brief_idx(kv) for kv in v[1:] ])
    if type == "context":
        return "CONTEXT(" + brief_string(v["name"]) + ")"

def brief_print_vars(d):
    print("{", end="")
    first = True
    for k, v in d.items():
        if first:
            first = False
        else:
            print(",", end="")
        print(" %s: %s"%(k, brief_string(v)), end="")
    print(" }")

def brief_print_range(start, end):
    if start == end:
        return "%d"%(start)
    if start + 1 == end:
        return "%d,%d"%(start, end)
    return "%d-%d"%(start, end)

class Brief:
    def __init__(self):
        self.tid = None
        self.name = None
        self.start = 0
        self.steps = ""
        self.interrupted = False
        self.lastmis = {}
        self.shared = {}
        self.failure = ""

    def flush(self):
        if self.tid != None:
            print("T%s: %s ["%(self.tid, self.name), end="")
            if self.steps != "":
                self.steps += ","
            self.steps += brief_print_range(self.start, int(self.lastmis["pc"]))
            print(self.steps + "] ", end="");
            brief_print_vars(self.shared);

    def print_macrostep(self, mas):
        mis = mas["microsteps"]
        if mas["tid"] != self.tid:
            self.flush()
            self.tid = mas["tid"]
            self.name = mas["name"]
            self.interrupted = False
            self.lastmis = mis[0]
            self.start = int(self.lastmis["pc"])
            if "shared" in self.lastmis:
                self.shared = self.lastmis["shared"]
            lastpc = 0
            self.steps = ""
            begin = 1
        else:
            begin = 0
        for i in range(begin, len(mis)):
            if "shared" in mis[i]:
                self.shared = mis[i]["shared"]
            if self.interrupted:
                if self.steps != "":
                    self.steps += ","
                self.steps += brief_print_range(self.start, int(self.lastmis["pc"]))
                self.start = int(mis[i]["pc"])
                self.steps += ",interrupt"
            elif "choose" in mis[i]:
                if self.steps != "":
                    self.steps += ","
                self.steps += brief_print_range(self.start, int(mis[i]["pc"]))
                self.steps += "(choose %s)"%brief_string(mis[i]["choose"])
                self.start = int(mis[i]["pc"]) + 1
            elif int(mis[i]["pc"]) != int(self.lastmis["pc"]) + 1:
                if self.steps != "":
                    self.steps += ","
                self.steps += brief_print_range(self.start, int(self.lastmis["pc"]))
                self.start = int(mis[i]["pc"])
            self.lastmis = mis[i]
            if "failure" in self.lastmis:
                self.failure = self.lastmis["failure"]
            self.interrupted = "interrupt" in self.lastmis and self.lastmis["interrupt"] == "True"

    def run(self):
        with open("charm.json") as f:
            top = json.load(f)
            assert isinstance(top, dict)
            if top["issue"] == "No issues":
                return True

            # print("Issue:", top["issue"])
            assert isinstance(top["macrosteps"], list)
            for mes in top["macrosteps"]:
                self.print_macrostep(mes)
            self.flush()
            print(self.failure)
            return False;


class GenHTML:
    def __init__(self):
        self.top = {}
        self.nmegasteps = 0
        self.nmicrosteps = 0
        self.nthreads = 0
        self.vardir = {}

        self.style = """
#table-wrapper {
  position:relative;
}
#table-scroll {
  height:200px;
  overflow:auto;  
}
#table-wrapper table {
  width:100%;
}
#table-wrapper table * {
  color:black;
}
#table-wrapper table thead th .text {
  position:absolute;   
  top:-20px;
  z-index:2;
  height:20px;
  width:35%;
  border:1px solid red;
}
table {
    border-collapse: collapse;
    border-style: hidden;
}
table td, table th {
    border: 1px solid black;
}

        """
        self.js = """
var boxSize = 10;
var currentTime = 0;
var totalTime = 0;
var microsteps = [];
var megasteps = []
var threads = [];
var curMegaStep = 0;
var mestable = document.getElementById("mestable");
var threadtable = document.getElementById("threadtable");
var coderow = document.getElementById("coderow");
var container = document.getElementById('table-scroll');
var currOffset = 0;
var currCloc = null;

function drawTimeLine(mes) {
  var c = mes.canvas.getContext("2d");
  c.beginPath();
  c.clearRect(0, 0, mes.canvas.width, mes.canvas.height);
  var t = mes.startTime;
  var yboxes = Math.floor((mes.nsteps + 29) / 30);
  var nsteps = mes.nsteps;
  for (var y = 0; y < yboxes; y++) {
    var xboxes = nsteps > 30 ? 30 : nsteps;
    for (var x = 0; x < xboxes; x++) {
      c.fillStyle = t < currentTime ? "orange" : "white";
      c.fillRect(x * boxSize, y * boxSize, boxSize, boxSize);
      c.rect(x * boxSize, y * boxSize, boxSize, boxSize);
      c.stroke();
      t += 1;
    }
    nsteps -= xboxes;
  }
}

function currentMegaStep() {
  if (currentTime == totalTime) {
    return microsteps[currentTime - 1].mesidx;
  }
  return microsteps[currentTime].mesidx;
}

function json_string_set(obj) {
  var result = "";
  for (var i = 0; i < obj.length; i++) {
    if (result != "") {
      result += ", ";
    }
    result += json_string(obj[i]);
  }
  return "{ " + result + " }";
}

function json_string_dict(obj) {
  if (obj.length == 0) {
    return "( )"
  }

  var islist = true;
  for (var i = 0; i < obj.length; i++) {
    if (obj[i].key.type != "int" || obj[i].key.value != i.toString()) {
      islist = false;
      break;
    }
  }

  var result = "";
  if (islist) {
    for (var i = 0; i < obj.length; i++) {
      if (i != 0) {
        result += ", ";
      }
      result += json_string(obj[i].value);
    }
    if (obj.length == 1) {
      result += ",";
    }
    return "[" + result + "]";
  }

  for (var i = 0; i < obj.length; i++) {
    if (result != "") {
      result += ", ";
    }
    var kv = obj[i];
    var k = json_string(kv.key);
    var v = json_string(kv.value);
    result += k + ": " + v;
  }
  return "{ " + result + " }";
}

function json_string_address(obj) {
  if (obj.length == 0) {
    return "None";
  }
  var result = "?" + obj[0].value;
  for (var i = 1; i < obj.length; i++) {
    if (obj[i].type == "atom") {
      result += "." + obj[i].value;
    }
    else {
      result += "[" + json_string(obj[i]) + "]";
    }
  }
  return result;
}

function json_string_context(obj) {
  var name = json_string(obj.name);
  var arg = json_string(obj.arg);
  var pc = json_string(obj.pc);
  return "CTX(" + name + "(" + arg + "):" + pc + ")";
}

function json_string(obj) {
  switch (obj.type) {
  case "bool": case "int":
    return obj.value;
    break;
  case "atom":
    return "." + obj.value;
  case "set":
    return json_string_set(obj.value);
  case "dict":
    return json_string_dict(obj.value);
  case "pc":
    return "PC(" + obj.value + ")"
  case "address":
    return json_string_address(obj.value);
  case "context":
    return json_string_context(obj.value);
  default:
    return JSON.stringify(obj);
  }
}

function stringify_vars(obj) {
  var result = "";
  for (var k in obj) {
    if (k == "result" && obj[k].type == "dict" && obj[k].value.length == 0) {
      continue;
    }
    if (result != "") {
      result += ", ";
    }
    result += k + ": " + json_string(obj[k]);
  }
  return result;
}

function convert_var(obj) {
  if (obj.type != "dict") {
    return json_string(obj);
  }
  if (obj.value.length == 0) {
    return "";
  }
  var result = {};
  for (var i = 0; i < obj.value.length; i++) {
    var kv = obj.value[i];
    var k = json_string(kv.key);
    result[k] = convert_var(kv.value);
  }
  return result;
}

function convert_vars(obj) {
  var result = {};
  for (var k in obj) {
    result[k] = convert_var(obj[k]);
  }
  return result;
}

function stackTrace(tid, trace, failure) {
  var table = threads[tid].tracetable;
  table.innerHTML = "";
  if (trace.length == 0) {
    var row = table.insertRow();
    var mcell = row.insertCell();
    mcell.innerHTML = threads[tid].name;
  }
  for (var i = 0; i < trace.length; i++) {
    var row = table.insertRow();

    var mcell = row.insertCell();
    mcell.innerHTML = trace[i].method;
    switch (trace[i].calltype) {
    case "process":
        mcell.style.color = "blue";
        break;
    case "normal":
        mcell.style.color = "black";
        break;
    case "interrupt":
        mcell.style.color = "orange";
        break;
    default:
        mcell.style.color = "red";
    }

    var vcell = row.insertCell();
    var vtext = document.createTextNode(stringify_vars(trace[i].vars));
    vcell.appendChild(vtext);
  }
  if (failure != null) {
    var row = table.insertRow();
    var fcell = row.insertCell();
    fcell.innerHTML = failure;
    fcell.colSpan = 2;
    fcell.style.color = "red";
  }
}

function handleClick(e, mesIdx) {
  var x = Math.floor(e.offsetX / boxSize);
  var y = Math.floor(e.offsetY / boxSize);
  currentTime = megasteps[mesIdx].startTime + y*30 + x + 1;
  run_microsteps()
}

var noloc = { file: "", line: "", code: "" };

function getCode(pc) {
  var locs = state.locations;
  while (pc >= 0) {
    s = "" + pc;
    if (locs.hasOwnProperty(s)) {
      return locs[s];
    }
    pc--;
  }
  return noloc;
}

function handleKeyPress(e) {
  switch (e.key) {
    case '0':
      currentTime = 0;
      run_microsteps();
      break;
    case 'ArrowLeft':
      if (currentTime > 0) {
        currentTime -= 1;
      }
      run_microsteps();
      break;
    case 'ArrowRight':
      if (currentTime < totalTime) {
        currentTime += 1;
      }
      run_microsteps();
      break;
    case 'ArrowUp':
      var mesidx = currentMegaStep();
      var mes = megasteps[mesidx];
      if (currentTime == mes.startTime && mesidx > 0) {
          mes = megasteps[mesidx - 1];
      }
      currentTime = mes.startTime;
      run_microsteps();
      break;
    case 'ArrowDown':
      var mesidx = currentMegaStep();
      var mes = megasteps[mesidx];
      currentTime = mes.startTime + mes.nsteps;
      if (currentTime > totalTime) {
        currentTime = totalTime;
      }
      run_microsteps();
      break;
    case 'Enter':
      if (currentTime < totalTime) {
        var cloc = getCode(microsteps[currentTime].pc);
        while (++currentTime < totalTime) {
          var nloc = getCode(microsteps[currentTime].pc);
          if (nloc != cloc) {
            break;
          }
        }
        run_microsteps();
      }
      break;
    default:
      // alert("unknown key " + e.code);
  }
}

function init_microstep(masidx, misidx) {
  var mas = state.macrosteps[masidx];
  var mis = mas.microsteps[misidx];
  var t = microsteps.length;
  if (t > 0 && microsteps[t - 1].tid != mas.tid) {
    curMegaStep++;
    megasteps[curMegaStep].startTime = t;
  }
  var mes = megasteps[curMegaStep];
  mes.nsteps++;
  microsteps[t] = {
    mesidx: curMegaStep,
    masidx: masidx,
    misidx: misidx,
    tid: parseInt(mas.tid),
    pc: parseInt(mis.pc),
    invfails: misidx == mas.microsteps.length - 1 ? mas.invfails : [],
    contexts: mas.contexts
  };

  if (mis.hasOwnProperty("npc")) {
    microsteps[t].npc = mis.npc;
  }
  else {
    microsteps[t].npc = mis.pc;
  }

  microsteps[t].code = getCode(microsteps[t].npc);

  microsteps[t].cloc = document.getElementById('C' + microsteps[t].npc);
  var npc = microsteps[t].npc - 4;
  if (npc < 0) {
    npc = 0;
  }
  microsteps[t].offset = document.getElementById('P' + npc);

  if (mis.hasOwnProperty("mode")) {
    microsteps[t].mode = mis.mode;
  }
  else {
    microsteps[t].mode = misidx == 0 ? "running" : microsteps[t-1].mode;
  }

  if (mis.hasOwnProperty("atomic")) {
    microsteps[t].atomic = mis["atomic"];
  }
  else if (misidx == 0) {
    microsteps[t].atomic = 0;
  }
  else {
    microsteps[t].atomic = microsteps[t-1].atomic;
  }

  if (mis.hasOwnProperty("readonly")) {
    microsteps[t].readonly = mis["readonly"];
  }
  else if (misidx == 0) {
    microsteps[t].readonly = 0;
  }
  else {
    microsteps[t].readonly = microsteps[t-1].readonly;
  }

  if (mis.hasOwnProperty("interruptlevel")) {
    microsteps[t].interruptlevel = mis["interruptlevel"];
  }
  else if (misidx == 0) {
    microsteps[t].interruptlevel = 0;
  }
  else {
    microsteps[t].interruptlevel = microsteps[t-1].interruptlevel;
  }

  if (mis.hasOwnProperty("choose")) {
    microsteps[t].choose = "chose " + json_string(mis["choose"]);
  }
  else {
    microsteps[t].choose = null;
  }

  if (mis.hasOwnProperty("failure")) {
    microsteps[t].failure = mis.failure;
    microsteps[t].cloc = null;
  }
  else {
    microsteps[t].failure = null;
  }

  if (mis.hasOwnProperty("trace")) {
    microsteps[t].trace = mis.trace;
  }
  else if (misidx == 0) {
    microsteps[t].trace = [];
  }
  else {
    microsteps[t].trace = microsteps[t-1].trace;
  }

  // Update local variables
  var trl = microsteps[t].trace.length; 
  if (trl > 0 && mis.hasOwnProperty("local")) {
    // deep copy first
    microsteps[t].trace = JSON.parse(JSON.stringify(microsteps[t].trace))
    microsteps[t].trace[trl - 1].vars = mis.local;
  }

  if (mis.hasOwnProperty("shared")) {
    microsteps[t].shared = convert_vars(mis.shared);
  }
  else if (t == 0) {
    microsteps[t].shared = {};
  }
  else {
    microsteps[t].shared = microsteps[t-1].shared;
  }

  if (mis.hasOwnProperty("fp")) {
    microsteps[t].fp = mis.fp;
  }
  else if (misidx == 0) {
    microsteps[t].fp = 0;
  }
  else {
    microsteps[t].fp = microsteps[t-1].fp;
  }
  if (mis.hasOwnProperty("pop")) {
    var n = parseInt(mis.pop);
    microsteps[t].stack = microsteps[t-1].stack.slice(0,
                              microsteps[t-1].stack.length - n);
  }
  else if (misidx == 0) {
    microsteps[t].stack = [];
  }
  else {
    microsteps[t].stack = microsteps[t-1].stack;
  }
  if (mis.hasOwnProperty("push")) {
    var vals = mis.push.map(x => json_string(x));
    microsteps[t].stack = microsteps[t].stack.concat(vals);
  }
  // microsteps[t].choose = microsteps[t].stack;
}

function init_macrostep(i) {
  var mas = state.macrosteps[i];
  for (var j = 0; j < mas.microsteps.length; j++) {
    init_microstep(i, j);
  }
  for (var ctx = 0; ctx < mas.contexts.length; ctx++) {
    var tid = parseInt(mas.contexts[ctx].tid);
    threads[tid].name = mas.contexts[ctx].name;
  }
}

function dict_convert(d) {
  if (typeof d === "string") {
    return d;
  }
  result = "";
  for (var k in d) {
    if (result != "") {
      result += ", ";
    }
    result += dict_convert(k) + ":" + dict_convert(d[k]);;
  }
  return "{" + result + "}";
}

function get_shared(shared, path) {
  if (!shared.hasOwnProperty(path[0])) {
    return "";
  }
  if (path.length == 1) {
    return dict_convert(shared[path[0]]);
  }
  return get_shared(shared[path[0]], path.slice(1));
}

function get_status(ctx) {
  var status = ctx.mode;
  if (status != "terminated") {
    if (ctx.atomic > 0) {
      status += " atomic";
    }
    if (ctx.readonly > 0) {
      status += " read-only";
    }
    if (ctx.interruptlevel > 0) {
      status += " interrupts-disabled";
    }
  }
  return status;
}

function escapeHTML(s) {
  return s
     .replace(/&/g, "&amp;")
     .replace(/</g, "&lt;")
     .replace(/>/g, "&gt;")
     .replace(/"/g, "&quot;")
     .replace(/'/g, "&#039;");
}

function run_microstep(t) {
  var mis = microsteps[t];
  var mesrow = mestable.rows[mis.mesidx];
  mesrow.cells[3].innerHTML = mis.npc;

  for (var i = 0; i < vardir.length; i++) {
    mesrow.cells[i + 4].innerHTML = get_shared(mis.shared, vardir[i])
  }

  if (mis.failure != null) {
    stackTrace(mis.tid, mis.trace, mis.failure);
  }
  else {
    stackTrace(mis.tid, mis.trace, mis.choose);
  }

  for (var ctx = 0; ctx < mis.contexts.length; ctx++) {
    var tid = parseInt(mis.contexts[ctx].tid);
    threads[tid].name = mis.contexts[ctx].name;
    threadtable.rows[tid].cells[1].innerHTML = get_status(mis.contexts[ctx]);
  }
  var mes = megasteps[mis.mesidx];
  if (t != mes.startTime + mes.nsteps - 1) {
    threadtable.rows[mis.tid].cells[1].innerHTML = get_status(mis);
  }
  threadtable.rows[mis.tid].cells[3].innerHTML = mis.stack.slice(mis.fp);

  if (mis.invfails.length > 0) {
    inv = mis.invfails[0];
    code = getCode(inv.pc);
    coderow.style.color = "red";
    coderow.innerHTML = code.file + ":" + code.line + "&nbsp;&nbsp;&nbsp;" + escapeHTML(code.code) + " (" + inv.reason + ")";
    mis.cloc = null;
  }
  else {
    coderow.style.color = "blue";
    coderow.innerHTML = mis.code.file + ":" + mis.code.line + "&nbsp;&nbsp;&nbsp;" + escapeHTML(mis.code.code);
  }

  currCloc = mis.cloc;
  currOffset = mis.offset;
}

function run_microsteps() {
  coderow.innerHTML = "";
  if (currCloc != null) {
    currCloc.style.color = "black";
    currCloc = null;
  }
  for (var i = 0; i < nmegasteps; i++) {
    mestable.rows[i].cells[3].innerHTML = "";
    for (var j = 0; j < vardir.length; j++) {
      mestable.rows[i].cells[j + 4].innerHTML = "";
    }
  }
  for (var tid = 0; tid < nthreads; tid++) {
    threadtable.rows[tid].cells[1].innerHTML = "init";
    stackTrace(tid, [], null);
    threadtable.rows[tid].cells[3].innerHTML = "";
  }
  for (var t = 0; t < currentTime; t++) {
    run_microstep(t);
  }
  for (var i = 0; i < nmegasteps; i++) {
    drawTimeLine(megasteps[i]);
  }
  container.scrollTop = currOffset.offsetTop;

  if (currCloc != null) {
    currCloc.style.color = "red";
  }

  var curmes = microsteps[currentTime == 0 ? 0 : (currentTime-1)].mesidx;
  for (var mes = 0; mes < nmegasteps; mes++) {
    var row = document.getElementById("mes" + mes)
    if (mes == curmes) {
      row.style = 'background-color: #A5FF33;';
    }
    else {
      row.style = 'background-color: white;';
    }
  }

  var curtid = microsteps[currentTime == 0 ? 0 : (currentTime-1)].tid;
  for (var tid = 0; tid < nthreads; tid++) {
    var row = document.getElementById("thread" + tid)
    if (tid == curtid) {
      row.style = 'background-color: #A5FF33;';
    }
    else {
      row.style = 'background-color: white;';
    }
  }
}

// Initialization starts here

for (var tid = 0; tid < nthreads; tid++) {
  threads[tid] = {
    name: "T" + tid,
    status: "normal",
    stack: [],
    stacktrace: [],
    tracetable: document.getElementById("threadinfo" + tid)
  };
}
for (let i = 0; i < nmegasteps; i++) {
  var canvas = document.getElementById("timeline" + i);
  megasteps[i] = {
    canvas: canvas,
    startTime: 0,
    nsteps: 0,
    contexts: []
  };
  canvas.addEventListener('mousedown', function(e){handleClick(e, i)});
}
for (var j = 0; j < state.macrosteps.length; j++) {
  init_macrostep(j);
}

currentTime = totalTime = microsteps.length;
run_microsteps();
document.addEventListener('keydown', handleKeyPress);

        """

    def json_kv(self, js):
        return self.json_string(js["key"]) + ": " + self.json_string(js["value"])

    def json_idx(self, js):
        if js["type"] == "atom":
            return self.json_string(js)
        return "[" + self.json_string(js) + "]"

    def json_string(self, js):
        type = js["type"]
        v = js["value"]
        if type in { "bool", "int" }:
            return v
        if type == "atom":
            return "." + v
        if type == "set":
            if v == []:
                return "{}"
            return "{ " + ", ".join([ self.json_string(val) for val in v]) + " }"
        if type == "dict":
            if v == []:
                return "()"
            return "{ " + ", ".join([ self.json_kv(kv) for kv in v ]) + " }" 
        if type == "pc":
            return "PC(%s)"%v
        if type == "address":
            if v == []:
                return "None"
            return "?" + v[0]["value"] + "".join([ self.json_idx(kv) for kv in v[1:] ])
        if type == "context":
            return "CONTEXT(" + self.json_string(v["name"]) + ")"
        assert False

    def file_include(self, name, f):
        with open(name) as g:
            print(g.read(), file=f)

    def html_megastep(self, step, tid, name, nmicrosteps, width, f):
        print("<tr id='mes%d'>"%(step-1), file=f)
        print("  <td align='right'>", file=f)
        print("    %d&nbsp;"%step, file=f)
        print("  </td>", file=f)

        print("  <td>", file=f)
        print("    T%s: %s"%(tid, name), file=f, end="")
        print("  </td>", file=f)

        print("  <td>", file=f)
        time = nmicrosteps
        nrows = (time + 29) // 30
        print("    <canvas id='timeline%d' width='300px' height='%dpx'>"%(step-1, 10*nrows), file=f)
        print("    </canvas>", file=f)
        print("  </td>", file=f)

        print("  <td align='center'>", file=f);
        print("  </td>", file=f)

        for i in range(width):
          print("  <td align='center'>", file=f)
          print("  </td>", file=f)
        print("</tr>", file=f)

    def vardim(self, d):
        if isinstance(d, dict):
            if d == {}:
                return (1, 0)
            totalwidth = 0
            maxheight = 0
            for k in sorted(d.keys()):
                (w, h) = self.vardim(d[k])
                totalwidth += w
                if h + 1 > maxheight:
                    maxheight = h + 1
            return (totalwidth, maxheight)
        else:
            return (1, 0)

    def varhdr(self, d, name, nrows, f):
        q = queue.Queue()
        level = 0
        q.put((d, level))
        while not q.empty():
            (nd, nl) = q.get()
            if nl > level:
                print("</tr><tr>", file=f)
                level = nl
            if isinstance(nd, dict):
                for k in sorted(nd.keys()):
                    (w,h) = self.vardim(nd[k])
                    if h == 0:
                        print("<td align='center' style='font-style: italic' colspan='%d' rowspan='%d'>%s</td>"%(w,nrows-nl,k), file=f)
                    else:
                        print("<td align='center' style='font-style: italic' colspan='%d'>%s</td>"%(w,k), file=f)
                    q.put((nd[k], nl+1))

    def html_top(self, f):
        (width, height) = self.vardim(self.vardir)
        print("<table border='1'>", file=f)
        print("  <thead>", file=f)
        print("    <tr>", file=f)
        print("      <th colspan='4' style='color:red;'>", file=f)
        print("        Issue:", self.top["issue"], file=f)
        print("      </th>", file=f)
        print("      <th align='center' colspan='%d'>"%width, file=f)
        print("        Shared Variables", file=f)
        print("      </th>", file=f)
        print("    </tr>", file=f)

        print("    <tr>", file=f)
        print("      <th align='center' rowspan='%d'>"%height, file=f)
        print("        Turn", file=f)
        print("      </th>", file=f)
        print("      <th align='center' rowspan='%d'>"%height, file=f)
        print("        Thread", file=f)
        print("      </th>", file=f)
        print("      <th align='center' rowspan='%d'>"%height, file=f)
        print("        Instructions Executed", file=f)
        print("      </th>", file=f)
        print("      <th align='center' rowspan='%d'>"%height, file=f)
        print("        &nbsp;PC&nbsp;", file=f)
        print("      </th>", file=f)
        self.varhdr(self.vardir, "", height, f)
        print("    </tr>", file=f)
        print("  </thead>", file=f)

        print("  <tbody id='mestable'>", file=f)
        assert isinstance(self.top["macrosteps"], list)
        nsteps = 0
        tid = None
        name = None
        nmicrosteps = 0
        for mas in self.top["macrosteps"]:
            if tid == mas["tid"]:
                nmicrosteps += len(mas["microsteps"])
            else:
                if tid != None:
                    self.html_megastep(nsteps, tid, name, nmicrosteps, width, f)
                nsteps += 1
                tid = mas["tid"]
                name = mas["name"]
                nmicrosteps = len(mas["microsteps"])
        self.html_megastep(nsteps, tid, name, nmicrosteps, width, f)
        print("  </tbody>", file=f)
        print("</table>", file=f)

    def html_botleft(self, f):
        print("<div id='table-wrapper'>", file=f)
        print("  <div id='table-scroll'>", file=f)
        print("    <table border='1'>", file=f)
        print("      <tbody>", file=f)
        alter = False;
        for pc, instr in enumerate(self.top["code"]):
            if str(pc) in self.top["locations"]:
                alter = not alter;
            print("        <tr id='P%d'>"%pc, file=f)
            print("          <td align='right'>", file=f)
            print("            <a name='P%d'>%d</a>&nbsp;"%(pc, pc), file=f)
            print("          </td>", file=f)
            print("          <td style='background-color: %s;'>"%("#E6E6E6" if alter else "white"), file=f)
            print("            <span title='%s' id='C%d'>"%(self.top["explain"][pc], pc), file=f)
            print("              %s"%instr, file=f);
            print("            </span>", file=f)
            print("          </td>", file=f)
            print("        </tr>", file=f)
        print("      </body>", file=f)
        print("    </table>", file=f)
        print("  </div>", file=f)
        print("</div>", file=f)

    def html_botright(self, f):
        print("<table border='1'", file=f)
        print("  <thead>", file=f)
        print("    <tr>", file=f)
        print("      <th colspan='4'>Threads</th>", file=f)
        print("    </tr>", file=f)
        print("    <tr>", file=f)
        print("      <th>", file=f)
        print("        ID", file=f)
        print("      </th>", file=f)
        print("      <th>", file=f)
        print("        Status", file=f)
        print("      </th>", file=f)
        print("      <th>", file=f)
        print("        Stack Trace", file=f)
        print("      </th>", file=f)
        print("      <th>", file=f)
        print("        Stack Top", file=f)
        print("      </th>", file=f)
        print("    </tr>", file=f)
        print("  </thead>", file=f)
        print("  <tbody id='threadtable'>", file=f)
        maxtid = 0
        for i in range(self.nthreads):
            print("    <tr id='thread%d'>"%i, file=f)
            print("      <td align='center'>", file=f)
            print("        T%d"%i, file=f)
            print("      </td>", file=f)
            print("      <td align='center'>", file=f)
            print("        init", file=f)
            print("      </td>", file=f)
            print("      <td>", file=f)
            print("        <table id='threadinfo%d' border='1'>"%i, file=f)
            print("        </table>", file=f)
            print("      </td>", file=f)
            print("      <td align='left'>", file=f)
            print("      </td>", file=f)
            print("    </tr>", file=f)
        print("  </tbody>", file=f)
        print("</table>", file=f)

    def html_outer(self, f):
        print("<table>", file=f)
        print("  <tr>", file=f)
        print("    <td colspan='2'>", file=f)
        self.html_top(f)
        print("    </td>", file=f)
        print("  </tr>", file=f)
        print("  <tr><td></td></tr>", file=f)
        print("  <tr>", file=f)
        print("    <td colspan='2'>", file=f)
        print("      <h3 style='color:blue;'>", file=f)
        print("        <div id='coderow'>", file=f)
        print("        </div>", file=f)
        print("      </h3>", file=f)
        print("    </td>", file=f)
        print("  </tr>", file=f)
        print("  <tr><td></td></tr>", file=f)
        print("  <tr>", file=f)
        print("    <td valign='top'>", file=f)
        self.html_botleft(f)
        print("    </td>", file=f)
        print("    <td valign='top'>", file=f)
        self.html_botright(f)
        print("    </td>", file=f)
        print("  </tr>", file=f)
        print("</table>", file=f)

    def vardir_dump(self, d, path, index, f):
        if isinstance(d, dict) and d != {}:
            for k in sorted(d.keys()):
                index = self.vardir_dump(d[k], path + [k], index, f)
            return index
        if index > 0:
            print(",", file=f)
        print("  " + str(path), end="", file=f)
        return index + 1

    def html_script(self, f):
        print("<script>", file=f)
        print("var nthreads = %d;"%self.nthreads, file=f)
        print("var nmegasteps = %d;"%self.nmegasteps, file=f)
        print("var vardir = [", file=f)
        self.vardir_dump(self.vardir, [], 0, f)
        print(file=f)
        print("];", file=f)
        print("var state =", file=f)
        self.file_include("charm.json", f)
        print(";", file=f)
        print(self.js, file=f)
        # file_include("charm.js", f)
        print("</script>", file=f)

    def html_body(self, f):
        print("<body>", file=f)
        self.html_outer(f)
        self.html_script(f)
        print("</body>", file=f)

    def html_head(self, f):
        print("<head>", file=f)
        print("  <meta charset='UTF-8'></meta>", file=f)
        print("  <style>", file=f)
        print(self.style, file=f)
        print("  </style>", file=f)
        print("</head>", file=f)

    def html(self, f):
        print("<html>", file=f)
        self.html_head(f)
        self.html_body(f)
        print("</html>", file=f)

    def var_convert(self, v):
        if v["type"] != "dict":
            return self.json_string(v)
        d = {}
        for kv in v["value"]:
            k = self.json_string(kv["key"])
            d[k] = self.var_convert(kv["value"])
        return d

    def dict_merge(self, vardir, d):
        for (k, v) in d.items():
            if not isinstance(v, dict):
                vardir[k] = v
            else:
                if k not in vardir:
                    vardir[k] = {}
                elif not isinstance(vardir[k], dict):
                    continue
                self.dict_merge(vardir[k], v)

    def vars_add(self, vardir, shared):
        d = {}
        for (k, v) in shared.items():
            val = self.var_convert(v)
            if val != {}:
                d[k] = val
        self.dict_merge(vardir, d)

    def run(self):
        # First figure out how many megasteps there are and how many threads
        lasttid = -1
        with open("charm.json") as f:
            self.top = json.load(f)
            assert isinstance(self.top, dict)
            macrosteps = self.top["macrosteps"]
            for mas in macrosteps:
                tid = int(mas["tid"])
                if tid >= self.nthreads:
                    self.nthreads = tid + 1
                if tid != lasttid:
                    self.nmegasteps += 1
                    lasttid = tid
                self.nmicrosteps += len(mas["microsteps"])
                for mis in mas["microsteps"]:
                    if "shared" in mis:
                        self.vars_add(self.vardir, mis["shared"])
                for ctx in mas["contexts"]:
                    tid = int(ctx["tid"])
                    if tid >= self.nthreads:
                        self.nthreads = tid + 1

        with open("harmony.html", "w") as out:
            self.html(out)


def bag_add(bag, item):
    cnt = bag.get(item)
    if cnt == None:
        bag[item] = 1
    else:
        bag[item] = cnt + 1

def bag_remove(bag, item):
    cnt = bag[item]
    assert cnt > 0
    if cnt == 1:
        del bag[item]
    else:
        bag[item] = cnt - 1

def doImport(scope, code, module):
    (lexeme, file, line, column) = module
    # assert lexeme not in scope.names        # TODO
    if lexeme not in imported:
        # TODO.  Only do the following if the modules have variables?
        code.append(PushOp((novalue, file, line, column)))
        code.append(StoreOp(module, module, []))

        # module name replacement with -m flag
        modname = modules[lexeme] if lexeme in modules \
                            else lexeme

        # create a new scope
        scope2 = Scope(None)
        scope2.prefix = [lexeme]
        scope2.locations = scope.locations
        scope2.labels = scope.labels

        found = False
        for dir in [ os.path.dirname(namestack[-1]), "modules", "." ]:
            filename = dir + "/" + modname + ".hny"
            if os.path.exists(filename):
                with open(filename) as f:
                    load(f, filename, scope2, code)
                found = True
                break
        if not found:
            if modname in internal_modules:
                load_string(internal_modules[lexeme],
                    "<internal>/" + modname + ".hny", scope2, code)
            else:
                print("Can't find module", modname, "imported from", namestack)
                sys.exit(1)
        
        imported[lexeme] = scope2

    scope.names[lexeme] = ("module", imported[lexeme])

def load_string(all, filename, scope, code):
    files[filename] = all.split("\n")
    tokens = lexer(all, filename)
    if tokens == []:
        print("Empty file:", filename)
        sys.exit(1)

    try:
        (ast, rem) = StatListRule(-1).parse(tokens)
    except IndexError:
        # best guess...
        print("Parsing", filename, "hit EOF")
        sys.exit(1)

    if rem != []:
        print("Parsing: unexpected tokens remaining at end of program:", rem[0])
        sys.exit(1)

    for mod in ast.getImports():
        doImport(scope, code, mod)

    # method names and label names get a temporary value
    # they are filled in with their actual values after compilation
    # TODO.  Look for duplicates?
    tmp = PcValue(-1)
    for (lexeme, file, line, column) in ast.getLabels():
        scope.names[lexeme] = ("constant", (tmp, file, line, column))

    # Compile the first time, only to figure out the values of
    # method and label constants
    before = len(code)
    ast.compile(scope, code)
    del code[before:]

    # Compile again with the real values of the methods and label constants
    ast.compile(scope, code)

    for (lexeme, file, line, column) in ast.getLabels():
        (t, v) = scope.names[lexeme]
        (pc, file, line, columv) = v
        assert pc != tmp, ("not all labels have been filled", lexeme, v)

def load(f, filename, scope, code):
    if filename in files:
        return
    namestack.append(filename)
    all = ""
    for line in f:
        all += line
    load_string(all, filename, scope, code)
    namestack.pop()

def islower(c):
    return c in "abcdefghijklmnopqrstuvwxyz"

def isupper(c):
    return c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

def isletter(c):
    return islower(c) or isupper(c)

def isnumeral(c):
    return c in "0123456789"

def isalnum(c):
    return isletter(c) or isnumeral(c)

def isnamechar(c):
    return isalnum(c) or c == "_"

def isprint(c):
    return isinstance(c, str) and len(c) == 1 and (
        isalnum(c) or c in " ~!@#$%^&*()-_=+[{]}\\|;:\",<.>/?")

def isnumber(s):
    return all(isnumeral(c) for c in s)

def isreserved(s):
    return s in {
        "all",
        "and",
        "any",
        "as",
        "assert",
        "atLabel",
        "atomic",
        "await",
        # "call",
        "choose",
        "const",
        "contexts",
        "def",
        "del",
        "elif",
        "else",
        "end",
        "except",
        "False",
        # "fun",
        "for",
        "from",
        "get_context",
        "go",
        "hash",
        "if",
        "import",
        "in",
        "inf",
        "invariant",
        "keys",
        "lambda",
        "len",
        "let",
        "max",
        "min",
        "None",
        "not",
        "or",
        "pass",
        "print",
        "sequential",
        "setintlevel",
        "spawn",
        "stop",
        "trap",
        "try",
        "True",
        "where",
        "while"
        "with"
    }

def isname(s):
    return (not isreserved(s)) and (isletter(s[0]) or s[0] == "_") and \
                    all(isnamechar(c) for c in s)

def isunaryop(s):
    return s in { "!", "-", "~", "abs", "all", "any", "atLabel", "choose",
        "contexts", "get_context", "min", "max", "not", "keys", "hash", "len",
        "print"
    }

def isxbinop(s):
    return s in {
        "and", "or", "=>", "&", "|", "^", "-", "+", "*", "/", "//", "%", "mod",
        "**", "<<", ">>"
    }

def iscmpop(s):
    return s in { "==", "!=", "<", "<=", ">", ">=" }

assignops = {
    "and=", "or=", "=>=", "&=", "|=", "^=", "-=", "+=", "*=", "/=", "//=",
    "%=", "mod=", "**=", "<<=", ">>="
}

def isbinaryop(s):
    return isxbinop(s) or iscmpop(s) or s == "in"

tokens = { "{", "==", "!=", "<=", ">=", "=>",
                        "//", "**", "<<", ">>", "..", "->" } | assignops

def lexer(s, file):
    result = []
    line = 1
    column = 1
    cont = 1
    s = s.replace('\\r', '')        # MS-DOS...
    indentChars = set()
    indent = True
    while s != "":
        # see if it's a blank
        if s[0] in { " ", "\t" }:
            if indent:
                indentChars.add(s[0])
            s = s[1:]
            column += 1
            continue

        # backslash at end of line: glue on the next line
        if s[0] == "\\":
            if len(s) == 1:
                break
            if s[1] == "\n":
                s = s[2:]
                column += 2
                cont += 1
                continue

        if s[0] == "\n":
            s = s[1:]
            line += cont
            cont = 1
            column = 1
            indent = True
            continue

        indent = False

        # skip over line comments
        if s.startswith("#"):
            s = s[1:]
            while len(s) > 0 and s[0] != '\n':
                s = s[1:]
            continue

        # skip over nested comments
        if s.startswith("(*"):
            count = 1
            s = s[2:]
            column += 2
            while count != 0 and s != "":
                if s.startswith("(*"):
                    count += 1
                    s = s[2:]
                    column += 2
                elif s.startswith("*)"):
                    count -= 1
                    s = s[2:]
                    column += 2
                elif s[0] == "\n":
                    s = s[1:]
                    line += cont
                    cont = 1
                    column = 1
                else:
                    s = s[1:]
                    column += 1
            continue

        # see if it's a multi-character token.  Match with the longest one
        found = ""
        for t in tokens:
            if s.startswith(t) and len(t) > len(found):
                found = t
        if found != "":
            result += [ (found, file, line, column) ]
            s = s[len(found):]
            column += len(found)
            continue

        # see if a sequence of letters and numbers
        if isnamechar(s[0]):
            i = 0
            while i < len(s) and isnamechar(s[i]):
                i += 1
            result += [ (s[:i], file, line, column) ]
            s = s[i:]
            column += i
            continue

        # string
        if s[0] == '"' or s[0] == "'":
            start_col = column
            if s.startswith('"""'):
                term = '"""'
            elif s.startswith("'''"):
                term = "'''"
            elif s[0] == '"':
                term = '"'
            else:
                assert s[0] == "'", s[0]
                term = "'"
            column += len(term)
            s = s[len(term):]
            str = '"'
            while s != "" and not s.startswith(term):
                if s[0] == '\\':
                    s = s[1:]
                    if s == "":
                        break
                    column += 1
                    if s[0] == 'a':
                        str += '\a'; column += 1; s = s[1:]
                    elif s[0] == 'b':
                        str += '\b'; column += 1; s = s[1:]
                    elif s[0] == 'f':
                        str += '\f'; column += 1; s = s[1:]
                    elif s[0] == 'n':
                        str += '\n'; column += 1; s = s[1:]
                    elif s[0] == 'r':
                        str += '\r'; column += 1; s = s[1:]
                    elif s[0] == 't':
                        str += '\t'; column += 1; s = s[1:]
                    elif s[0] == 'v':
                        str += '\v'; column += 1; s = s[1:]
                    elif s[0] in "01234567":
                        total = 0
                        for i in range(3):
                            if s[0] not in "01234567":
                                break
                            total *= 8
                            total += ord(s[0]) - ord("0")
                            column += 1
                            s = s[1:]
                        str += chr(total)
                    elif s[0] in { 'x', "X" }:
                        column += 1
                        s = s[1:]
                        total = 0
                        while s != "" and s[0] in "0123456789abcdefABCDEF":
                            total *= 16;
                            if s[0] in "0123456789":
                                total += ord(s[0]) - ord("0")
                            elif s[0] in "abcdef":
                                total += 10 + (ord(s[0]) - ord("a"))
                            else:
                                assert s[0] in "ABCDEF", s[0]
                                total += 10 + (ord(s[0]) - ord("A"))
                            column += 1
                            s = s[1:]
                        str += chr(total)
                    else:
                        str += s[0]
                        if s[0] == '\n':
                            line += cont
                            cont = 1
                        column += 1
                        s = s[1:]
                else:
                    str += s[0]
                    if s[0] == '\n':
                        line += cont
                        cont = 1
                    column += 1
                    s = s[1:]
            result += [ (str, file, line, start_col) ]
            column += len(term)
            s = s[len(term):]
            continue

        # everything else is a single character token
        result += [ (s[0], file, line, column) ]
        s = s[1:]
        column += 1

    if len(indentChars) > 1:
        print("WARNING: do not mix tabs in spaces for indentation")
        print("It is likely to lead to incorrect parsing and code generation")

    return result

def strValue(v):
    if isinstance(v, Value) or isinstance(v, bool) or isinstance(v, int) or isinstance(v, float):
        return str(v)
    if isinstance(v, str):
        if isname(v):
            return "." + v
        else:
            assert len(v) == 1, v
            return ".0x%02X"%ord(v[0])
    assert False, v

def jsonValue(v):
    if isinstance(v, Value):
        return v.jdump()
    if isinstance(v, bool):
        return '{ "type": "bool", "value": "%s" }'%str(v)
    if isinstance(v, int) or isinstance(v, float):
        return '{ "type": "int", "value": "%s" }'%str(v)
    if isinstance(v, str):
        if isname(v):
            return '{ "type": "atom", "value": "%s" }'%str(v)
        else:
            assert len(v) == 1, v
            return '{ "type": "char", "value": "%02X" }'%ord(v[0])
    assert False, v

def strVars(v):
    assert isinstance(v, DictValue)
    result = ""
    for (var, val) in v.d.items():
        if result != "":
            result += ", "
        result += strValue(var)[1:] + "=" + strValue(val)
    return "{" + result + "}"

def keyValue(v):
    if isinstance(v, bool):
        return (0, v)
    if isinstance(v, int) or isinstance(v, float):
        return (1, v)
    if isinstance(v, str):
        return (2, v)
    assert isinstance(v, Value), v
    return v.key()

class Value:
    def __str__(self):
        return self.__repr__()

    def jdump(self):
        assert False

class PcValue(Value):
    def __init__(self, pc):
        self.pc = pc

    def __repr__(self):
        return "PC(" + str(self.pc) + ")"

    def __hash__(self):
        return self.pc.__hash__()

    def __eq__(self, other):
        return isinstance(other, PcValue) and other.pc == self.pc

    def key(self):
        return (3, self.pc)

    def jdump(self):
        return '{ "type": "pc", "value": "%d" }'%self.pc

class DictValue(Value):
    def __init__(self, d):
        self.d = d

    def __repr__(self):
        if len(self.d) == 0:
            return "()"
        result = ""
        if set(self.d.keys()) == set(range(len(self.d))):
            for k in range(len(self.d)):
                if result != "":
                    result += ", ";
                result += strValue(self.d[k])
            return "[" + result + "]"
        keys = sorted(self.d.keys(), key=keyValue)
        for k in keys:
            if result != "":
                result += ", ";
            result += strValue(k) + ":" + strValue(self.d[k])
        return "{ " + result + " }"

    def jdump(self):
        result = ""
        keys = sorted(self.d.keys(), key=keyValue)
        for k in keys:
            if result != "":
                result += ", ";
            result += '{ "key": %s, "value": %s }'%(jsonValue(k), jsonValue(self.d[k]))
        return '{ "type": "dict", "value": [%s] }'%result

    def __hash__(self):
        hash = 0
        for x in self.d.items():
            hash ^= x.__hash__()
        return hash

    def __eq__(self, other):
        if not isinstance(other, DictValue):
            return False
        if len(self.d.keys()) != len(other.d.keys()):   # for efficiency
            return False
        return self.d == other.d

    def __len__(self):
        return len(self.d.keys())

    # Dictionary ordering generalizes lexicographical ordering when the dictionary
    # represents a list or tuple
    def key(self):
        return (5, [ (keyValue(v), keyValue(self.d[v]))
                        for v in sorted(self.d.keys(), key=keyValue)])

# TODO.  Is there a better way than making this global?
novalue = DictValue({})

class SetValue(Value):
    def __init__(self, s):
        self.s = s

    def __repr__(self):
        if len(self.s) == 0:
            return "{}"
        result = ""
        vals = sorted(self.s, key=keyValue)
        for v in vals:
            if result != "":
                result += ", ";
            result += strValue(v)
        return "{ " + result + " }"

    def jdump(self):
        result = ""
        vals = sorted(self.s, key=keyValue)
        for v in vals:
            if result != "":
                result += ", ";
            result += jsonValue(v)
        return '{ "type": "set", "value": [%s] }'%result

    def __hash__(self):
        return frozenset(self.s).__hash__()

    def __eq__(self, other):
        if not isinstance(other, SetValue):
            return False
        return self.s == other.s

    def key(self):
        return (6, [keyValue(v) for v in sorted(self.s, key=keyValue)])

class AddressValue(Value):
    def __init__(self, indexes):
        self.indexes = indexes

    def __repr__(self):
        if len(self.indexes) == 0:
            return "None"
        result = "?" + self.indexes[0]
        for index in self.indexes[1:]:
            if isinstance(index, str):
                result = result + strValue(index)
            else:
                result += "[" + strValue(index) + "]"
        return result

    def jdump(self):
        result = ""
        for index in self.indexes:
            if result != "":
                result += ", "
            result = result + jsonValue(index)
        return '{ "type": "address", "value": [%s] }'%result

    def __hash__(self):
        hash = 0
        for x in self.indexes:
            hash ^= x.__hash__()
        return hash

    def __eq__(self, other):
        if not isinstance(other, AddressValue):
            return False
        return self.indexes == other.indexes

    def key(self):
        return (7, self.indexes)

class Op:
    def jdump(self):
        return '{ "op": "XXX %s" }'%str(self)

    def explain(self):
        return "no explanation yet"

    def sametype(x, y):
        return type(x) == type(y)

    def convert(self, x):
        if isinstance(x, tuple):
            return x[0]
        else:
            assert isinstance(x, list)
            result = "";
            for v in x:
                if result != "":
                    result += ", "
                result += self.convert(v)
            return "(" + result + ")"

    def store(self, context, var, val):
        if isinstance(var, tuple):
            (lexeme, file, line, column) = var
            context.set([lexeme], val)
        else:
            assert isinstance(var, list)
            if not isinstance(val, DictValue):
                context.failure = "Error: pc = %d: tried to assign %s to %s"%(
                    context.pc, val, self.convert(var))
            elif len(var) != len(val.d):
                context.failure = "Error: pc = %d: cannot assign %s to %s"%(
                    context.pc, val, self.convert(var))
            else:
                for i in range(len(var)):
                    self.store(context, var[i], val.d[i])

    def load(self, context, var):
        if isinstance(var, tuple):
            (lexeme, file, line, column) = var
            return context.get(lexeme)
        else:
            assert isinstance(var, list)
            d = { i:self.load(context, var[i]) for i in range(len(var)) }
            return DictValue(d)

class SetIntLevelOp(Op):
    def __repr__(self):
        return "SetIntLevel"

    def jdump(self):
        return '{ "op": "SetIntLevel" }'

    def explain(self):
        return "pops new boolean interrupt level and pushes old one"

    def eval(self, state, context):
        before = context.interruptLevel
        v = context.pop()
        assert isinstance(v, bool), v
        context.interruptLevel = v
        context.push(before)
        context.pc += 1

# Splits a non-empty set or dict in its minimum element and its remainder
class CutOp(Op):
    def __init__(self, s, v):
        self.s = s
        self.v = v

    def __repr__(self):
        return "Cut(" + self.s[0] + ", " + self.v[0] + ")"

    def jdump(self):
        return '{ "op": "Cut", "set": \"%s\", "var": \"%s\" }'%(self.s[0], self.v[0])

    def explain(self):
        return "remove smallest element from %s and assign to %s"%(self.s[0], self.v[0])

    def eval(self, state, context):
        v = self.load(context, self.s)
        if isinstance(v, DictValue):
            if v.d == {}:
                context.failure = "pc = " + str(context.pc) + \
                    ": Error: expected non-empty dict value"
            else:
                select = min(v.d.keys(), key=keyValue)
                self.store(context, self.v, v.d[select])
                copy = v.d.copy()
                del copy[select]
                self.store(context, self.s, DictValue(copy))
                context.pc += 1
        else:
            if not isinstance(v, SetValue):
                context.failure = "pc = " + str(context.pc) + \
                    ": Error: expected set value, got " + str(v)
            elif v.s == set():
                context.failure = "pc = " + str(context.pc) + \
                    ": Error: expected non-empty set value"
            else:
                lst = sorted(v.s, key=keyValue)
                self.store(context, self.v, lst[0])
                self.store(context, self.s, SetValue(set(lst[1:])))
                context.pc += 1

# Splits a tuple into its elements
class SplitOp(Op):
    def __init__(self, n):
        self.n = n

    def __repr__(self):
        return "Split %d"%self.n

    def jdump(self):
        return '{ "op": "Split", "count": "%d" }'%self.n

    def explain(self):
        return "splits a tuple value into its elements"

    def eval(self, state, context):
        v = context.pop()
        assert isinstance(v, DictValue), v
        assert len(v.d) == self.n, (self.n, len(v.d))
        for i in range(len(v.d)):
            context.push(v.d[i])
        context.pc += 1

# Move an item in the stack to the top
class MoveOp(Op):
    def __init__(self, offset):
        self.offset = offset

    def __repr__(self):
        return "Move %d"%self.offset

    def jdump(self):
        return '{ "op": "Move", "offset": "%d" }'%self.offset

    def explain(self):
        return "move stack element to top"

    def eval(self, state, context):
        v = context.stack.pop(len(context.stack) - self.offset)
        context.push(v)
        context.pc += 1

class DupOp(Op):
    def __repr__(self):
        return "Dup"

    def jdump(self):
        return '{ "op": "Dup" }'

    def explain(self):
        return "push a copy of the top value on the stack"

    def eval(self, state, context):
        v = context.pop()
        context.push(v)
        context.push(v)
        context.pc += 1

class GoOp(Op):
    def __repr__(self):
        return "Go"

    def jdump(self):
        return '{ "op": "Go" }'

    def explain(self):
        return "pops a context and a value, restores the corresponding thread, and pushes the value on its stack"

    def eval(self, state, context):
        ctx = context.pop()
        if not isinstance(ctx, ContextValue):
            context.failure = "pc = " + str(context.pc) + \
                ": Error: expected context value, got " + str(ctx)
        else:
            if ctx in state.stopbag:
                cnt = state.stopbag[ctx]
                assert cnt > 0
                if cnt == 1:
                    del state.stopbag[ctx]
                else:
                    state.stopbag[ctx] = cnt - 1
            result = context.pop();
            copy = ctx.copy()
            copy.push(result)
            copy.stopped = False
            bag_add(state.ctxbag, copy)
            context.pc += 1

class LoadVarOp(Op):
    def __init__(self, v):
        self.v = v

    def __repr__(self):
        if self.v == None:
            return "LoadVar"
        else:
            return "LoadVar " + self.convert(self.v)

    def jdump(self):
        if self.v == None:
            return '{ "op": "LoadVar" }'
        else:
            return '{ "op": "LoadVar", "value": "%s" }'%self.convert(self.v)

    def explain(self):
        if self.v == None:
            return "pop the address of a method variable and push the value of that variable"
        else:
            return "push the value of " + self.convert(self.v)

    def eval(self, state, context):
        if self.v == None:
            av = context.pop()
            assert isinstance(av, AddressValue)
            context.push(context.iget(av.indexes))
        else:
            context.push(self.load(context, self.v))
        context.pc += 1

class IncVarOp(Op):
    def __init__(self, v):
        self.v = v

    def __repr__(self):
        return "IncVar " + self.convert(self.v)

    def jdump(self):
        return '{ "op": "IncVar", "value": "%s" }'%self.convert(self.v)

    def explain(self):
        return "increment the value of " + self.convert(self.v)

    def eval(self, state, context):
        v = self.load(context, self.v)
        self.store(context, self.v, v + 1)
        context.pc += 1

class PushOp(Op):
    def __init__(self, constant):
        self.constant = constant

    def __repr__(self):
        (lexeme, file, line, column) = self.constant
        return "Push " + strValue(lexeme)

    def jdump(self):
        (lexeme, file, line, column) = self.constant
        return '{ "op": "Push", "value": %s }'%jsonValue(lexeme)

    def explain(self):
        return "push constant " + strValue(self.constant[0])

    def eval(self, state, context):
        (lexeme, file, line, column) = self.constant
        context.push(lexeme)
        context.pc += 1

class LoadOp(Op):
    def __init__(self, name, token, prefix):
        self.name = name
        self.token = token
        self.prefix = prefix

    def __repr__(self):
        if self.name == None:
            return "Load"
        else:
            (lexeme, file, line, column) = self.name
            return "Load " + ".".join(self.prefix + [lexeme])

    def jdump(self):
        if self.name == None:
            return '{ "op": "Load" }'
        else:
            (lexeme, file, line, column) = self.name
            result = ""
            for n in self.prefix + [lexeme]:
                if result != "":
                    result += ", "
                result += jsonValue(n)
            return '{ "op": "Load", "value": [%s] }'%result

    def explain(self):
        if self.name == None:
            return "pop an address and push the value at the address"
        else:
            return "push value of shared variable " + self.name[0]

    def eval(self, state, context):
        if self.name == None:
            av = context.pop()
            if not isinstance(av, AddressValue):
                context.failure = "Error: not an address " + \
                                    str(self.token) + " -> " + str(av)
                return
            context.push(state.iget(av.indexes))
        else:
            (lexeme, file, line, column) = self.name
            # TODO
            if False and lexeme not in state.vars.d:
                context.failure = "Error: no variable " + str(self.token)
                return
            context.push(state.iget(self.prefix + [lexeme]))
        context.pc += 1

class StoreOp(Op):
    def __init__(self, name, token, prefix):
        self.name = name
        self.token = token  # for error reporting
        self.prefix = prefix

    def __repr__(self):
        if self.name == None:
            return "Store"
        else:
            (lexeme, file, line, column) = self.name
            return "Store " + ".".join(self.prefix + [lexeme])

    def jdump(self):
        if self.name == None:
            return '{ "op": "Store" }'
        else:
            (lexeme, file, line, column) = self.name
            result = ""
            for n in self.prefix + [lexeme]:
                if result != "":
                    result += ", "
                result += jsonValue(n)
            return '{ "op": "Store", "value": [%s] }'%result

    def explain(self):
        if self.name == None:
            return "pop a value and an address and store the value at the address"
        else:
            return "pop a value and store it in shared variable " + self.name[0]

    def eval(self, state, context):
        if context.readonly > 0:
            context.failure = "Error: no update allowed in assert " + str(self.token)
            return
        v = context.pop()
        if self.name == None:
            av = context.pop()
            if not isinstance(av, AddressValue):
                context.failure = "Error: not an address " + \
                                    str(self.token) + " -> " + str(av)
                return
            lv = av.indexes
            if len(lv) == 0:
                context.failure = "Error: bad address " + str(self.token)
                return
            name = lv[0]
        else:
            (lexeme, file, line, column) = self.name
            lv = self.prefix + [lexeme]
            name = lexeme

        # TODO
        if False and not state.initializing and (name not in state.vars.d):
            context.failure = "Error: using an uninitialized shared variable " \
                    + name + ": " + str(self.token)
        else:
            try:
                state.set(lv, v)
                context.pc += 1
            except AttributeError:
                context.failure = "Error: " + name + " is not a dictionary " + str(self.token)

class DelOp(Op):
    # TODO: prefix
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        if self.name != None:
            (lexeme, file, line, column) = self.name
            return "Del " + lexeme
        else:
            return "Del"

    def jdump(self):
        if self.name == None:
            return '{ "op": "Del" }'
        else:
            (lexeme, file, line, column) = self.name
            return '{ "op": "Del", "value": "%s" }'%lexeme

    def explain(self):
        if self.name == None:
            return "pop an address and delete the shared variable at the address"
        else:
            return "delete the shared variable " + self.name[0]

    def eval(self, state, context):
        if self.name == None:
            av = context.pop()
            if not isinstance(av, AddressValue):
                context.failure = "Error: not an address " + \
                                    str(self.token) + " -> " + str(av)
                return
            lv = av.indexes
            name = lv[0]
        else:
            (lexeme, file, line, column) = self.name
            lv = [lexeme]
            name = lexeme

        if not state.initializing and (name not in state.vars.d):
            context.failure = "Error: deleting an uninitialized shared variable " \
                    + name + ": " + str(self.token)
        else:
            state.delete(lv)
            context.pc += 1

class StopOp(Op):
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        if self.name != None:
            (lexeme, file, line, column) = self.name
            return "Stop " + lexeme
        else:
            return "Stop"

    def jdump(self):
        if self.name != None:
            (lexeme, file, line, column) = self.name
            return '{ "op": "Stop", "value": %s }'%lexeme
        else:
            return '{ "op": "Stop" }'

    def explain(self):
        if self.name == None:
            return "pop an address and store context at that address"
        else:
            return "store context at " + self.name[0]

    def eval(self, state, context):
        if self.name == None:
            av = context.pop()
            if not isinstance(av, AddressValue):
                context.failure = "Error: not an address " + \
                                    str(self.name) + " -> " + str(av)
                return
            lv = av.indexes
            name = lv[0]
        else:
            (lexeme, file, line, column) = self.name
            lv = [lexeme]
            name = lexeme

        if not state.initializing and (name not in state.vars.d):
            context.failure = "Error: using an uninitialized shared variable " \
                    + name + ": " + str(self.name)
        else:
            # Update the context before saving it
            context.stopped = True
            context.pc += 1
            assert isinstance(state.code[context.pc], ContinueOp)

            # Save the context
            state.stop(lv, context)

class SequentialOp(Op):
    def __init__(self):
        pass

    def __repr__(self):
        return "Sequential"

    def jdump(self):
        return '{ "op": "Sequential" }'

    def explain(self):
        return "sequential consistency for variable on top of stack"

    def eval(self, state, context):
        # TODO
        context.pop()

class ContinueOp(Op):
    def __repr__(self):
        return "Continue"

    def explain(self):
        return "a no-op, must follow a Stop operation"

    def jdump(self):
        return '{ "op": "Continue" }'

    def eval(self, state, context):
        context.pc += 1

class AddressOp(Op):
    def __repr__(self):
        return "Address"

    def jdump(self):
        return '{ "op": "Address" }'

    def explain(self):
        return "combine the top two values on the stack into an address and push the result"

    def eval(self, state, context):
        index = context.pop()
        av = context.pop()
        assert isinstance(av, AddressValue), av
        context.push(AddressValue(av.indexes + [index]))
        context.pc += 1

class StoreVarOp(Op):
    def __init__(self, v):
        self.v = v

    def __repr__(self):
        if self.v == None:
            return "StoreVar"
        else:
            return "StoreVar " + self.convert(self.v)

    def jdump(self):
        if self.v == None:
            return '{ "op": "StoreVar" }'
        else:
            return '{ "op": "StoreVar", "value": "%s" }'%self.convert(self.v)

    def explain(self):
        if self.v == None:
            return "pop a value and the address of a method variable and store the value at that address"
        else:
            return "pop a value and store in " + self.convert(self.v)

    # TODO.  Check error message.  Doesn't seem right
    def eval(self, state, context):
        if self.v == None:
            value = context.pop()
            av = context.pop();
            assert isinstance(av, AddressValue)
            try:
                context.set(av.indexes, value)
                context.pc += 1
            except AttributeError:
                context.failure = "Error: " + str(av.indexes) + " not a dictionary"
        else:
            try:
                self.store(context, self.v, context.pop())
                context.pc += 1
            except AttributeError:
                context.failure = "Error: " + str(self.v) + " -- not a dictionary"

class DelVarOp(Op):
    def __init__(self, v):
        self.v = v

    def __repr__(self):
        if self.v == None:
            return "DelVar"
        else:
            (lexeme, file, line, column) = self.v
            return "DelVar " + str(lexeme)

    def jdump(self):
        if self.v == None:
            return '{ "op": "DelVar" }'
        else:
            return '{ "op": "DelVar", "value": "%s" }'%self.convert(self.v)

    def explain(self):
        if self.v == None:
            return "pop an address of a method variable and delete that variable"
        else:
            return "delete method variable " + self.v[0]

    def eval(self, state, context):
        if self.v == None:
            av = context.pop();
            assert isinstance(av, AddressValue)
            context.delete(av.indexes)
        else:
            (lexeme, file, line, column) = self.v
            context.delete([lexeme])
        context.pc += 1

class ChooseOp(Op):
    def __repr__(self):
        return "Choose"

    def jdump(self):
        return '{ "op": "Choose" }'

    def explain(self):
        return "pop a set value and push one of its elements"

    def eval(self, state, context):
        v = context.pop()
        assert isinstance(v, SetValue), v
        assert len(v.s) == 1, v
        for e in v.s:
            context.push(e)
        context.pc += 1

class AssertOp(Op):
    def __init__(self, token, exprthere):
        self.token = token
        self.exprthere = exprthere

    def __repr__(self):
        return "Assert2" if self.exprthere else "Assert"

    def jdump(self):
        if self.exprthere:
            return '{ "op": "Assert2" }'
        else:
            return '{ "op": "Assert" }'

    def explain(self):
        if self.exprthere:
            return "pop a value and a condition and raise exception if condition is false"
        else:
            return "pop a condition and raise exception if condition is false"

    def eval(self, state, context):
        if self.exprthere:
            expr = context.pop()
        cond = context.pop()
        if not isinstance(cond, bool):
            context.failure = "Error: argument to " + str(self.token) + \
                        " must be a boolean: " + strValue(cond)
            return
        if not cond:
            (lexeme, file, line, column) = self.token
            context.failure = "Harmony Assertion (file=%s, line=%d) failed"%(file, line)
            if self.exprthere:
                context.failure += ": " + strValue(expr)
            return
        context.pc += 1

class PopOp(Op):
    def __init__(self):
        pass

    def __repr__(self):
        return "Pop"

    def jdump(self):
        return '{ "op": "Pop" }'

    def explain(self):
        return "discard the top value on the stack"

    def eval(self, state, context):
        context.pop()
        context.pc += 1

class FrameOp(Op):
    def __init__(self, name, args):
        self.name = name
        self.args = args

    def __repr__(self):
        (lexeme, file, line, column) = self.name
        return "Frame " + str(lexeme) + " " + self.convert(self.args)

    def jdump(self):
        (lexeme, file, line, column) = self.name
        return '{ "op": "Frame", "name": "%s", "args": "%s" }'%(lexeme, self.convert(self.args))

    def explain(self):
        return "start of method " + str(self.name[0])

    def eval(self, state, context):
        arg = context.pop()
        context.push(arg)               # restore for easier debugging
        context.push(context.vars)
        context.push(context.fp)
        context.fp = len(context.stack) # points to old fp, old vars, and return address
        context.vars = DictValue({ "result": novalue })
        self.store(context, self.args, arg)
        context.pc += 1

class ReturnOp(Op):
    def __repr__(self):
        return "Return"

    def jdump(self):
        return '{ "op": "Return" }'

    def explain(self):
        return "restore caller method state and push result"

    def eval(self, state, context):
        if len(context.stack) == 0:
            context.phase = "end"
            return
        result = context.get("result")
        context.fp = context.pop()
        context.vars = context.pop()
        context.pop()       # argument saved for stack trace
        assert isinstance(context.vars, DictValue)
        if len(context.stack) == 0:
            context.phase = "end"
            return
        calltype = context.pop()
        if calltype == "normal":
            pc = context.pop()
            assert isinstance(pc, PcValue)
            assert pc.pc != context.pc
            context.pc = pc.pc
            context.push(result)
        elif calltype == "interrupt":
            assert context.interruptLevel
            context.interruptLevel = False
            pc = context.pop()
            assert isinstance(pc, PcValue)
            assert pc.pc != context.pc
            context.pc = pc.pc
        elif calltype == "process":
            context.phase = "end"
        else:
            assert False, calltype

class SpawnOp(Op):
    def __repr__(self):
        return "Spawn"

    def jdump(self):
        return '{ "op": "Spawn" }'

    def explain(self):
        return "pop a pc, argument, and tag and spawn a new thread"

    def eval(self, state, context):
        if context.readonly > 0:
            context.failure = "Error: no spawn allowed in assert"
            return
        method = context.pop()
        assert isinstance(method, PcValue)
        arg = context.pop()
        this = context.pop()
        frame = state.code[method.pc]
        assert isinstance(frame, FrameOp)
        ctx = ContextValue(frame.name, method.pc, arg, this)
        ctx.push("process")
        ctx.push(arg)
        bag_add(state.ctxbag, ctx)
        context.pc += 1

class TrapOp(Op):
    def __repr__(self):
        return "Trap"

    def explain(self):
        return "pop a pc and argument and set trap"

    def jdump(self):
        return '{ "op": "Trap" }'

    def eval(self, state, context):
        method = context.pop()
        assert isinstance(method, PcValue)
        arg = context.pop()
        frame = state.code[method.pc]
        assert isinstance(frame, FrameOp)
        context.trap = (method, arg)
        context.pc += 1

class AtomicIncOp(Op):
    def __repr__(self):
        return "AtomicInc"

    def jdump(self):
        return '{ "op": "AtomicInc" }'

    def explain(self):
        return "increment atomic counter of context; thread runs uninterrupted if larger than 0"

    def eval(self, state, context):
        context.atomic += 1
        context.pc += 1

class AtomicDecOp(Op):
    def __repr__(self):
        return "AtomicDec"

    def jdump(self):
        return '{ "op": "AtomicDec" }'

    def explain(self):
        return "decrement atomic counter of context"

    def eval(self, state, context):
        assert context.atomic > 0
        context.atomic -= 1
        context.pc += 1

class ReadonlyIncOp(Op):
    def __repr__(self):
        return "ReadonlyInc"

    def jdump(self):
        return '{ "op": "ReadonlyInc" }'

    def explain(self):
        return "increment readonly counter of context; thread cannot mutate shared variables if > 0"

    def eval(self, state, context):
        context.readonly += 1
        context.pc += 1

class ReadonlyDecOp(Op):
    def __repr__(self):
        return "ReadonlyDec"

    def jdump(self):
        return '{ "op": "ReadonlyDec" }'

    def explain(self):
        return "decrement readonly counter of context"

    def eval(self, state, context):
        assert context.readonly > 0
        context.readonly -= 1
        context.pc += 1

class InvariantOp(Op):
    def __init__(self, cnt, token):
        assert cnt > 0
        self.cnt = cnt
        self.token = token

    def __repr__(self):
        return "Invariant " + str(self.cnt)

    def jdump(self):
        return '{ "op": "Invariant", "cnt": "%d" }'%self.cnt

    def explain(self):
        return "test invariant in next " + str(self.cnt) + " instructions"

    def eval(self, state, context):
        assert self.cnt > 0
        state.invariants |= {context.pc}
        context.pc += (self.cnt + 1)

class JumpOp(Op):
    def __init__(self, pc):
        self.pc = pc

    def __repr__(self):
        return "Jump " + str(self.pc)

    def jdump(self):
        return '{ "op": "Jump", "pc": "%d" }'%self.pc

    def explain(self):
        return "set program counter to " + str(self.pc)

    def eval(self, state, context):
        assert self.pc != context.pc
        context.pc = self.pc

class JumpCondOp(Op):
    def __init__(self, cond, pc):
        self.cond = cond
        self.pc = pc

    def __repr__(self):
        return "JumpCond " + str(self.cond) + " " + str(self.pc)

    def jdump(self):
        return '{ "op": "JumpCond", "pc": "%d", "cond": %s }'%(self.pc, jsonValue(self.cond))

    def explain(self):
        return "pop a value and jump to " + str(self.pc) + \
            " if the value is " + strValue(self.cond)

    def eval(self, state, context):
        c = context.pop()
        if c == self.cond:
            assert self.pc != context.pc
            context.pc = self.pc
        else:
            context.pc += 1

class NaryOp(Op):
    def __init__(self, op, n):
        self.op = op
        self.n = n

    def __repr__(self):
        (lexeme, file, line, column) = self.op
        return "%d-ary "%self.n + str(lexeme)

    def jdump(self):
        (lexeme, file, line, column) = self.op
        return '{ "op": "Nary", "arity": %d, "value": "%s" }'%(self.n, lexeme)

    def explain(self):
        return "pop " + str(self.n) + \
            (" value" if self.n == 1 else " values") + \
            " and push the result of applying " + self.op[0]

    def atLabel(self, state, pc):
        bag = {}
        for (ctx, cnt) in state.ctxbag.items():
            if ctx.pc == pc:
                nametag = DictValue({ 0: PcValue(ctx.entry), 1: ctx.arg })
                c = bag.get(nametag)
                bag[nametag] = cnt if c == None else (c + cnt)
        return DictValue(bag)

    def contexts(self, state):
        return DictValue({ **state.ctxbag, **state.termbag, **state.stopbag })

    def concat(self, d1, d2):
        result = []
        keys = sorted(d1.d.keys(), key=keyValue)
        for k in keys:
            result.append(d1.d[k])
        keys = sorted(d2.d.keys(), key=keyValue)
        for k in keys:
            result.append(d2.d[k])
        return DictValue({ i:result[i] for i in range(len(result)) })

    def checktype(self, state, context, args, chk):
        assert len(args) == self.n, (self, args)
        if not chk:
            context.failure = "Error: unexpected types in " + str(self.op) + \
                        " operands: " + str(list(reversed(args)))
            return False
        return True

    def checkdmult(self, state, context, args, d, e):
        if not self.checktype(state, context, args, type(e) == int):
            return False
        keys = set(range(len(d.d)))
        if d.d.keys() != keys:
            context.failure = "Error: one operand in " + str(self.op) + \
                        " must be a list: " + str(list(reversed(args)))
            return False
        return True

    def dmult(self, d, e):
        n = len(d.d)
        lst = { i:d.d[i % n] for i in range(e * n) }
        return DictValue(lst)

    def eval(self, state, context):
        (op, file, line, column) = self.op
        assert len(context.stack) >= self.n
        sa = context.stack[-self.n:]
        if op in { "+", "*", "&", "|", "^" }:
            assert self.n > 1
            e2 = context.pop()
            for i in range(1, self.n):
                e1 = context.pop()
                if op == "+":
                    if type(e1) == int:
                        if not self.checktype(state, context, sa, type(e2) == int):
                            return
                        e2 += e1
                    else:
                        if not self.checktype(state, context, sa, isinstance(e1, DictValue)):
                            return
                        if not self.checktype(state, context, sa, isinstance(e2, DictValue)):
                            return
                        e2 = self.concat(e1, e2)
                elif op == "*":
                    if isinstance(e1, DictValue) or isinstance(e2, DictValue):
                        if isinstance(e1, DictValue) and not self.checkdmult(state, context, sa, e1, e2):
                            return
                        if isinstance(e2, DictValue) and not self.checkdmult(state, context, sa, e2, e1):
                            return
                        e2 = self.dmult(e1, e2) if isinstance(e1, DictValue) else self.dmult(e2, e1)
                    else:
                        if not self.checktype(state, context, sa, type(e1) == int):
                            return
                        if not self.checktype(state, context, sa, type(e2) == int):
                            return
                        e2 *= e1
                elif op == "&":
                    if type(e1) == int:
                        if not self.checktype(state, context, sa, type(e2) == int):
                            return
                        e2 &= e1
                    elif type(e1) == SetValue:
                        if not self.checktype(state, context, sa, isinstance(e2, SetValue)):
                            return
                        e2 = SetValue(e1.s & e2.s)
                    else:
                        if not self.checktype(state, context, sa, isinstance(e1, DictValue)):
                            return
                        if not self.checktype(state, context, sa, isinstance(e2, DictValue)):
                            return
                        d = {}
                        for (k1, v1) in e1.d.items():
                            if k1 in e2.d:
                                v2 = e2.d[k1]
                                d[k1] = v1 if keyValue(v1) < keyValue(v2) else v2
                        e2 = DictValue(d)
                elif op == "|":
                    if type(e1) == int:
                        if not self.checktype(state, context, sa, type(e2) == int):
                            return
                        e2 |= e1
                    elif type(e1) == SetValue:
                        if not self.checktype(state, context, sa, isinstance(e2, SetValue)):
                            return
                        e2 = SetValue(e1.s | e2.s)
                    else:
                        if not self.checktype(state, context, sa, isinstance(e1, DictValue)):
                            return
                        if not self.checktype(state, context, sa, isinstance(e2, DictValue)):
                            return
                        d = {}
                        for (k1, v1) in e1.d.items():
                            if k1 in e2.d:
                                v2 = e2.d[k1]
                                d[k1] = v1 if keyValue(v1) > keyValue(v2) else v2
                            else:
                                d[k1] = v1
                        for (k2, v2) in e2.d.items():
                            if k2 not in e1.d:
                                d[k2] = v2
                        e2 = DictValue(d)
                elif op == "^": 
                    if type(e1) == int:
                        if not self.checktype(state, context, sa, type(e2) == int):
                            return
                        e2 ^= e1
                    else:
                        if not self.checktype(state, context, sa, isinstance(e1, SetValue)):
                            return
                        if not self.checktype(state, context, sa, isinstance(e2, SetValue)):
                            return
                        e2 = SetValue(e2.s.union(e1.s).difference(e2.s.intersection(e1.s)))
                else:
                    assert False, op
            context.push(e2)
        elif self.n == 1:
            e = context.pop()
            if op == "-":
                if not self.checktype(state, context, sa, type(e) == int or isinstance(e, float)):
                    return
                context.push(-e)
            elif op == "~":
                if not self.checktype(state, context, sa, type(e) == int):
                    return
                context.push(~e)
            elif op == "not":
                if not self.checktype(state, context, sa, isinstance(e, bool)):
                    return
                context.push(not e)
            elif op == "abs":
                if not self.checktype(state, context, sa, type(e) == int):
                    return
                context.push(abs(e))
            elif op == "atLabel":
                if not context.atomic:
                    context.failure = "not in atomic block: " + str(self.op)
                    return
                if not self.checktype(state, context, sa, isinstance(e, PcValue)):
                    return
                context.push(self.atLabel(state, e.pc))
            elif op == "get_context":
                # if not self.checktype(state, context, sa, isinstance(e, int)):
                #   return
                context.push(context.copy())
            elif op == "contexts":
                if not context.atomic:
                    context.failure = "not in atomic block: " + str(self.op)
                    return
                # if not self.checktype(state, context, sa, isinstance(e, str)):
                #     return
                context.push(self.contexts(state))
            elif op == "print":
                print("PRINT", e, "TNIRP")
                context.push(e)
            elif op == "IsEmpty":
                if isinstance(e, DictValue):
                    context.push(e.d == {})
                elif self.checktype(state, context, sa, isinstance(e, SetValue)):
                    context.push(e.s == set())
            elif op == "min":
                if isinstance(e, DictValue):
                    if len(e.d) == 0:
                        context.failure = "Error: min() invoked with empty dict: " + str(self.op)
                    else:
                        context.push(min(e.d.values(), key=keyValue))
                else:
                    if not self.checktype(state, context, sa, isinstance(e, SetValue)):
                        return
                    if len(e.s) == 0:
                        context.failure = "Error: min() invoked with empty set: " + str(self.op)
                    else:
                        context.push(min(e.s, key=keyValue))
            elif op == "max":
                if isinstance(e, DictValue):
                    if len(e.d) == 0:
                        context.failure = "Error: max() invoked with empty dict: " + str(self.op)
                    else:
                        context.push(max(e.d.values(), key=keyValue))
                else:
                    if not self.checktype(state, context, sa, isinstance(e, SetValue)):
                        return
                    if len(e.s) == 0:
                        context.failure = "Error: max() invoked with empty set: " + str(self.op)
                    else:
                        context.push(max(e.s, key=keyValue))
            elif op == "len":
                if isinstance(e, SetValue):
                    context.push(len(e.s))
                else:
                    if not self.checktype(state, context, sa, isinstance(e, DictValue)):
                        return
                    context.push(len(e.d))
            elif op == "any":
                if isinstance(e, SetValue):
                    context.push(any(e.s))
                else:
                    if not self.checktype(state, context, sa, isinstance(e, DictValue)):
                        return
                    context.push(any(e.d.values()))
            elif op == "all":
                if isinstance(e, SetValue):
                    context.push(all(e.s))
                else:
                    if not self.checktype(state, context, sa, isinstance(e, DictValue)):
                        return
                    context.push(all(e.d.values()))
            elif op == "keys":
                if not self.checktype(state, context, sa, isinstance(e, DictValue)):
                    return
                context.push(SetValue(set(e.d.keys())))
            elif op == "hash":
                context.push((e,).__hash__())
            else:
                assert False, self
        elif self.n == 2:
            e2 = context.pop()
            e1 = context.pop()
            if op == "==":
                # if not self.checktype(state, context, sa, type(e1) == type(e2)):
                #     return
                context.push(e1 == e2)
            elif op == "!=":
                # if not self.checktype(state, context, sa, type(e1) == type(e2)):
                #     return
                context.push(e1 != e2)
            elif op == "<":
                context.push(keyValue(e1) < keyValue(e2))
            elif op == "<=":
                context.push(keyValue(e1) <= keyValue(e2))
            elif op == ">":
                context.push(keyValue(e1) > keyValue(e2))
            elif op == ">=":
                context.push(keyValue(e1) >= keyValue(e2))
            elif op == "-":
                if type(e1) == int or isinstance(e1, float):
                    if not self.checktype(state, context, sa, type(e2) == int or isinstance(e2, float)):
                        return
                    context.push(e1 - e2)
                else:
                    if not self.checktype(state, context, sa, isinstance(e1, SetValue)):
                        return
                    if not self.checktype(state, context, sa, isinstance(e2, SetValue)):
                        return
                    context.push(SetValue(e1.s.difference(e2.s)))
            elif op in { "/", "//" }:
                if not self.checktype(state, context, sa, type(e1) == int or isinstance(e1, float)):
                    return
                if not self.checktype(state, context, sa, type(e2) == int or isinstance(e2, float)):
                    return
                if type(e1) == int and (e2 == math.inf or e2 == -math.inf):
                    context.push(0)
                else:
                    context.push(e1 // e2)
            elif op in { "%", "mod" }:
                if not self.checktype(state, context, sa, type(e1) == int):
                    return
                if not self.checktype(state, context, sa, type(e2) == int):
                    return
                context.push(e1 % e2)
            elif op == "**":
                if not self.checktype(state, context, sa, type(e1) == int):
                    return
                if not self.checktype(state, context, sa, type(e2) == int):
                    return
                context.push(e1 ** e2)
            elif op == "<<":
                if not self.checktype(state, context, sa, type(e1) == int):
                    return
                if not self.checktype(state, context, sa, type(e2) == int):
                    return
                context.push(e1 << e2)
            elif op == ">>":
                if not self.checktype(state, context, sa, type(e1) == int):
                    return
                if not self.checktype(state, context, sa, type(e2) == int):
                    return
                context.push(e1 >> e2)
            elif op == "..":
                if not self.checktype(state, context, sa, type(e1) == int):
                    return
                if not self.checktype(state, context, sa, type(e2) == int):
                    return
                context.push(SetValue(set(range(e1, e2+1))))
            elif op == "in":
                if isinstance(e2, SetValue):
                    context.push(e1 in e2.s)
                elif not self.checktype(state, context, sa, isinstance(e2, DictValue)):
                    return
                else:
                    context.push(e1 in e2.d.values())
            elif op == "SetAdd":
                assert isinstance(e1, SetValue)
                context.push(SetValue(e1.s | {e2}))
            elif op == "BagAdd":
                assert isinstance(e1, DictValue)
                d = e1.d.copy()
                if e2 in d:
                    assert isinstance(d[e2], int)
                    d[e2] += 1
                else:
                    d[e2] = 1
                context.push(DictValue(d))
            else:
                assert False, self
        elif self.n == 3:
            e3 = context.pop()
            e2 = context.pop()
            e1 = context.pop()
            if op == "DictAdd":
                assert isinstance(e1, DictValue)
                d = e1.d.copy()
                if e2 in d:
                    if keyValue(d[e2]) >= keyValue(e3):
                        context.push(e1)
                    else:
                        d[e2] = e3
                        context.push(DictValue(d))
                else:
                    d[e2] = e3
                    context.push(DictValue(d))
            else:
                assert False, self
        else:
            assert False, self
        context.pc += 1

class ApplyOp(Op):
    def __init__(self, token):
        self.token = token

    def __repr__(self):
        return "Apply"

    def jdump(self):
        return '{ "op": "Apply" }'

    def explain(self):
        return "pop a pc or dictionary f and an index i and push f(i)"

    def eval(self, state, context):
        method = context.pop()
        e = context.pop()
        if isinstance(method, DictValue):
            try:
                context.push(method.d[e])
            except KeyError:
                context.failure = "Error: no entry " + str(e) + " in " + \
                        str(self.token) + " = " + str(method)
                return
            context.pc += 1
        elif isinstance(method, ContextValue):
            if e == "this":
                context.push(method.this)
            elif e == "name":
                context.push(method.name)
            elif e == "entry":
                context.push(method.entry)
            elif e == "arg":
                context.push(method.arg)
            elif e == "mode":
                if method.failure != None:
                    context.push("failed")
                elif method.phase == "end":
                    context.push("terminated")
                elif method.stopped:
                    context.push("stopped")
                else:
                    context.push("normal")
            context.pc += 1
        else:
            # TODO.  Need a token to have location
            if not isinstance(method, PcValue):
                context.failure = "pc = " + str(context.pc) + \
                    ": Error: must be either a method or a dictionary"
                return
            context.push(PcValue(context.pc + 1))
            context.push("normal")
            context.push(e)
            assert method.pc != context.pc
            context.pc = method.pc

class AST:
    def assign(self, scope, var):
        if isinstance(var, tuple):
            scope.checkUnused(var)
            (lexeme, file, line, column) = var
            scope.names[lexeme] = ("local", var)
        else:
            assert isinstance(var, list)
            for v in var:
                self.assign(scope, v)

    def delete(self, scope, code, var):
        if isinstance(var, tuple):
            code.append(DelVarOp(var))  # remove variable
            (lexeme, file, line, column) = var
            del scope.names[lexeme]
        else:
            assert isinstance(var, list)
            assert len(var) > 0
            for v in var:
                self.delete(scope, code, v)

    def isConstant(self, scope):
        return False

    def eval(self, scope, code):
        state = State(code, scope.labels)
        ctx = ContextValue(("__eval__", None, None, None), 0, novalue, novalue)
        ctx.atomic = 1
        while ctx.pc != len(code) and ctx.failure == None:
            code[ctx.pc].eval(state, ctx)
        if ctx.failure != None:
            print("constant evaluation failed: ", self, ctx.failure)
            sys.exit(1)
        return ctx.pop()

    def compile(self, scope, code):
        if self.isConstant(scope):
            code2 = []
            self.gencode(scope, code2)
            v = self.eval(scope, code2)
            code.append(PushOp((v, None, None, None)))
        else:
            self.gencode(scope, code)

    # Return if this lvalue refers to a local or a shared variable
    def isShared(self, scope):
        return True

    # This is supposed to push the address of an lvalue
    def ph1(self, scope, code):
        print("Cannot use in left-hand side expression:", self)
        sys.exit(1)

    def rec_comprehension(self, scope, code, iter, pc, N, vars, ctype):
        if iter == []:
            (lexeme, file, line, column) = self.token
            if ctype == "list":
                code.append(LoadVarOp(N))
            elif ctype == "dict":
                # code.append(LoadVarOp(vars[0] if len(vars) == 1 else vars))
                self.key.compile(scope, code)
            self.value.compile(scope, code)
            if ctype == "set":
                code.append(NaryOp(("SetAdd", file, line, column), 2))
            elif ctype == "dict":
                code.append(NaryOp(("DictAdd", file, line, column), 3))
            elif ctype == "list":
                code.append(NaryOp(("DictAdd", file, line, column), 3))
                code.append(IncVarOp(N))
            elif ctype == "bag":
                code.append(NaryOp(("BagAdd", file, line, column), 2))
                code.append(IncVarOp(N))
            return

        (type, rest) = iter[0]
        assert type == "for" or type == "where", type

        if type == "for":
            (var, expr) = rest

            self.assign(scope, var)
            uid = len(code)
            (lexeme, file, line, column) = self.token

            # Evaluate the set and store in a temporary variable
            expr.compile(scope, code)
            S = ("$s"+str(uid), file, line, column)
            code.append(StoreVarOp(S))

            # Now generate the code:
            #   while X != {}:
            #       var := oneof X
            #       X := X - var
            #       push value
            pc = len(code)
            code.append(LoadVarOp(S))
            code.append(NaryOp(("IsEmpty", file, line, column), 1))
            tst = len(code)
            code.append(None)       # going to plug in a Jump op here
            code.append(CutOp(S, var))  
            self.rec_comprehension(scope, code, iter[1:], pc, N, vars + [var], ctype)
            code.append(JumpOp(pc))
            code[tst] = JumpCondOp(True, len(code))
            self.delete(scope, code, var)
            code.append(DelVarOp(S))

        else:
            assert type == "where"
            negate = isinstance(rest, NaryAST) and rest.op[0] == "not"
            cond = rest.args[0] if negate else rest
            cond.compile(scope, code)
            code.append(JumpCondOp(negate, pc))
            self.rec_comprehension(scope, code, iter[1:], pc, N, vars, ctype)

    def comprehension(self, scope, code, ctype):
        # Keep track of the size
        uid = len(code)
        (lexeme, file, line, column) = self.token
        N = ("$n"+str(uid), file, line, column)
        if ctype == "set":
            code.append(PushOp((SetValue(set()), file, line, column)))
        elif ctype == "dict":
            code.append(PushOp((novalue, file, line, column)))
        elif ctype in { "bag", "list" }:
            code.append(PushOp((0, file, line, column)))
            code.append(StoreVarOp(N))
            code.append(PushOp((novalue, file, line, column)))
        self.rec_comprehension(scope, code, self.iter, None, N, [], ctype)
        if ctype == { "bag", "list" }:
            code.append(DelVarOp(N))

    def doImport(self, scope, code, module):
        (lexeme, file, line, column) = module
        # assert lexeme not in scope.names        # TODO
        if lexeme not in imported:
            code.append(PushOp((novalue, file, line, column)))
            code.append(StoreOp(module, module, []))

            # module name replacement with -m flag
            modname = modules[lexeme] if lexeme in modules \
                                else lexeme

            # create a new scope
            scope2 = Scope(None)
            scope2.prefix = [lexeme]
            scope2.locations = scope.locations
            scope2.labels = scope.labels

            found = False
            for dir in [ os.path.dirname(namestack[-1]), "modules", "." ]:
                filename = dir + "/" + modname + ".hny"
                if os.path.exists(filename):
                    with open(filename) as f:
                        load(f, filename, scope2, code)
                    found = True
                    break
            if not found:
                if modname in internal_modules:
                    load_string(internal_modules[lexeme],
                        "<internal>/" + modname + ".hny", scope2, code)
                else:
                    print("Can't find module", modname, "imported from", namestack)
                    sys.exit(1)
            
            imported[lexeme] = scope2

        scope.names[lexeme] = ("module", imported[lexeme])

    def getLabels(self):
        return set()

    def getImports(self):
        return []

class ConstantAST(AST):
    def __init__(self, const):
        self.const = const

class ConstantAST(AST):
    def __init__(self, const):
        self.const = const

    def __repr__(self):
        return "ConstantAST" + str(self.const)

    def compile(self, scope, code):
        code.append(PushOp(self.const))

    def isConstant(self, scope):
        return True

class NameAST(AST):
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return "NameAST" + str(self.name)

    def compile(self, scope, code):
        (t, v) = scope.lookup(self.name)
        if t == "local":
            code.append(LoadVarOp(self.name))
        elif t == "constant":
            (lexeme, file, line, column) = self.name
            code.append(PushOp(v))
        else:
            assert t in { "global", "module" }
            code.append(LoadOp(self.name, self.name, scope.prefix))

    def isShared(self, scope):
        (t, v) = scope.find(self.name)
        assert t in { "constant", "local", "global", "module" }
        return t != "local"

    def ph1(self, scope, code):
        (t, v) = scope.lookup(self.name)
        if t == "local":
            (lexeme, file, line, column) = v
            code.append(PushOp((AddressValue([lexeme]), file, line, column)))
        elif t == "constant":
            print("constant cannot be an lvalue:", self.name)
            sys.exit(1)
        else:
            (lexeme, file, line, column) = self.name
            code.append(PushOp((AddressValue(scope.prefix + [lexeme]), file, line, column)))

    def ph2(self, scope, code, skip):
        if skip > 0:
            code.append(MoveOp(skip + 2))
            code.append(MoveOp(2))
        (t, v) = scope.lookup(self.name)
        if t == "local":
            code.append(StoreVarOp(None))
        else:
            assert t == "global", (t, v)
            code.append(StoreOp(None, self.name, None))

    def isConstant(self, scope):
        (lexeme, file, line, column) = self.name
        (t, v) = scope.lookup(self.name)
        if t in { "local", "global", "module" }:
            return False
        elif t == "constant":
            return True
        else:
            assert False, (t, v, self.name)

class SetAST(AST):
    def __init__(self, collection):
        self.collection = collection

    def __repr__(self):
        return str(self.collection)

    def isConstant(self, scope):
        return all(x.isConstant(scope) for x in self.collection)

    def gencode(self, scope, code):
        code.append(PushOp((SetValue(set()), None, None, None)))
        for e in self.collection:
            e.compile(scope, code)
            code.append(NaryOp(("SetAdd", None, None, None), 2))

class BagAST(AST):
    def __init__(self, collection):
        self.collection = collection

    def __repr__(self):
        return "Bag(" + str(self.collection) + ")"

    def isConstant(self, scope):
        return all(x.isConstant(scope) for x in self.collection)

    def gencode(self, scope, code):
        code.append(PushOp((novalue, None, None, None)))
        for e in self.collection:
            e.compile(scope, code)
            code.append(NaryOp(("BagAdd", None, None, None), 2))

class RangeAST(AST):
    def __init__(self, lhs, rhs, token):
        self.lhs = lhs
        self.rhs = rhs
        self.token = token

    def __repr__(self):
        return "Range(%s,%s)"%(self.lhs, self.rhs)

    def isConstant(self, scope):
        return self.lhs.isConstant(scope) and self.rhs.isConstant(scope)

    def gencode(self, scope, code):
        self.lhs.compile(scope, code)
        self.rhs.compile(scope, code)
        (lexeme, file, line, column) = self.token
        code.append(NaryOp(("..", file, line, column), 2))

class TupleAST(AST):
    def __init__(self, list, token):
        self.list = list
        self.token = token

    def __repr__(self):
        return "TupleAST" + str(self.list)

    def isConstant(self, scope):
        return all(v.isConstant(scope) for v in self.list)

    def gencode(self, scope, code):
        (lexeme, file, line, column) = self.token
        code.append(PushOp((novalue, file, line, column)))
        for (i, v) in enumerate(self.list):
            code.append(PushOp((i, file, line, column)))
            v.compile(scope, code)
            code.append(NaryOp(("DictAdd", file, line, column), 3))

    def isShared(self, scope):
        assert False

    def ph1(self, scope, code):
        for lv in self.list:
            lv.ph1(scope, code)

    def ph2(self, scope, code, skip):
        n = len(self.list)
        code.append(SplitOp(n))
        for lv in reversed(self.list):
            n -= 1
            lv.ph2(scope, code, skip + n)

class DictAST(AST):
    def __init__(self, record):
        self.record = record

    def __repr__(self):
        return "DictAST" + str(self.record)

    def isConstant(self, scope):
        return all(k.isConstant(scope) and v.isConstant(scope)
                        for (k, v) in self.record)

    def gencode(self, scope, code):
        code.append(PushOp((novalue, None, None, None)))
        for (k, v) in self.record:
            k.compile(scope, code)
            v.compile(scope, code)
            code.append(NaryOp(("DictAdd", None, None, None), 3))

class SetComprehensionAST(AST):
    def __init__(self, value, iter, token):
        self.value = value
        self.iter = iter
        self.token = token

    def __repr__(self):
        return "SetComprehension(" + str(self.var) + ")"

    def compile(self, scope, code):
        self.comprehension(scope, code, "set")

class BagComprehensionAST(AST):
    def __init__(self, value, iter, token):
        self.value = value
        self.iter = iter
        self.token = token

    def __repr__(self):
        return "BagComprehension(" + str(self.var) + ")"

    def compile(self, scope, code):
        self.comprehension(scope, code, "bag")

class DictComprehensionAST(AST):
    def __init__(self, key, value, iter, token):
        self.key = key
        self.value = value
        self.iter = iter
        self.token = token

    def __repr__(self):
        return "DictComprehension(" + str(self.key) + ")"

    def compile(self, scope, code):
        self.comprehension(scope, code, "dict")

class ListComprehensionAST(AST):
    def __init__(self, value, iter, token):
        self.value = value
        self.iter = iter
        self.token = token

    def __repr__(self):
        return "ListComprehension(" + str(self.var) + ")"

    def compile(self, scope, code):
        self.comprehension(scope, code, "list")

# N-ary operator
class NaryAST(AST):
    def __init__(self, op, args):
        self.op = op
        self.args = args
        assert all(isinstance(x, AST) for x in args), args

    def __repr__(self):
        return "NaryOp(" + str(self.op) + ", " + str(self.args) + ")"

    def isConstant(self, scope):
        (op, file, line, column) = self.op
        if op in { "atLabel", "choose", "contexts", "get_context" }:
            return False
        return all(x.isConstant(scope) for x in self.args)

    def gencode(self, scope, code):
        (op, file, line, column) = self.op
        n = len(self.args)
        if op == "and" or op == "or":
            self.args[0].compile(scope, code)
            pcs = []
            for i in range(1, n):
                pcs.append(len(code))
                code.append(None)
                self.args[i].compile(scope, code)
            code.append(JumpOp(len(code) + 2))
            for pc in pcs:
                code[pc] = JumpCondOp(op == "or", len(code))
            code.append(PushOp((op == "or", file, line, column)))
        elif op == "=>":
            assert n == 2, n
            self.args[0].compile(scope, code)
            pc = len(code)
            code.append(None)
            self.args[1].compile(scope, code)
            code.append(JumpOp(len(code) + 2))
            code[pc] = JumpCondOp(False, len(code))
            code.append(PushOp((True, file, line, column)))
        elif op == "if":
            assert n == 3, n
            negate = isinstance(self.args[1], NaryAST) and self.args[1].op[0] == "not"
            cond = self.args[1].args[0] if negate else self.args[1]
            cond.compile(scope, code)
            pc1 = len(code)
            code.append(None)
            self.args[0].compile(scope, code)
            pc2 = len(code)
            code.append(None)
            self.args[2].compile(scope, code)
            code[pc1] = JumpCondOp(negate, pc2 + 1)
            code[pc2] = JumpOp(len(code))
        elif op == "choose":
            assert n == 1
            self.args[0].compile(scope, code)
            code.append(ChooseOp())
        else:
            for i in range(n):
                self.args[i].compile(scope, code)
            code.append(NaryOp(self.op, n))

class CmpAST(AST):
    def __init__(self, ops, args):
        self.ops = ops
        self.args = args
        assert len(ops) == len(args) - 1
        assert all(isinstance(x, AST) for x in args), args

    def __repr__(self):
        return "CmpOp(" + str(self.ops) + ", " + str(self.args) + ")"

    def isConstant(self, scope):
        return all(x.isConstant(scope) for x in self.args)

    def gencode(self, scope, code):
        n = len(self.args)
        self.args[0].compile(scope, code)
        pcs = []
        (lexeme, file, line, column) = self.ops[0]
        T = ("__cmp__"+str(len(code)), file, line, column)
        for i in range(1, n-1):
            self.args[i].compile(scope, code)
            code.append(DupOp())
            code.append(StoreVarOp(T))
            code.append(NaryOp(self.ops[i-1], 2))
            code.append(DupOp())
            pcs.append(len(code))
            code.append(None)
            code.append(PopOp())
            code.append(LoadVarOp(T))
        self.args[n-1].compile(scope, code)
        code.append(NaryOp(self.ops[n-2], 2))
        for pc in pcs:
            code[pc] = JumpCondOp(False, len(code))
        if n > 2:
            code.append(DelVarOp(T))

class ApplyAST(AST):
    def __init__(self, method, arg, token):
        self.method = method
        self.arg = arg
        self.token = token

    def __repr__(self):
        return "ApplyAST(" + str(self.method) + ", " + str(self.arg) + ")"

    def varCompile(self, scope, code):
        if isinstance(self.method, NameAST):
            (t, v) = scope.lookup(self.method.name)
            if t == "global":
                self.method.ph1(scope, code)
                self.arg.compile(scope, code)
                code.append(AddressOp())
                return True
            else:
                return False

        if isinstance(self.method, PointerAST):
            self.method.expr.compile(scope, code)
            self.arg.compile(scope, code)
            code.append(AddressOp())
            return True

        if isinstance(self.method, ApplyAST):
            if self.method.varCompile(scope, code):
                self.arg.compile(scope, code)
                code.append(AddressOp())
                return True;
            else:
                return False

        return False

    def compile(self, scope, code):
        if isinstance(self.method, NameAST):
            (t, v) = scope.lookup(self.method.name)
            # See if it's of the form "module.constant":
            if t == "module" and isinstance(self.arg, ConstantAST) and isinstance(self.arg.const[0], str):
                (t2, v2) = v.lookup(self.arg.const)
                if t2 == "constant":
                    code.append(PushOp(v2))
                    return
            # Decrease chances of data race
            if t == "global":
                self.method.ph1(scope, code)
                self.arg.compile(scope, code)
                code.append(AddressOp())
                code.append(LoadOp(None, self.token, None))
                return

        # Decrease chances of data race
        if self.varCompile(scope, code):
            code.append(LoadOp(None, self.token, None))
            return

        # TODO: is there an issue below with evaluation order
        #       not being the same as program order?
        self.arg.compile(scope, code)
        self.method.compile(scope, code)
        code.append(ApplyOp(self.token))

    def isShared(self, scope):
        return self.method.isShared(scope)

    def ph1(self, scope, code):
        # See if it's of the form "module.constant":
        if isinstance(self.method, NameAST):
            (t, v) = scope.lookup(self.method.name)
            if t == "module" and isinstance(self.arg, ConstantAST) and isinstance(self.arg.const[0], str):
                (t2, v2) = v.lookup(self.arg.const)
                if t2 == "constant":
                    print("Cannot assign to constant", self.method.name, self.arg.const)
                    sys.exit(1)
        self.method.ph1(scope, code)
        self.arg.compile(scope, code)
        code.append(AddressOp())

    def ph2(self, scope, code, skip):
        if skip > 0:
            code.append(MoveOp(skip + 2))
            code.append(MoveOp(2))
        shared = self.method.isShared(scope)
        st = StoreOp(None, self.token, None) if shared else StoreVarOp(None)
        code.append(st)

class Rule:
    def expect(self, rule, b, got, want):
        if not b:
            print("Parse error in %s."%rule, "Got", got, ":", want)
            sys.exit(1)

    def forParse(self, t, closers):
        (bv, t) = BoundVarRule().parse(t)
        (lexeme, file, line, column) = token = t[0]
        self.expect("for expression", lexeme == "in", t[0], "expected 'in'")
        (expr, t) = NaryRule(closers | { "where", "for" }).parse(t[1:])
        return ((bv, expr), t)

    def whereParse(self, t, closers):
        return NaryRule(closers | { "for", "where" }).parse(t)

    def iterParse(self, t, closers):
        (ve, t) = self.forParse(t, closers)
        lst = [("for", ve)]
        (lexeme, file, line, column) = t[0]
        while lexeme not in closers:
            self.expect("for expression", lexeme == "for" or lexeme == "where",
                            lexeme, "expected 'for' or 'where'")
            if lexeme == "for":
                (ve, t) = self.forParse(t[1:], closers)
                lst.append(("for", ve))
            else:
                assert lexeme == "where"
                (st, t) = self.whereParse(t[1:], closers)
                lst.append(("where", st))
            (lexeme, file, line, column) = t[0]
        return (lst, t)

class NaryRule(Rule):
    def __init__(self, closers):
        self.closers = closers

    def parse(self, t):
        (ast, t) = ExpressionRule().parse(t)
        if ast == False or t == []:
            return (ast, t)
        (lexeme, file, line, column) = t[0]
        if lexeme in self.closers:
            return (ast, t)
        args = [ast]
        op = t[0]
        invert = None
        if isunaryop(op[0]) and op[0] != '-':  # mostly for use in "a not in s", but more general
            invert = op
            t = t[1:]
            op = t[0]
        self.expect("n-ary operation", isbinaryop(op[0]) or op[0] == "if", op,
                    "expected binary operation or 'if'")
        if iscmpop(op[0]):
            assert invert == None           # TODO
            ops = []
            while iscmpop(lexeme):
                ops.append(t[0])
                (ast3, t) = ExpressionRule().parse(t[1:])
                if ast3 == False:
                    print("expected an expression after n-ary comparison operation in", op)
                    sys.exit(1)
                args.append(ast3)
                if t == []:
                    break
                (lexeme, file, line, column) = t[0]
            if t != []:
                self.expect("n-ary operation", lexeme in self.closers,
                        t[0], "expected one of %s"%self.closers)
            return (CmpAST(ops, args), t)
        if op[0] == "if":
            (ast2, t) = NaryRule({"else"}).parse(t[1:])
        else:
            (ast2, t) = ExpressionRule().parse(t[1:])
        if ast2 == False:
            print("expected an expression after operation", op)
            sys.exit(1)
        args.append(ast2)
        if t != []:
            (lexeme, file, line, column) = t[0]
            if op[0] == "if":
                self.expect("n-ary operation", lexeme == "else", t[0], "expected 'else'")
                (ast3, t) = ExpressionRule().parse(t[1:])
                if ast3 == False:
                    print("expected an expression after else in", op)
                    sys.exit(1)
                args.append(ast3)
                if t != []:
                    (lexeme, file, line, column) = t[0]
            elif (op[0] == lexeme) and (lexeme in { "+", "*", "|", "&", "^", "and", "or" }):
                while lexeme == op[0]:
                    (ast3, t) = ExpressionRule().parse(t[1:])
                    if ast3 == False:
                        print("expected an expression after n-ary operation in", op)
                        sys.exit(1)
                    args.append(ast3)
                    if t == []:
                        break
                    (lexeme, file, line, column) = t[0]
            if t != []:
                self.expect("n-ary operation", lexeme in self.closers, t[0],
                                "expected one of %s"%self.closers)
        ast = NaryAST(op, args)
        if invert != None:
            return (NaryAST(invert, [ast]), t)
        else:
            return (ast, t)

class SetComprehensionRule(Rule):
    def __init__(self, value):
        self.value = value

    def parse(self, t):
        token = t[0]
        (lst, t) = self.iterParse(t[1:], {"}"})
        return (SetComprehensionAST(self.value, lst, token), t[1:])

class BagComprehensionRule(Rule):
    def __init__(self, value):
        self.value = value

    def parse(self, t):
        token = t[0]
        (lst, t) = self.iterParse(t[1:], {"}"})
        return (BagComprehensionAST(self.value, lst, token), t[1:])

class DictComprehensionRule(Rule):
    def __init__(self, key, value):
        self.key = key
        self.value = value

    def parse(self, t):
        token = t[0]
        (lst, t) = self.iterParse(t[1:], {"}"})
        return (DictComprehensionAST(self.key, self.value, lst, token), t[1:])

class ListComprehensionRule(Rule):
    def __init__(self, value, closers):
        self.value = value
        self.closers = closers

    def parse(self, t):
        token = t[0]
        (lst, t) = self.iterParse(t[1:], self.closers) 
        return (ListComprehensionAST(self.value, lst, token), t)

class SetRule(Rule):
    def parse(self, t):
        (lexeme, file, line, column) = t[0]
        self.expect("set expression", lexeme == "{", t[0], "expected '{'")
        (lexeme, file, line, column) = t[1]
        if lexeme == "}":
            return (SetAST([]), t[2:])
        s = []
        while True:
            (next, t) = NaryRule({":", "for", "..", ",", "}"}).parse(t[1:])
            if next == False:
                return (False, t)
            s.append(next)
            (lexeme, file, line, column) = t[0]
            if lexeme == ":":
                self.expect("set/dict", len(s) == 1, t[0],
                            "cannot mix set values and value maps")
                return DictSuffixRule(s[0]).parse(t[1:])
            if lexeme == "for":
                self.expect("set comprehension", len(s) == 1, t[0],
                    "can have only one expression")
                return SetComprehensionRule(s[0]).parse(t)
            if lexeme == "..":
                self.expect("range", len(s) == 1, t[0],
                    "can have only two expressions")
                token = t[0]
                (ast, t) = NaryRule({"}"}).parse(t[1:])
                return (RangeAST(next, ast, token), t[1:])
            if lexeme == "}":
                return (SetAST(s), t[1:])
            self.expect("set expression", lexeme == ",", t[0],
                    "expected a comma")

class BagRule(Rule):
    def parse(self, t):
        (lexeme, file, line, column) = t[0]
        self.expect("bag expression", lexeme == "bag{", t[0], "expected '{'")
        (lexeme, file, line, column) = t[1]
        if lexeme == "}":
            return (BagAST([]), t[2:])
        s = []
        while True:
            (next, t) = NaryRule({"for", "..", ",", "}"}).parse(t[1:])
            if next == False:
                return (next, t)
            s.append(next)
            (lexeme, file, line, column) = t[0]
            if lexeme == "for":
                self.expect("bag comprehension", len(s) == 1, t[0],
                    "can have only one expression")
                return BagComprehensionRule(s[0]).parse(t)
            if lexeme == "..":
                self.expect("range", len(s) == 1, t[0],
                    "can have only two expressions")
                token = t[0]
                (ast, t) = NaryRule({"}"}).parse(t[1:])
                return (RangeAST(next, ast, token), t[1:])
            if lexeme == "}":
                return (BagAST(s), t[1:])
            self.expect("bag expression", lexeme == ",", t[0],
                    "expected a comma")

class DictSuffixRule(Rule):
    def __init__(self, first):
        self.first = first

    def parse(self, t):
        key = self.first
        d = []
        while True:
            (value, t) = NaryRule({",", "}", "for"}).parse(t)
            (lexeme, file, line, column) = t[0]
            self.expect("dict expression", lexeme in { ",", "}", "for" }, t[0],
                                    "expected a comma or '}'")
            if lexeme == "for":
                self.expect("dict comprehension", d == [], t[0],
                    "expected single expression")
                return DictComprehensionRule(key, value).parse(t)

            d.append((key, value))
            if lexeme == "}":
                return (DictAST(d), t[1:])

            (key, t) = NaryRule({":"}).parse(t[1:])
            if key == False:
                return (key, t)
            (lexeme, file, line, column) = t[0]
            self.expect("dict expression", lexeme == ":", t[0],
                                        "expected a colon")
            t = t[1:]

class TupleRule(Rule):
    def __init__(self, closers):
        self.closers = closers

    def parse(self, t):
        (lexeme, file, line, column) = t[0]
        if lexeme in self.closers:
            return (ConstantAST(
                (novalue, file, line, column)), t)
        (ast, t) = NaryRule(self.closers.union({",", "for"})).parse(t)
        if not ast or t == []:
            return (ast, t)
        (lexeme, file, line, column) = token = t[0]
        if lexeme in self.closers:
            return (ast, t)
        if lexeme == "for":
            return ListComprehensionRule(ast, self.closers).parse(t)
        d = [ ast ]
        while lexeme == ",":
            (lexeme, file, line, column) = t[1]
            if lexeme in self.closers:
                return (TupleAST(d, token), t[1:])
            (next, t) = NaryRule(self.closers.union({ "," })).parse(t[1:])
            d.append(next)
            if t == []:
                break
            (lexeme, file, line, column) = token = t[0]
        if t != []:
            self.expect("tuple expression", lexeme in self.closers, t[0],
                "expected %s"%self.closers)
        return (TupleAST(d, token), t)

class BasicExpressionRule(Rule):
    def parse(self, t):
        (lexeme, file, line, column) = token = t[0]
        if isnumber(lexeme):
            return (ConstantAST((int(lexeme), file, line, column)), t[1:])
        if lexeme == "False":
            return (ConstantAST((False, file, line, column)), t[1:])
        if lexeme == "True":
            return (ConstantAST((True, file, line, column)), t[1:])
        if lexeme == "None":
            return (ConstantAST((AddressValue([]), file, line, column)), t[1:])
        if lexeme == "inf":
            return (ConstantAST((math.inf, file, line, column)), t[1:])
        if lexeme[0] == '"':
            return (TupleAST([ ConstantAST((c, file, line, column))
                                for c in lexeme[1:] ], token), t[1:])
        if lexeme == ".": 
            (lexeme, file, line, column) = t[1]
            if lexeme.startswith("0x"):
                return (ConstantAST((chr(int(lexeme, 16)), file, line, column)), t[2:])
            else:
                self.expect("dot expression", isname(lexeme), t[1],
                    "expected a name after .")
                return (ConstantAST((lexeme, file, line, column)), t[2:])
        if isname(lexeme):
            return (NameAST(t[0]), t[1:])
        if lexeme == "{":
            return SetRule().parse(t)
        # if lexeme == "bag{":
        #     return BagRule().parse(t)
        if lexeme == "(" or lexeme == "[":
            closer = ")" if lexeme == "(" else "]"
            (ast, t) = TupleRule({closer}).parse(t[1:])
            return (ast, t[1:])
        if lexeme == "?":
            (ast, t) = ExpressionRule().parse(t[1:])
            return (AddressAST(ast), t)
        return (False, t)

class PointerAST(AST):
    def __init__(self, expr, token):
        self.expr = expr
        self.token = token

    def __repr__(self):
        return "PointerAST(" + str(self.expr) + ")"

    def compile(self, scope, code):
        self.expr.compile(scope, code)
        code.append(LoadOp(None, self.token, None))

    def ph1(self, scope, code):
        self.expr.compile(scope, code)

    def ph2(self, scope, code, skip):
        if skip > 0:
            code.append(MoveOp(skip + 2))
            code.append(MoveOp(2))
        code.append(StoreOp(None, self.token, None))

class ExpressionRule(Rule):
    def parse(self, t):
        func = t[0]
        (lexeme, file, line, column) = func
        if lexeme == "lambda":
            (bv, t) = BoundVarRule().parse(t[1:])
            (lexeme, file, line, column) = t[0]
            self.expect("lambda expression", lexeme == ":", t[0], "expected ':'")
            (ast, t) = NaryRule(["end"]).parse(t[1:])
            return (LambdaAST(bv, ast, func), t[1:])
        if lexeme == "setintlevel":
            (ast, t) = ExpressionRule().parse(t[1:])
            return (SetIntLevelAST(ast), t)
        if lexeme == "stop":
            (ast, t) = ExpressionRule().parse(t[1:])
            return (StopAST(ast), t)
        if isunaryop(lexeme):
            (ast, t) = ExpressionRule().parse(t[1:])
            if lexeme == "!":
                return (PointerAST(ast, func), t)
            else:
                return (NaryAST(func, [ast]), t)

        # Example:
        # a b c -> d e -> f
        # (a b c -> d e) -> f
        # ((a b c -> d) e) -> f
        # (((a b c) -> d) e) -> f
        # ((((a b) c) -> d) e) -> f
        (ast, t) = BasicExpressionRule().parse(t)
        while t != []:
            (lexeme, file, line, column) = t[0]
            if lexeme == "->":
                (lexeme, file, line, column) = t[1]
                self.expect("-> expression", isname(lexeme), t[1],
                        "expected a name after ->")
                ast = ApplyAST(PointerAST(ast, t[1]), ConstantAST(t[1]), t[1])
                t = t[2:]
                if t == []:
                    break
            else:
                (arg, t) = BasicExpressionRule().parse(t)
                if arg == False:
                    break
                ast = ApplyAST(ast, arg, func)
        return (ast, t)

class AssignmentAST(AST):
    def __init__(self, lhslist, rv, op):
        self.lhslist = lhslist      # a, b = c, d = e = ...
        self.rv = rv                # rhs expression
        self.op = op                # ... op= ...

    def __repr__(self):
        return "Assign(" + str(self.lhslist) + ", " + str(self.rv) + \
                            ", " + str(self.op) + ")"

    # handle an "x op= y" assignment
    def opassign(self, lv, scope, code):
        shared = lv.isShared(scope)
        if isinstance(lv, NameAST):
            # handled separately for assembly code readability
            (t, v) = scope.find(lv.name)
            if t == "module":
                print("Cannot operate on module", lv.name)
                sys.exit(1)
            if t == "constant":
                print("Cannot operate on constant", lv.name)
                sys.exit(1)
            assert t in { "local", "global" }
            ld = LoadOp(lv.name, lv.name, scope.prefix) if t == "global" else LoadVarOp(lv.name)
        else:
            lv.ph1(scope, code)
            code.append(DupOp())                  # duplicate the address
            ld = LoadOp(None, self.op, None) if shared else LoadVarOp(None)
        code.append(ld)                       # load the value
        self.rv.compile(scope, code)          # compile the rhs
        (lexeme, file, line, column) = self.op
        code.append(NaryOp((lexeme[:-1], file, line, column), 2))
        if isinstance(lv, NameAST):
            st = StoreOp(lv.name, lv.name, scope.prefix) if shared else StoreVarOp(lv.name)
        else:
            st = StoreOp(None, self.op, None) if shared else StoreVarOp(None)
        code.append(st)

    def compile(self, scope, code):
        (lexeme, file, line, column) = self.op
        if lexeme != '=':
            assert len(self.lhslist) == 1, self.lhslist
            lv = self.lhslist[0]
            self.opassign(lv, scope, code)
            return

        # Compute the addresses of lhs expressions
        for lvs in self.lhslist:
            # handled separately for better assembly code readability
            if not isinstance(lvs, NameAST):
                lvs.ph1(scope, code)

        # Compute the right-hand side
        self.rv.compile(scope, code)

        # Make enough copies for each left-hand side
        for i in range(len(self.lhslist) - 1):
            code.append(DupOp())

        # Now assign to the left-hand side in reverse order
        skip = len(self.lhslist)
        for lvs in reversed(self.lhslist):
            skip -= 1
            if isinstance(lvs, NameAST):
                (t, v) = scope.find(lvs.name)
                if t == "module":
                    print("Cannot assign to module", lvs.name)
                    sys.exit(1)
                if t == "constant":
                    print("Cannot assign to constant", lvs.name)
                    sys.exit(1)
                assert t in { "local", "global" }, (t, lvs.name)
                st = StoreOp(lvs.name, lvs.name, scope.prefix) if t == "global" else StoreVarOp(lvs.name)
                code.append(st)
            else:
                lvs.ph2(scope, code, skip)

class DelAST(AST):
    def __init__(self, lv):
        self.lv = lv

    def __repr__(self):
        return "Del(" + str(self.lv) + ")"

    def compile(self, scope, code):
        self.lv.ph1(scope, code)
        shared = self.lv.isShared(scope)
        op = DelOp(None) if shared else DelVarOp(None)
        code.append(op)

class SetIntLevelAST(AST):
    def __init__(self, arg):
        self.arg = arg

    def __repr__(self):
        return "SetIntLevel " + str(self.arg)

    def compile(self, scope, code):
        self.arg.compile(scope, code)
        code.append(SetIntLevelOp())

class StopAST(AST):
    def __init__(self, lv):
        self.lv = lv

    def __repr__(self):
        return "Stop " + str(self.lv)

    def compile(self, scope, code):
        self.lv.ph1(scope, code)
        code.append(StopOp(None))
        code.append(ContinueOp())

class AddressAST(AST):
    def __init__(self, lv):
        self.lv = lv

    def __repr__(self):
        return "Address(" + str(self.lv) + ")"

    def isConstant(self, scope):
        return self.lv.isConstant(scope)

    def check(self, lv, scope):
        if isinstance(lv, NameAST):
            (t, v) = scope.lookup(lv.name)
            if t == "local":
                print("can't take address of local variable", lv)
                sys.exit(1)
            if t == "constant":
                print("can't take address of constant", lv)
                sys.exit(1)
            if t == "module":
                print("can't take address of imported", lv)
                sys.exit(1)
        elif isinstance(lv, ApplyAST):
            self.check(lv.method, scope)
        elif isinstance(lv, PointerAST):
            pass
        else:
            print("can't take address of", lv)
            sys.exit(1)

    def gencode(self, scope, code):
        self.check(self.lv, scope)
        self.lv.ph1(scope, code)

class PassAST(AST):
    def __repr__(self):
        return "Pass"

    def compile(self, scope, code):
        pass

class BlockAST(AST):
    def __init__(self, b):
        assert len(b) > 0
        self.b = b

    def __repr__(self):
        return "Block(" + str(self.b) + ")"

    def compile(self, scope, code):
        for s in self.b:
            s.compile(scope, code)

    def getLabels(self):
        labels = [ x.getLabels() for x in self.b ]
        return functools.reduce(lambda x,y: x|y, labels)

    def getImports(self):
        imports = [ x.getImports() for x in self.b ]
        return functools.reduce(lambda x,y: x+y, imports)

class IfAST(AST):
    def __init__(self, alts, stat):
        self.alts = alts        # alternatives
        self.stat = stat        # else statement

    def __repr__(self):
        return "If(" + str(self.alts) + ", " + str(self.what) + ")"

    def compile(self, scope, code):
        jumps = []
        for alt in self.alts:
            (rest, stat) = alt
            negate = isinstance(rest, NaryAST) and rest.op[0] == "not"
            cond = rest.args[0] if negate else rest
            cond.compile(scope, code)
            pc = len(code)
            code.append(None)
            stat.compile(scope, code)
            jumps += [len(code)]
            code.append(None)
            code[pc] = JumpCondOp(negate, len(code))
        if self.stat != None:
            self.stat.compile(scope, code)
        for pc in jumps:
            code[pc] = JumpOp(len(code))

    def getLabels(self):
        labels = [ x.getLabels() for (c, x) in self.alts ]
        if self.stat != None:
            labels += [ self.stat.getLabels() ]
        return functools.reduce(lambda x,y: x|y, labels)

    def getImports(self):
        imports = [ x.getImports() for (c, x) in self.alts ]
        if self.stat != None:
            imports += [ self.stat.getImports() ]
        return functools.reduce(lambda x,y: x+y, imports)

class WhileAST(AST):
    def __init__(self, cond, stat):
        self.cond = cond
        self.stat = stat

    def __repr__(self):
        return "While(" + str(self.cond) + ", " + str(self.stat) + ")"

    def compile(self, scope, code):
        negate = isinstance(self.cond, NaryAST) and self.cond.op[0] == "not"
        cond = self.cond.args[0] if negate else self.cond
        pc1 = len(code)
        cond.compile(scope, code)
        pc2 = len(code)
        code.append(None)
        self.stat.compile(scope, code)
        code.append(JumpOp(pc1))
        code[pc2] = JumpCondOp(negate, len(code))

    def getLabels(self):
        return self.stat.getLabels()

    def getImports(self):
        return self.stat.getImports()

class AwaitAST(AST):
    def __init__(self, cond):
        self.cond = cond

    def __repr__(self):
        return "Await(" + str(self.cond) + ")"

    def compile(self, scope, code):
        negate = isinstance(self.cond, NaryAST) and self.cond.op[0] == "not"
        cond = self.cond.args[0] if negate else self.cond
        pc1 = len(code)
        cond.compile(scope, code)
        code.append(JumpCondOp(negate, pc1))

class InvariantAST(AST):
    def __init__(self, cond, token):
        self.cond = cond
        self.token = token

    def __repr__(self):
        return "Invariant(" + str(self.cond) + ")"

    def compile(self, scope, code):
        pc = len(code)
        code.append(None)
        self.cond.compile(scope, code)
        code[pc] = InvariantOp(len(code) - pc, self.token);
        code.append(ReturnOp())

class LetAST(AST):
    def __init__(self, vars, stat):
        self.vars = vars
        self.stat = stat

    def __repr__(self):
        return "Let(" + str(self.vars) + ", " + str(self.stat) + ")"

    def compile(self, scope, code):
        for (var, expr) in self.vars:
            expr.compile(scope, code)
            code.append(StoreVarOp(var))
            self.assign(scope, var)

        # Run the body
        self.stat.compile(scope, code)

        # Restore the old variable state
        for (var, expr) in self.vars:
            self.delete(scope, code, var)

class ForAST(AST):
    def __init__(self, iter, stat, token):
        self.value = stat
        self.iter = iter
        self.token = token

    def __repr__(self):
        return "For(" + str(self.iter) + ", " + str(self.stat) + ")"

    def compile(self, scope, code):
        self.comprehension(scope, code, "for")

    def getLabels(self):
        return self.value.getLabels()

    def getImports(self):
        return self.value.getImports()

class AtomicAST(AST):
    def __init__(self, stat):
        self.stat = stat

    def __repr__(self):
        return "Atomic(" + str(self.stat) + ")"

    def compile(self, scope, code):
        code.append(AtomicIncOp())
        self.stat.compile(scope, code)
        code.append(AtomicDecOp())

    # TODO.  Is it ok to define labels within an atomic block?
    def getLabels(self):
        return self.stat.getLabels()

    def getImports(self):
        return self.stat.getImports()

class AssertAST(AST):
    def __init__(self, token, cond, expr):
        self.token = token
        self.cond = cond
        self.expr = expr

    def __repr__(self):
        return "Assert(" + str(self.token) + str(self.cond) + ", " + str(self.expr) + ")"

    def compile(self, scope, code):
        code.append(ReadonlyIncOp())
        code.append(AtomicIncOp())
        self.cond.compile(scope, code)
        if self.expr != None:
            self.expr.compile(scope, code)
        code.append(AssertOp(self.token, self.expr != None))
        code.append(AtomicDecOp())
        code.append(ReadonlyDecOp())

class MethodAST(AST):
    def __init__(self, name, args, stat):
        self.name = name
        self.args = args
        self.stat = stat

    def __repr__(self):
        return "Method(" + str(self.name) + ", " + str(self.args) + ", " + str(self.stat) + ")"

    def compile(self, scope, code):
        pc = len(code)
        code.append(None)       # going to plug in a Jump op here
        code.append(FrameOp(self.name, self.args))
        (lexeme, file, line, column) = self.name
        scope.names[lexeme] = ("constant", (PcValue(pc + 1), file, line, column))

        ns = Scope(scope)
        tmp = PcValue(-1)
        for (lexeme, file, line, column) in self.stat.getLabels():
            ns.names[lexeme] = ("constant", (tmp, file, line, column))
        self.assign(ns, self.args)
        ns.names["result"] = ("local", ("result", file, line, column))
        before = len(code)
        self.stat.compile(ns, code)
        del code[before:]
        self.stat.compile(ns, code)
        code.append(ReturnOp())
        code[pc] = JumpOp(len(code))

        # promote global variables
        for name, (t, v) in ns.names.items():
            if t == "global" and name not in scope.names:
                scope.names[name] = (t, v)

    def getLabels(self):
        return { self.name }

    def getImports(self):
        return self.stat.getImports()

class LambdaAST(AST):
    def __init__(self, args, stat, token):
        self.args = args
        self.stat = stat
        self.token = token

    def __repr__(self):
        return "Lambda " + str(self.args) + ", " + str(self.stat) + ")"

    def isConstant(self, scope):
        return True

    def compile_body(self, scope, code):
        pc = len(code)
        code.append(None)       # going to plug in a Jump op here
        code.append(FrameOp(self.token, self.args))

        (lexeme, file, line, column) = self.token
        ns = Scope(scope)
        self.assign(ns, self.args)
        R = ("result", file, line, column)
        ns.names["result"] = ("local", R)
        self.stat.compile(ns, code)
        code.append(StoreVarOp(R))
        code.append(ReturnOp())
        code[pc] = JumpOp(len(code))
        return pc + 1

    def compile(self, scope, code):
        pc = self.compile_body(scope, code)
        (lexeme, file, line, column) = self.token
        code.append(PushOp((PcValue(pc), file, line, column)))

class CallAST(AST):
    def __init__(self, expr):
        self.expr = expr

    def __repr__(self):
        return "Call(" + str(self.expr) + ")"

    def compile(self, scope, code):
        if not self.expr.isConstant(scope):
            self.expr.compile(scope, code)
            code.append(PopOp())

class SpawnAST(AST):
    def __init__(self, method, arg, this):
        self.method = method
        self.arg = arg
        self.this = this

    def __repr__(self):
        return "Spawn(" + str(self.method) + ", " + str(self.arg) + ", "  + str(self.this) + ")"

    def compile(self, scope, code):
        if self.this == None:
            code.append(PushOp((novalue, None, None, None)))
        else:
            self.this.compile(scope, code)
        self.arg.compile(scope, code)
        self.method.compile(scope, code)
        code.append(SpawnOp())

class TrapAST(AST):
    def __init__(self, method, arg):
        self.method = method
        self.arg = arg

    def __repr__(self):
        return "Trap(" + str(self.method) + ", " + str(self.arg) + ")"

    def compile(self, scope, code):
        self.arg.compile(scope, code)
        self.method.compile(scope, code)
        code.append(TrapOp())

class GoAST(AST):
    def __init__(self, ctx, result):
        self.ctx = ctx
        self.result = result

    def __repr__(self):
        return "Spawn(" + str(self.tag) + ", " + str(self.ctx) + ", " + str(self.result) + ")"

    def compile(self, scope, code):
        self.result.compile(scope, code)
        self.ctx.compile(scope, code)
        code.append(GoOp())

class ImportAST(AST):
    def __init__(self, modlist):
        self.modlist = modlist

    def __repr__(self):
        return "Import(" + str(self.modlist) + ")"

    def compile(self, scope, code):
        for module in self.modlist:
            self.doImport(scope, code, module)

    def getImports(self):
        return self.modlist

class FromAST(AST):
    def __init__(self, module, items):
        self.module = module
        self.items = items

    def __repr__(self):
        return "FromImport(" + str(self.module) + ", " + str(self.items) + ")"

    def compile(self, scope, code):
        self.doImport(scope, code, self.module)
        (lexeme, file, line, column) = self.module
        names = imported[lexeme].names
        # TODO.  Check for overlap, existence, etc.
        if self.items == []:  # from module import *
            for (item, (t, v)) in names.items():
                if t == "constant":
                    scope.names[item] = (t, v)
        else:
            for (lexeme, file, line, column) in self.items:
                if lexeme not in names:
                    print("%s line %d: can't import %s from module %s"%(
                        file, line, lexeme, self.module[0]))
                    sys.exit(1)
                (t, v) = names[lexeme]
                assert t == "constant", (lexeme, t, v)
                scope.names[lexeme] = (t, v)

    def getImports(self):
        return [self.module]

class LabelStatAST(AST):
    def __init__(self, labels, ast, file, line):
        self.labels = labels
        self.ast = ast
        self.file = file
        self.line = line

    def __repr__(self):
        return "LabelStat(" + str(self.labels) + ", " + str(self.ast) + ")"

    def compile(self, scope, code):
        scope.location(len(code), self.file, self.line, self.labels)
        if self.labels == []:
            self.ast.compile(scope, code)
        else:
            root = scope
            # while root.parent != None:
            #     root = root.parent
            for (lexeme, file, line, column) in self.labels:
                root.names[lexeme] = \
                    ("constant", (PcValue(len(code)), file, line, column))
            code.append(AtomicIncOp())
            self.ast.compile(scope, code)
            code.append(AtomicDecOp())

    def getLabels(self):
        return set(self.labels) | self.ast.getLabels();

    def getImports(self):
        return self.ast.getImports();

class SequentialAST(AST):
    def __init__(self, vars):
        self.vars = vars
    
    def __repr__(self):
        return "Sequential(" + str(self.vars) + ")"

    def compile(self, scope, code):
        for lv in self.vars:
            lv.ph1(scope, code)
            code.append(SequentialOp())

class ConstAST(AST):
    def __init__(self, const, expr):
        self.const = const
        self.expr = expr

    def __repr__(self):
        return "Const(" + str(self.const) + ", " + str(self.expr) + ")"

    def set(self, scope, const, v):
        if isinstance(const, tuple):
            (lexeme, file, line, column) = const
            if lexeme in constants:
                value = constants[lexeme]
            else:
                value = v
            scope.names[lexeme] = ("constant", (value, file, line, column))
        else:
            assert isinstance(const, list), const
            assert isinstance(v, DictValue), v
            assert len(const) == len(v.d), (const, v)
            for i in range(len(const)):
                self.set(scope, const[i], v.d[i])

    def compile(self, scope, code):
        if not self.expr.isConstant(scope):
            print(self.const, ": Parse error: expression not a constant", str(self.expr))
            sys.exit(1)
        if isinstance(self.expr, LambdaAST):
            pc = self.expr.compile_body(scope, code)
            self.set(scope, self.const, PcValue(pc))
        else:
            code2 = []
            self.expr.compile(scope, code2)
            state = State(code2, scope.labels)
            ctx = ContextValue(("__const__", None, None, None), 0, novalue, novalue)
            ctx.atomic = 1
            while ctx.pc != len(code2):
                code2[ctx.pc].eval(state, ctx)
            v = ctx.pop()
            self.set(scope, self.const, v)

class AssignmentRule(Rule):
    def __init__(self, lhslist, op):
        self.lhslist = lhslist
        self.op = op

    def parse(self, t):
        (ast, t) = TupleRule({";"}).parse(t)
        return (AssignmentAST(self.lhslist, ast, self.op), t)

# Zero or more labels, then a statement, then a semicolon
class LabelStatRule(Rule):
    def parse(self, t):
        (lexeme, thefile, theline, column) = t[0]
        labels = []
        while True:
            (lexeme, file, line, column) = t[0]
            if lexeme != "@":
                break
            label = t[1]
            (lexeme, file, line, column) = label
            self.expect("label", isname(lexeme), t[1], "expected name after @")
            labels.append(label)
            (lexeme, file, line, column) = t[2]
            self.expect("label", lexeme == ":", t[2], "expected ':' after label")
            t = t[3:]

        (ast, t) = StatementRule().parse(t)
        return (LabelStatAST(labels, ast, thefile, theline), t)

class StatListRule(Rule):
    def __init__(self, indent):
        self.indent = indent

    def parse(self, t):
        if t == []:
            print("Unexpected EOF")
            return (BlockAST([]), [])

        # find all the tokens that are indented more than self.indent
        slice = []
        (lexeme, file, line, column) = t[0]
        while column > self.indent:
            slice.append(t[0])
            t = t[1:]
            if t == []:
                break
            (lexeme, file, line, column) = t[0]
        if slice == []:
            print("Parse error: no statements in indented block:", t[0])
            sys.exit(1)

        b = []
        while slice != []:
            try:
                (ast, slice) = LabelStatRule().parse(slice)
                b.append(ast)
            except IndexError:
                print("Parsing: incomplete statement starting at ", slice[0])
                sys.exit(1)

        return (BlockAST(b), t)

class BlockRule(Rule):
    def __init__(self, indent):
        self.indent = indent

    def parse(self, t):
        (lexeme, file, line, column) = t[0]
        self.expect("block statement", lexeme == ":", t[0], "missing ':'")
        return StatListRule(self.indent).parse(t[1:])

# This parses the lefthand side of an assignment in a let expression.  Grammar:
#   lhs = (tuple ",")* [tuple]
#   tuple = name | "(" lhs ")"
# TODO: also use this for def arguments and for
class BoundVarRule(Rule):
    def parse(self, t):
        tuples = []
        while True:
            (lexeme, file, line, column) = t[0]
            if (isname(lexeme)):
                tuples.append(t[0])
            elif lexeme == "(":
                (nest, t) = BoundVarRule().parse(t[1:])
                (lexeme, file, line, column) = t[0]
                self.expect("let statement", lexeme == ")", t[0], "expected ')'")
                tuples.append(nest)
            elif lexeme == "[":
                (nest, t) = BoundVarRule().parse(t[1:])
                (lexeme, file, line, column) = t[0]
                self.expect("let statement", lexeme == "]", t[0], "expected ']'")
                tuples.append(nest)
            else:
                return (tuples, t)
            (lexeme, file, line, column) = t[1]
            if lexeme != ",":
                if len(tuples) == 1:
                    return (tuples[0], t[1:])
                else:
                    return (tuples, t[1:])
            t = t[2:]

class StatementRule(Rule):
    def rec_slice(self, t):
        (lexeme, file, line, column) = first = t[0]
        if lexeme == '(':
            bracket = ')'
        elif lexeme == '[':
            bracket = ']'
        else:
            assert lexeme == '{'
            bracket = '}'
        t = t[1:]
        tokens = []
        while t != []:
            tokens.append(t[0])
            (lexeme, file, line, column) = t[0]
            if lexeme == bracket:
                return (tokens, t[1:])
            if lexeme in [')', ']', '}']:
                print("unmatched bracket:", t[0])
                sys.exit(1)
            if lexeme in ['(', '[', '{']:
                (more, t) = self.rec_slice(t)
                tokens += more
                if t == []:
                    break
            else:
                t = t[1:]
        print("closing bracket missing:", first, tokens, t)
        sys.exit(1)

    def slice(self, t, indent):
        if t == []:
            return ([], [])
        tokens = []
        (lexeme, file, line, column) = t[0]
        if lexeme in ['(', '[', '{']:
            tokens.append(t[0])
            (more, t) = self.rec_slice(t)
            tokens += more
            if t == []:
                return (tokens, [])
            (lexeme, file, line, column) = t[0]
        while column > indent and lexeme != ";":
            tokens.append(t[0])
            t = t[1:]
            if t == []:
                break
            (lexeme, file, line, column) = t[0]
            if lexeme in ['(', '[', '{']:
                tokens.append(t[0])
                (more, t) = self.rec_slice(t)
                tokens += more
                if t == []:
                    break
                (lexeme, file, line, column) = t[0]
        return (tokens, t)

    def parse(self, t):
        token = t[0]
        (lexeme, file, line, column) = token
        if lexeme == ";":
            return (PassAST(), t[1:])
        if lexeme == "const":
            (tokens, t) = self.slice(t[1:], column)
            (const, tokens) = BoundVarRule().parse(tokens)
            (lexeme, file, line, column) = tokens[0]
            self.expect("constant definition", lexeme == "=", tokens[0], "expected '='")
            (ast, tokens) = TupleRule(set()).parse(tokens[1:])
            if tokens != []:
                print("constant definition: unexpected token:", tokens[0])
                sys.exit(1)
            return (ConstAST(const, ast), t)
        if lexeme == "if":
            alts = []
            while True:
                (cond, t) = NaryRule({":"}).parse(t[1:])
                (stat, t) = StatListRule(column).parse(t[1:])
                alts += [(cond, stat)]
                if t == []:
                    nextColumn = column
                    break
                (lexeme, file, line, nextColumn) = t[0]
                assert nextColumn <= column
                if nextColumn < column:
                    break
                if lexeme != "elif":
                    break
            if nextColumn == column and lexeme == "else":
                (stat, t) = BlockRule(column).parse(t[1:])
            else:
                stat = None
            return (IfAST(alts, stat), t)
        if lexeme == "while":
            (cond, t) = NaryRule({":"}).parse(t[1:])
            (stat, t) = StatListRule(column).parse(t[1:])
            return (WhileAST(cond, stat), t)
        if lexeme == "await":
            (tokens, t) = self.slice(t[1:], column)
            (cond, tokens) = NaryRule(set()).parse(tokens)
            if tokens != []:
                print("await: unexpected token:", tokens[0])
                sys.exit(1)
            return (AwaitAST(cond), t)
        if lexeme == "invariant":
            (tokens, t) = self.slice(t[1:], column)
            (cond, tokens) = NaryRule(set()).parse(tokens)
            if tokens != []:
                print("invariant: unexpected token:", tokens[0])
                sys.exit(1)
            return (InvariantAST(cond, token), t)
        if lexeme == "for":
            (lst, t) = self.iterParse(t[1:], {":"})
            (stat, t) = StatListRule(column).parse(t[1:])
            return (ForAST(lst, stat, token), t)
        if lexeme == "let":
            vars = []
            while True:
                (bv, t) = BoundVarRule().parse(t[1:])
                (lexeme, file, line, nextColumn) = t[0]
                self.expect("let statement", lexeme == "=", t[0], "expected '='")
                (ast, t) = TupleRule({":", "let"}).parse(t[1:])
                vars.append((bv, ast))
                (lexeme, file, line, nextColumn) = t[0]
                if lexeme == ":":
                    break
                self.expect("let statement", lexeme == "let", t[0], "expected 'let' or ':'")
            (stat, t) = StatListRule(column).parse(t[1:])
            return (LetAST(vars, stat), t)
        if lexeme == "atomic":
            (stat, t) = BlockRule(column).parse(t[1:])
            return (AtomicAST(stat), t)
        if lexeme == "del":
            (tokens, t) = self.slice(t[1:], column)
            (ast, tokens) = ExpressionRule().parse(tokens)
            if tokens != []:
                print("del: unexpected token:", tokens[0])
                sys.exit(1)
            return (DelAST(ast), t)
        if lexeme == "def":
            name = t[1]
            (lexeme, file, line, nextColumn) = name
            self.expect("method definition", isname(lexeme), name, "expected name")
            (bv, t) = BoundVarRule().parse(t[2:])
            (stat, t) = BlockRule(column).parse(t)
            return (MethodAST(name, bv, stat), t)
        if lexeme == "spawn":
            (tokens, t) = self.slice(t[1:], column)
            (func, tokens) = NaryRule({","}).parse(tokens)
            if not isinstance(func, ApplyAST):
                print("spawn: expected method application", token)
                sys.exit(1)
            if tokens == []:
                this = None
            else:
                (lexeme, file, line, column) = tokens[0]
                assert lexeme == ","
                (this, tokens) = NaryRule(set()).parse(tokens[1:])
                if tokens != []:
                    print("spawn: unexpected token:", tokens[0])
                    sys.exit(1)
            return (SpawnAST(func.method, func.arg, this), t)
        if lexeme == "trap":
            (tokens, t) = self.slice(t[1:], column)
            (func, tokens) = NaryRule(set()).parse(tokens)
            if not isinstance(func, ApplyAST):
                print("trap: expected method application", token)
                sys.exit(1)
            if tokens != []:
                print("trap: unexpected token:", tokens[0])
                sys.exit(1)
            return (TrapAST(func.method, func.arg), t)
        if lexeme == "go":
            (tokens, t) = self.slice(t[1:], column)
            (func, tokens) = NaryRule(set()).parse(tokens)
            if not isinstance(func, ApplyAST):
                print("go: expected method application", token)
                sys.exit(1)
            if tokens != []:
                print("go: unexpected token:", tokens[0])
                sys.exit(1)
            return (GoAST(func.method, func.arg), t)
        if lexeme == "pass":
            return (PassAST(), t[1:])
        if lexeme == "sequential":
            (tokens, t) = self.slice(t[1:], column)
            (ast, tokens) = ExpressionRule().parse(tokens)
            vars = [ast]
            if tokens != []:
                (lexeme, file, line, column) = tokens[0]
                while lexeme == ',':
                    (ast, tokens) = ExpressionRule().parse(tokens[1:])
                    vars.append(ast)
                    if tokens == []:
                        break
                    (lexeme, file, line, column) = tokens[0]
                if tokens != []:
                    print("sequential: unexpected token:", tokens[0])
                    sys.exit(1)
            return (SequentialAST(vars), t)
        if lexeme == "import":
            (tokens, t) = self.slice(t[1:], column)
            mods = [tokens[0]]
            tokens = tokens[1:]
            if tokens != []:
                (lexeme, file, line, column) = tokens[0]
                while lexeme == ',':
                    mods.append(tokens[1])
                    tokens = tokens[2:]
                    if tokens == []:
                        break
                    (lexeme, file, line, column) = tokens[0]
                if tokens != []:
                    print("import: unexpected token:", tokens[0])
                    sys.exit(1)
            return (ImportAST(mods), t)
        if lexeme == "from":
            (tokens, t) = self.slice(t[1:], column)
            (lexeme, file, line, column) = module = tokens[0]
            self.expect("from statement", isname(lexeme), module, "expected module name")
            (lexeme, file, line, column) = tokens[1]
            self.expect("from statement", lexeme == "import", tokens[1], "expected 'import'")
            (lexeme, file, line, column) = tokens[2]
            if lexeme == '*':
                assert len(tokens) == 3, tokens
                return (FromAST(module, []), t)
            items = [tokens[2]]
            tokens = tokens[3:]
            if tokens != []:
                (lexeme, file, line, column) = tokens[0]
                while lexeme == ',':
                    items.append(tokens[1])
                    tokens = tokens[2:]
                    if tokens == []:
                        break;
                    (lexeme, file, line, column) = tokens[0]
            if tokens != []:
                print("from: unexpected token:", tokens[0])
                sys.exit(1)
            return (FromAST(module, items), t)
        if lexeme == "assert":
            (tokens, t) = self.slice(t[1:], column)
            (cond, tokens) = NaryRule({","}).parse(tokens)
            if tokens == []:
                expr = None
            else:
                (lexeme, file, line, column) = tokens[0]
                assert lexeme == ","
                (expr, tokens) = NaryRule(set()).parse(tokens[1:])
                if tokens != []:
                    print("assert: unexpected token:", tokens[0])
                    sys.exit(1)
            return (AssertAST(token, cond, expr), t)
        
        # If we get here, the next statement is either an expression
        # or an assignment.  The assignment grammar is either
        #   (tuple_expression '=')* tuple_expression
        # or
        #   tuple_expression 'op=' tuple_expression
        (lexeme, file, line, column) = t[0]
        if lexeme in ['(', '[', '{']:
            (tokens, t) = self.slice(t, column)
        else:
            (tokens, t) = self.slice(t[1:], column)
            tokens = [token] + tokens
        exprs = []
        assignop = None
        while tokens != []:
            tk = tokens[0]
            (ast, tokens) = TupleRule({ "=" } | assignops).parse(tokens)
            self.expect("statement", ast != False, tk, "expected expression")
            exprs.append(ast)
            if tokens == []:
                break
            (lexeme, file, line, column) = tokens[0]
            assert assignop == None or assignop[0] == "="
            assignop = tokens[0]
            tokens = tokens[1:]
        if len(exprs) == 1:
            return (CallAST(exprs[0]), t)
        else:
            return (AssignmentAST(exprs[:-1], exprs[-1], assignop), t)

class ContextValue(Value):
    def __init__(self, name, entry, arg, this):
        self.name = name
        self.entry = entry
        self.arg = arg
        self.pc = entry
        self.this = this
        self.atomic = 0
        self.readonly = 0
        self.interruptLevel = False
        self.stack = []     # collections.deque() seems slightly slower
        self.fp = 0         # frame pointer
        self.vars = novalue
        self.trap = None
        self.phase = "start"        # start, middle, or end
        self.stopped = False
        self.failure = None

    def __repr__(self):
        return "ContextValue(" + str(self.name) + ", " + str(self.arg) + ", " + str(self.this) + ")"

    def __str__(self):
        return self.__repr__()

    def nametag(self):
        if self.arg == novalue:
            return self.name[0] + "()"
        return self.name[0] + "(" + str(self.arg) + ")"

    def __hash__(self):
        h = (self.name, self.entry, self.arg, self.pc, self.this, self.atomic, self.readonly, self.interruptLevel, self.vars,
            self.trap, self.phase, self.stopped, self.failure).__hash__()
        for v in self.stack:
            h ^= v.__hash__()
        return h

    def __eq__(self, other):
        if not isinstance(other, ContextValue):
            return False
        if self.name != other.name:
            return False
        if self.entry != other.entry:
            return False
        if self.arg != other.arg:
            return False
        if self.pc != other.pc:
            return False
        if self.this != other.this:
            return False
        if self.atomic != other.atomic:
            return False
        if self.readonly != other.readonly:
            return False
        if self.interruptLevel != other.interruptLevel:
            return False
        if self.phase != other.phase:
            return False
        if self.stopped != other.stopped:
            return False
        if self.fp != other.fp:
            return False
        if self.trap != other.trap:
            return False
        if self.failure != other.failure:
            return False
        return self.stack == other.stack and self.vars == other.vars

    def copy(self):
        c = ContextValue(self.name, self.entry, self.arg, self.this)
        c.pc = self.pc
        c.atomic = self.atomic
        c.readonly = self.readonly
        c.interruptLevel = self.interruptLevel
        c.stack = self.stack.copy()
        c.fp = self.fp
        c.trap = self.trap
        c.vars = self.vars
        c.phase = self.phase
        c.stopped = self.stopped
        c.failure = self.failure
        return c

    def get(self, var):
        return self.this if var == "this" else self.vars.d[var]

    def iget(self, indexes):
        assert indexes[0] != "this"
        v = self.vars
        while indexes != []:
            v = v.d[indexes[0]]
            indexes = indexes[1:]
        return v

    def update(self, record, indexes, val):
        if len(indexes) > 1:
            v = self.update(record.d[indexes[0]], indexes[1:], val)
        else:
            v = val
        d = record.d.copy()
        d[indexes[0]] = v
        return DictValue(d)

    def doDelete(self, record, indexes):
        if len(indexes) > 1:
            d = record.d.copy()
            d[indexes[0]] = self.doDelete(record.d[indexes[0]], indexes[1:])
        else:
            d = record.d.copy()
            if indexes[0] in d:
                del d[indexes[0]]
        return DictValue(d)

    def set(self, indexes, val):
        if indexes[0] == "this":
            if len(indexes) == 1:
                self.this = val
            else:
                self.this = self.update(self.this, indexes[1:], val)
        else:
            self.vars = self.update(self.vars, indexes, val)

    def delete(self, indexes):
        self.vars = self.doDelete(self.vars, indexes)

    def push(self, val):
        assert val != None
        self.stack.append(val)

    def pop(self):
        return self.stack.pop()

    def key(self):
        return (100, (self.pc, self.__hash__()))

class State:
    def __init__(self, code, labels):
        self.code = code
        self.labels = labels
        self.vars = novalue
        self.ctxbag = {}        # running contexts
        self.stopbag = {}       # stopped contexts
        self.termbag = {}       # terminated contexts
        self.choosing = None
        self.invariants = set()
        self.initializing = True

    def __repr__(self):
        return "State(" + str(self.vars) + ", " + str(self.ctxbag) + ", " + \
            str(self.stopbag) + ", " + str(self.invariants) + ")"

    def __hash__(self):
        h = self.vars.__hash__()
        for c in self.ctxbag.items():
            h ^= c.__hash__()
        for c in self.stopbag.items():
            h ^= c.__hash__()
        for c in self.termbag.items():
            h ^= c.__hash__()
        for i in self.invariants:
            h ^= i
        return h

    def __eq__(self, other):
        if not isinstance(other, State):
            return False
        assert self.code == other.code and self.labels == other.labels
        if self.vars != other.vars:
            return False
        if self.ctxbag != other.ctxbag:
            return False
        if self.stopbag != other.stopbag:
            return False
        if self.termbag != other.termbag:
            return False
        if self.choosing != other.choosing:
            return False
        if self.invariants != other.invariants:
            return False
        if self.initializing != self.initializing:
            return False
        return True

    def copy(self):
        s = State(self.code, self.labels)
        s.vars = self.vars      # no need to copy as store operations do it
        s.ctxbag = self.ctxbag.copy()
        s.stopbag = self.stopbag.copy()
        s.termbag = self.termbag.copy()
        s.choosing = self.choosing
        s.invariants = self.invariants.copy()
        s.initializing = self.initializing
        return s

    def get(self, var):
        return self.vars.d[var]

    def iget(self, indexes):
        path = indexes
        v = self.vars
        while indexes != []:
            try:
                v = v.d[indexes[0]]
            except KeyError:
                print()
                print("no index", indexes[0], "in variable", path)
                sys.exit(1)
            indexes = indexes[1:]
        return v

    def update(self, record, indexes, val):
        if len(indexes) > 1:
            v = self.update(record.d[indexes[0]], indexes[1:], val)
        else:
            v = val
        d = record.d.copy()
        d[indexes[0]] = v
        return DictValue(d)

    def doDelete(self, record, indexes):
        d = record.d.copy()
        if len(indexes) > 1:
            d[indexes[0]] = self.doDelete(record.d[indexes[0]], indexes[1:])
        else:
            del d[indexes[0]]
        return DictValue(d)

    def doStop(self, record, indexes, ctx):
        d = record.d.copy()
        if len(indexes) > 1:
            d[indexes[0]] = self.doStop(record.d[indexes[0]], indexes[1:], ctx)
        else:
            # TODO.  Should be print + set failure
            list = d[indexes[0]]
            assert(isinstance(list, DictValue))
            d2 = list.d.copy()
            d2[len(d2)] = ctx
            d[indexes[0]] = DictValue(d2)
        return DictValue(d)

    def set(self, indexes, val):
        self.vars = self.update(self.vars, indexes, val)

    def delete(self, indexes):
        self.vars = self.doDelete(self.vars, indexes)

    def stop(self, indexes, ctx):
        self.vars = self.doStop(self.vars, indexes, ctx)
        cnt = self.stopbag.get(ctx)
        if cnt == None:
            self.stopbag[ctx] = 1
        else:
            self.stopbag[ctx] = cnt + 1

class Node:
    def __init__(self, state, uid, parent, before, after, steps, len):
        self.state = state      # State associated with this node
        self.uid = uid          # index into 'nodes' array
        self.parent = parent    # next hop on way to initial state
        self.len = len          # length of path to initial state
        self.before = before    # the context that made the hop from the parent state
        self.after = after      # the resulting context
        self.steps = steps      # list of microsteps

        # if state.choosing, maps choice, else context
        self.edges = {}         # map to <nextNode, nextContext, steps>

        self.sources = set()    # backward edges
        self.expanded = False   # lazy deletion
        self.issues = set()     # set of problems with this state
        self.cid = 0            # strongly connected component id
        self.blocked = {}       # map of context -> boolean

    def __hash__(self):
        return self.uid

    def __eq__(self, other):
        return isinstance(other, Node) and other.uid == self.uid

    def rec_isblocked(self, ctx, vars, seen):
        if self.uid in seen:
            return True
        seen.add(self.uid)
        if ctx in self.blocked:
            return self.blocked[ctx]
        s = self.state
        if s.choosing == ctx:
            for (choice, next) in self.edges.items():
                (nn, nc, steps) = next
                ns = nn.state
                if ns.vars != vars or not nn.rec_isblocked(nc, vars, seen):
                    self.blocked[ctx] = False
                    return False
        elif ctx in self.edges:
            next = self.edges[ctx]
            (nn, nc, steps) = next
            ns = nn.state
            if ns.vars != vars or not nn.rec_isblocked(nc, vars, seen):
                self.blocked[ctx] = False
                return False
        else:
            self.blocked[ctx] = False
            return False
        self.blocked[ctx] = True
        return True

    # See if the given process is "blocked", i.e., it cannot change
    # the shared state (the state variables), terminate, or stop unless
    # some other process changes the shared state first
    def isblocked(self, ctx):
        return self.rec_isblocked(ctx, self.state.vars, set())

def strsteps(steps):
    if steps == None:
        return "[]"
    result = ""
    i = 0
    while i < len(steps):
        if result != "":
            result += ","
        (pc, choice) = steps[i]
        if pc == None:
            result += "Interrupt"
        else:
            result += str(pc)
        j = i + 1
        if choice != None:
            result += "(choose %s)"%strValue(choice)
        else:
            while j < len(steps):
                (pc2, choice2) = steps[j]
                if pc == None or pc2 != pc + 1 or choice2 != None:
                    break
                (pc, choice) = (pc2, choice2)
                j += 1
            if j > i + 1:
                result += "-%d"%pc
        i = j
    return "[" + result + "]"

def find_shortest(bad):
    best_node = None
    best_len = 0
    for node in bad:
        if best_node == None or node.len < best_len:
            best_node = node
            best_len = node.len
    return best_node

def varvisit(d, vars, name, r):
    if isinstance(d, dict):
        for k in sorted(d.keys()):
            if isinstance(k, str):
                nn = name + "." + k
            else:
                nn = name + "[" + strValue(k) + "]"
            if k in vars.d:
                varvisit(d[k], vars.d[k], nn, r)
            else:
                r.append("%s: ---"%nn)
    else:
        r.append("%s: %s"%(name, strValue(vars)))

def strvars(d, vars):
    r = [];
    for k in sorted(d.keys()):
        varvisit(d[k], vars.d[k], k, r)
    return "{ " + ", ".join(r) + " }"

def varmerge(d, vars):
    assert isinstance(d, dict)
    assert isinstance(vars, DictValue)
    for (k, v) in vars.d.items():
        if k in d and isinstance(d[k], dict) and isinstance(v, DictValue):
            varmerge(d[k], v)
        elif k not in d and isinstance(v, DictValue):
            d[k] = {}
            varmerge(d[k], v)
        elif k not in d:
            d[k] = {v}
        elif isinstance(d[k], set):
            d[k] |= {v}
        else:
            assert isinstance(d[k], dict)
            d[k] = { v }

def vartrim(d):
    pairs = list(d.items())
    for (k, v) in pairs:
        if v == {}:
            del d[k]
        elif isinstance(d[k], dict):
            vartrim(d[k])

def pathvars(path):
    d = {}
    for (fctx, ctx, steps, states, vars) in path:
        varmerge(d, vars)
    vartrim(d)
    return d

def print_path(bad_node):
    path = genpath(bad_node)
    d = pathvars(path)
    pids = []
    for (fctx, ctx, steps, states, vars) in path:
        try:
            pid = pids.index(fctx)
            pids[pid] = ctx
        except ValueError:
            pids.append(ctx)
            pid = len(pids) - 1
        print("T%d:"%pid, ctx.nametag(), strsteps(steps), ctx.pc, strvars(d, vars))
    if len(path) > 0:
        (fctx, ctx, steps, states, vars) = path[-1]
        if ctx.failure != None:
            print(">>>", ctx.failure)

class Scope:
    def __init__(self, parent):
        self.parent = parent               # parent scope
        self.names = { "this": ("local", ("this", "NOFILE", 0, 0)) }   # name to (type, x) map
        self.locations = {} if parent == None else parent.locations
        self.labels = {} if parent == None else parent.labels
        self.prefix = [] if parent == None else parent.prefix

    def copy(self):
        c = Scope(self.parent)
        c.names = self.names.copy()
        c.locations = self.locations.copy()
        c.labels = self.labels.copy()
        c.prefix = self.prefix.copy()
        return c

    def checkUnused(self, name):
        (lexeme, file, line, column) = name
        tv = self.names.get(lexeme)
        if tv != None:
            (t, v) = tv
            assert t != "variable", ("variable name in use", name, v)

    def lookup(self, name):
        (lexeme, file, line, column) = name
        tv = self.names.get(lexeme)
        if tv != None:
            return tv
        ancestor = self.parent
        while ancestor != None:
            tv = ancestor.names.get(lexeme)
            if tv != None:
                # (t, v) = tv
                # if t == "local":
                #    return None
                return tv
            ancestor = ancestor.parent
        # print("Warning: unknown name:", name, " (assuming global variable)")
        self.names[lexeme] = ("global", name)
        return ("global", lexeme)

    def find(self, name):
        (lexeme, file, line, column) = name
        tv = self.names.get(lexeme)
        if tv != None:
            return tv
        self.names[lexeme] = ("global", name)
        # print("Warning: unknown name:", name, " (find)")
        return ("global", lexeme)

    def location(self, pc, file, line, labels):
        if self.parent == None:
            self.locations[pc] = (file, line)
            for (label, file, line, column) in labels:
                self.labels[label] = pc
        else:
            self.parent.location(pc, file, line, labels)

def optjump(code, pc):
    while pc < len(code):
        op = code[pc]
        if not isinstance(op, JumpOp):
            break
        pc = op.pc
    return pc

def optimize(code):
    for i in range(len(code)):
        op = code[i]
        if isinstance(op, JumpOp):
            code[i] = JumpOp(optjump(code, op.pc))
        elif isinstance(op, JumpCondOp):
            code[i] = JumpCondOp(op.cond, optjump(code, op.pc))

def invcheck(state, inv):
    assert isinstance(state.code[inv], InvariantOp)
    op = state.code[inv]
    ctx = ContextValue(("__invariant__", None, None, None), 0, novalue, novalue)
    ctx.atomic = ctx.readonly = 1
    ctx.pc = inv + 1
    while ctx.pc != inv + op.cnt:
        old = ctx.pc
        state.code[ctx.pc].eval(state, ctx)
        assert ctx.pc != old, old
    assert len(ctx.stack) == 1;
    assert isinstance(ctx.stack[0], bool)
    return ctx.stack[0]

class Pad:
    def __init__(self, descr):
        self.descr = descr
        self.value = ""
        self.lastlen = 0
    
    def __repr__(self):
        return self.descr + " = " + self.value

    def pad(self, v):
        if len(v) < len(self.value):
            self.value = " " * (len(self.value) - len(v))
        else:
            self.value = ""
        self.value += v

p_ctx = Pad("ctx")
p_pc  = Pad("pc")
p_ns  = Pad("#states")
p_dia = Pad("diameter")
p_ql  = Pad("#queue")

# Have context ctx make one (macro) step in the given state
def onestep(node, ctx, choice, interrupt, nodes, visited, todo):
    assert ctx.failure == None, ctx.failure

    # Keep track of whether this is the same context as the parent context
    samectx = ctx == node.after

    # Copy the state before modifying it
    sc = node.state.copy()   # sc is "state copy"
    sc.choosing = None

    # Make a copy of the context before modifying it (cc is "context copy")
    cc = ctx.copy()

    # Copy the choice as well
    choice_copy = choice

    steps = []

    if interrupt:
        assert not cc.interruptLevel
        (method, arg) = ctx.trap
        cc.push(PcValue(cc.pc))
        cc.push("interrupt")
        cc.push(arg)
        cc.pc = method.pc
        cc.trap = None
        cc.interruptLevel = True
        steps.append((None, None))      # indicates an interrupt

    localStates = set() # used to detect infinite loops
    loopcnt = 0         # only check for infinite loops after a while
    while cc.phase != "end":
        # execute one microstep
        steps.append((cc.pc, choice_copy))

        # print status update
        global lasttime, silent
        if not silent and time.time() - lasttime > 0.3:
            p_ctx.pad(cc.nametag())
            p_pc.pad(str(cc.pc))
            p_ns.pad(str(len(visited)))
            p_dia.pad(str(node.len))
            p_ql.pad(str(len(todo)))
            print(p_ctx, p_pc, p_ns, p_dia, p_ql, len(localStates), end="\r")
            lasttime = time.time()

        # If the current instruction is a "choose" instruction,
        # make the specified choice
        if isinstance(sc.code[cc.pc], ChooseOp):
            assert choice_copy != None;
            cc.stack[-1] = choice_copy
            cc.pc += 1
            choice_copy = None
        else:
            assert choice_copy == None
            if type(sc.code[cc.pc]) in { LoadOp, StoreOp, AtomicIncOp }:
                assert cc.phase != "end"
                cc.phase = "middle"
            try:
                sc.code[cc.pc].eval(sc, cc)
            except Exception as e:
                traceback.print_exc()
                sys.exit(1)
                cc.failure = "Python assertion failed"

        if cc.failure != None or cc.stopped:
            break

        # See if this process is making a nondeterministic choice.
        # If so, we break out of the microstep loop.  However, only
        # this process is scheduled from this state.
        if isinstance(sc.code[cc.pc], ChooseOp):
            v = cc.stack[-1]
            if (not isinstance(v, SetValue)) or v.s == set():
                # TODO.  Need the location of the choose operation in the file
                cc.failure = "pc = " + str(cc.pc) + \
                    ": Error: choose can only be applied to non-empty sets"
                break

            # if there is only one choice, we can just keep on going
            if len(v.s) > 1:
                sc.choosing = cc
                break
            else:
                choice_copy = list(v.s)[0]

        # if we're about to access shared state, let other processes
        # go first assuming there are other processes and we're not
        # in "atomic" mode
        # TODO.  IS THIS CHECK RIGHT?
        if cc.phase != "start" and cc.atomic == 0 and type(sc.code[cc.pc]) in { LoadOp, StoreOp }: # TODO  and len(sc.ctxbag) > 1:
            break
        # TODO.  WHY NOT HAVE THE SAME CHECK HERE?
        if cc.phase != "start" and cc.atomic == 0 and type(sc.code[cc.pc]) in { AtomicIncOp }:
            break

        # ContinueOp always causes a break
        if isinstance(sc.code[cc.pc], ContinueOp):
            break

        # Detect infinite loops if there's a suspicion
        loopcnt += 1
        if loopcnt > 200:
            if (sc, cc) in localStates:
                cc.failure = "infinite loop"
                break
            localStates.add((sc.copy(), cc.copy()))

    # Remove original context from bag
    bag_remove(sc.ctxbag, ctx)

    # Put the resulting context into the bag unless it's done
    if cc.phase == "end":
        sc.initializing = False     # initializing ends when __init__ finishes
        bag_add(sc.termbag, cc)
    elif not cc.stopped:
        bag_add(sc.ctxbag, cc)

    length = node.len if samectx else (node.len + 1)
    next = visited.get(sc)
    if next == None:
        next = Node(sc, len(nodes), node, ctx, cc, steps, length)
        nodes.append(next)
        visited[sc] = next
        if samectx:
            todo.insert(0, next)
        else:
            todo.append(next)
    elif next.len > length:
        assert length == node.len and next.len == node.len + 1 and not next.expanded, (node.len, length, next.len, next.expanded)
        # assert not next.expanded, (node.len, length, next.len, next.expanded)
        next.len = length
        next.parent = node
        next.before = ctx
        next.after = cc
        next.steps = steps
        todo.insert(0, next)
    node.edges[choice if node.state.choosing else ctx] = (next, cc, steps)
    next.sources.add(node)
    if cc.failure != None:
        next.issues.add("Thread Failure")

def parseConstant(c, v):
    tokens = lexer(v, "<constant argument>")
    if tokens == []:
        print("Empty constant")
        sys.exit(1)
    try:
        (ast, rem) = ExpressionRule().parse(tokens)
    except IndexError:
        # best guess...
        print("Parsing constant", v, "hit end of string")
        sys.exit(1)
    scope = Scope(None)
    code = []
    ast.compile(scope, code)
    state = State(code, scope.labels)
    ctx = ContextValue(("__arg__", None, None, None), 0, novalue, novalue)
    ctx.atomic = 1
    while ctx.pc != len(code):
        code[ctx.pc].eval(state, ctx)
    constants[c] = ctx.pop()

def doCompile(filenames, consts, mods):
    for c in consts:
        try:
            i = c.index("=")
            parseConstant(c[0:i], c[i+1:])
        except IndexError:
            print("Usage: -c C=V to define a constant")
            sys.exit(1)

    global modules
    for m in mods:
        try:
            i = m.index("=")
            modules[m[0:i]] = m[i+1:]
        except IndexError:
            print("Usage: -m module=version to specify a module version")
            sys.exit(1)

    scope = Scope(None)
    code = [
        FrameOp(("__init__", None, None, None), [])
    ]
    if filenames == []:
        usage()
    else:
        for fname in filenames:
            try:
                with open(fname) as fd:
                    load(fd, fname, scope, code)
            except IOError:
                print("harmony: can't open", fname, file=sys.stderr)
                sys.exit(1)
    code.append(ReturnOp())     # to terminate "__init__" process
    optimize(code)
    return (code, scope)

def kosaraju1(nodes, stack):
    seen = set()
    for node in nodes:
        if node.uid in seen:
            continue
        seen.add(node.uid)
        S = [node]
        while S:
            u = S[-1]
            done = True
            for (nn, nc, steps) in u.edges.values():
                if nn.uid not in seen:
                    seen.add(nn.uid)
                    done = False
                    S.append(nn)
                    break
            if done:
                S.pop()
                stack.append(u)

def kosaraju2(nodes, node, seen, scc):
    stack2 = [node]
    while stack2 != []:
        node = stack2.pop()
        if node.uid in seen:
            continue
        seen.add(node.uid)
        node.cid = scc.cid
        scc.nodes.add(node)
        for nn in node.sources:
            if nn.uid not in seen:
                stack2.append(nn)

class SCC:
    def __init__(self, cid):
        self.cid = cid
        self.nodes = set()      # set of nodes in this component
        self.edges = set()      # edges to other components
        self.good = False

# Find strongly connected components using Kosaraju's algorithm
def find_scc(nodes):
    stack = []
    kosaraju1(nodes, stack)
    seen = set()
    components = []
    while stack != []:
        next = stack.pop()
        if next.uid not in seen:
            scc = SCC(len(components))
            components.append(scc)
            kosaraju2(nodes, next, seen, scc)
    return components

def run(code, labels, blockflag):
    state = State(code, labels)
    ctx = ContextValue(("__init__", None, None, None), 0, novalue, novalue)
    ctx.atomic = 1
    ctx.push("process")
    ctx.push(novalue)
    bag_add(state.ctxbag, ctx)
    node = Node(state, 0, None, None, None, [], 0)

    nodes = [node]

    # For traversing Kripke graph
    visited = { state: node }
    todo = collections.deque([node])
    bad = set()

    faultyState = False
    maxdiameter = 0
    while todo:
        node = todo.popleft()

        # check the invariants
        if len(node.issues) == 0 and node.state.choosing == None:
            for inv in node.state.invariants:
                if not invcheck(node.state, inv):
                    (lexeme, file, line, column) = code[inv].token
                    node.issues.add("Invariant file=%s line=%d failed"%(file, line))

        if len(node.issues) > 0:
            bad.add(node)
            faultyState = True
            break

        if node.expanded:
            continue
        node.expanded = True
        if node.len > maxdiameter:
            maxdiameter = node.len

        if node.state.choosing != None:
            ctx = node.state.choosing
            assert ctx in node.state.ctxbag, ctx
            choices = ctx.stack[-1]
            assert isinstance(choices, SetValue), choices
            assert len(choices.s) > 0
            for choice in choices.s:
                onestep(node, ctx, choice, False, nodes, visited, todo)
        else:
            for (ctx, _) in node.state.ctxbag.items():
                onestep(node, ctx, None, False, nodes, visited, todo)
                if ctx.trap != None and not ctx.interruptLevel:
                    onestep(node, ctx, None, True, nodes, visited, todo)

    if not silent:
        print("#states =", len(visited), "diameter =", maxdiameter,
                                " "*100 + "\b"*100)

    todump = set()

    # See if there has been a safety violation
    issues_found = False
    if len(bad) > 0:
        print("==== Safety violation ====")
        bad_node = find_shortest(bad)
        print_path(bad_node)
        todump.add(bad_node)
        for issue in bad_node.issues:
            print(issue)
        issues_found = True

    if not faultyState:
        # Determine the strongly connected components
        components = find_scc(nodes)
        if not silent:
            print("#components:", len(components))

        # Figure out which strongly connected components are "good".
        # These are non-sink components or components that have
        # a terminated state.
        bad = set()
        for (s, n) in visited.items():
            if len(s.ctxbag) == 0 and len(s.stopbag) == 0:
                assert len(n.edges) == 0
                components[n.cid].good = True
                if blockflag:
                    bad.add(n)
                    n.issues.add("Terminating State")
            else:
                # assert len(n.edges) != 0, n.edges         TODO
                for (nn, nc, steps) in n.edges.values():
                    if nn.cid != n.cid:
                        components[n.cid].edges.add(nn.cid)
                    if nn.cid != n.cid:
                        components[n.cid].good = True
                        break

        nbadc = sum(not scc.good for scc in components)
        if nbadc != 0:
            if not blockflag:
                print("#bad components:", nbadc)
            for n in nodes:
                if components[n.cid].good:
                    continue
                if blockflag:
                    # see if all processes are blocked or stopped
                    s = n.state
                    for ctx in s.ctxbag.keys():
                        assert isinstance(ctx, ContextValue)
                        if not n.isblocked(ctx):
                            n.issues.add("Non-terminating State")
                            bad.add(n)
                            break
                else:
                    n.issues.add("Non-terminating State")
                    bad.add(n)

        if len(bad) > 0:
            bad_node = find_shortest(bad)
            issues = ""
            for issue in bad_node.issues:
                if issues != "":
                    issues += ", "
                issues += issue
            print("====", issues, "===")
            print_path(bad_node)
            todump.add(bad_node)
            issues_found = True

            # See which processes are blocked
            assert not bad_node.state.choosing
            running = 0
            blocked = 0
            stopped = 0
            for ctx in bad_node.state.ctxbag.keys():
                assert isinstance(ctx, ContextValue)
                if bad_node.isblocked(ctx):
                    blocked += 1
                    print("blocked process:", ctx.nametag(), "pc =", ctx.pc)
                else:
                    running += 1
                    print("running process:", ctx.nametag(), "pc =", ctx.pc)
            for ctx in bad_node.state.stopbag.keys():
                print("stopped process:", ctx.nametag(), "pc =", ctx.pc)
                stopped += 1
            print("#blocked:", blocked, "#stopped:", stopped, "#running:", running)

    if not issues_found:
        print("no issues found")
        n = None
    else:
        n = find_shortest(todump)
    return (nodes, n)

def htmlstrsteps(steps):
    if steps == None:
        return "[]"
    result = ""
    i = 0
    while i < len(steps):
        if result != "":
            result += " "
        (pc, choice) = steps[i]
        j = i + 1
        if pc == None:
            result += "Interrupt"
        else:
            result += "<a href='#P%d'>%d"%(pc, pc)
        if choice != None:
            result += "</a>(choose %s)"%strValue(choice)
        else:
            while j < len(steps):
                (pc2, choice2) = steps[j]
                if pc == None or pc2 != pc + 1 or choice2 != None:
                    break
                (pc, choice) = (pc2, choice2)
                j += 1
            if j > i + 1:
                result += "-%d"%pc
            result += "</a>"
        i = j
    return result

def genpath(n):
    # Extract the path to node n
    path = []
    while n != None:
        if n.after == None:
            break
        path = [n] + path
        n = n.parent

    # Now compress the path, combining macrosteps by the same context
    path2 = []
    lastctx = firstctx = None
    laststeps = []
    laststates = []
    lastvars = DictValue({})
    for n in path:
        if firstctx == None:
            firstctx = n.before
        if lastctx == None or lastctx == n.before:
            laststeps += n.steps
            lastctx = n.after
            laststates.append(n.uid)
            lastvars = n.state.vars
            continue
        path2.append((firstctx, lastctx, laststeps, laststates, lastvars))
        firstctx = n.before
        lastctx = n.after
        laststeps = n.steps.copy()
        laststates = [n.uid]
        lastvars = n.state.vars
    path2.append((firstctx, lastctx, laststeps, laststates, lastvars))
    return path2

def vardim(d):
    totalwidth = 0
    maxheight = 0
    if isinstance(d, dict):
        for k in sorted(d.keys()):
            (w, h) = vardim(d[k])
            totalwidth += w
            if h + 1 > maxheight:
                maxheight = h + 1
    else:
        return (1, 0)
    return (totalwidth, maxheight)

def varhdr(d, name, nrows, f):
    q = queue.Queue()
    level = 0
    q.put((d, level))
    while not q.empty():
        (nd, nl) = q.get()
        if nl > level:
            print("</tr><tr>", file=f)
            level = nl
        if isinstance(nd, dict):
            for k in sorted(nd.keys()):
                (w,h) = vardim(nd[k])
                if h == 0:
                    print("<td align='center' style='font-style: italic' colspan=%d rowspan=%d>%s</td>"%(w,nrows-nl,k), file=f)
                else:
                    print("<td align='center' style='font-style: italic' colspan=%d>%s</td>"%(w,k), file=f)
                q.put((nd[k], nl+1))

def vardump_rec(d, vars, f):
    if isinstance(d, dict):
        for k in sorted(d.keys()):
            if vars != None and k in vars.d:
                vardump_rec(d[k], vars.d[k], f)
            else:
                vardump_rec(d[k], None, f)
    elif vars == None:
        print("<td></td>", file=f)
    else:
        print("<td align='center'>%s</td>"%strValue(vars), file=f)

def vardump(d, vars, f):
    for k in sorted(d.keys()):
        vardump_rec(d[k], vars.d[k], f)

def htmlpath(n, color, f):
    # Generate a label for the path table
    issues = n.issues
    if len(issues) == 0:
        issues = { "no issues" }
    label = ""
    for issue in issues:
        if label != "":
            label += ", "
        label += issue
    label = "Issue: " + label
    # keys = sorted(n.state.vars.d.keys(), key=keyValue)
    path = genpath(n)
    d = pathvars(path)
    (width, height) = vardim(d)
    print("<table id='issuestbl' border='1' width='100%%'><tr><th colspan='2' align='left' style='color: %s'>%s</th><th></th>"%(color, html.escape(label)), file=f)
    if width == 1:
        print("<th>Shared Variable</th>", file=f)
    else:
        print("<th colspan='%d'>Shared Variables</th>"%width, file=f)
    print("<col style='width:15%'>", file=f)
    print("<tr><th rowspan=%d>Process</th><th rowspan=%d>Steps</th><th rowspan=%d></th>"%(height, height, height), file=f)
    varhdr(d, "", height, f)
    print("</tr><tr><td></td></tr>", file=f)
    row = height + 1
    pids = []
    for (fctx, ctx, steps, states, vars) in path:
        row += 1
        if len(states) > 0:
            sid = states[-1]
        else:
            sid = n.uid
        try:
            pid = pids.index(fctx)
            pids[pid] = ctx
        except ValueError:
            pids.append(ctx)
            pid = len(pids) - 1
        print("<tr><td>T%d: <a href='javascript:rowshow(%d,%d)'>%s</a></td>"%(pid, row, sid, ctx.nametag()), file=f)
        print("<td>%s</td><td></td>"%htmlstrsteps(steps), file=f)
        vardump(d, vars, f)
        print("</tr>", file=f)
    print("</table>", file=f)
    return height

def htmlloc(code, scope, ctx, traceid, f):
    pc = ctx.pc
    fp = ctx.fp
    print("<table id='loc%d' border='1' width='100%%'>"%traceid, file=f)
    trace = []
    while True:
        trace += [(pc, fp)]
        if fp < 5:
            break
        pc = ctx.stack[fp - 5]
        assert isinstance(pc, PcValue)
        pc = pc.pc
        fp = ctx.stack[fp - 1]
    trace.reverse()
    row = 0
    for (pc, fp) in trace:
        if row == 0:
            print("<tr style='background-color: #A5FF33'>", file=f)
        else:
            print("<tr>", file=f)
        print("<td>", file=f)
        print("<a href='#P%d'>%d</a> "%(pc, pc), file=f)
        print("<a href='javascript:setrow(%d,%d)'>"%(traceid,row), file=f)
        origpc = pc
        while pc >= 0 and pc not in scope.locations:
            pc -= 1
        if pc in scope.locations:
            (file, line) = scope.locations[pc]
        else:
            (file, line) = ("NOFILE", 0)
        # TODO.  Should skip over nested methods
        while pc >= 0 and not isinstance(code[pc], FrameOp):
            pc -= 1
        if fp >= 3:
            arg = ctx.stack[fp-3]
            if arg == novalue:
                print("%s()"%(code[pc].name[0]), end="", file=f)
            else:
                print("%s(%s)"%(code[pc].name[0], strValue(arg)), end="", file=f)
        print("</a>:", file=f)
        lines = files.get(file)
        if lines != None and line <= len(lines):
            print(html.escape(lines[line - 1]), file=f)
        print("</td></tr>", file=f)
        row += 1

    if ctx.failure != None:
        print("<tr style='color: red'><td>%s</td></tr>"%ctx.failure, file=f)
    print("</table>", file=f)

def htmlvars(vars, id, row, f):
    assert(isinstance(vars, DictValue))
    display = "block" if row == 0 else "none"
    print("<div id='vars%d_%d' style='display:%s'>"%(traceid, row, display), file=f)
    if len(vars.d) > 0:
        print("<table>", file=f)
        for (key, value) in vars.d.items():
            print("<tr>", file=f)
            print("<td>%s = %s</td>"%(strValue(key)[1:], strValue(value)), file=f)
            print("</tr>", file=f)
        print("</table>", file=f)
    print("</div>", file=f)

# print the variables on the stack
def htmltrace(code, scope, ctx, traceid, f):
    pc = ctx.pc
    fp = ctx.fp
    trace = [ctx.vars]
    while True:
        if fp < 5:
            break
        trace.append(ctx.stack[fp - 2])
        fp = ctx.stack[fp - 1]
    trace.reverse()
    for i in range(len(trace)):
        htmlvars(trace[i], traceid, i, f)

traceid = 0

def htmlrow(ctx, bag, node, code, scope, f, verbose):
    global traceid
    traceid += 1

    print("<tr>", file=f)
    if bag[ctx] > 1:
        print("<td>%s [%d copies]</td>"%(ctx.nametag(), bag[ctx]), file=f)
    else:
        print("<td>%s</td>"%ctx.nametag(), file=f)
    if ctx.stopped:
        print("<td>stopped</td>", file=f)
    else:
        if node.state.choosing:
            print("<td>choosing</td>", file=f)
        else:
            if ctx in node.edges:
                if node.isblocked(ctx):
                    print("<td>blocked</td>", file=f)
                else:
                    print("<td>running</td>", file=f)
            else:
                print("<td>failed</td>", file=f)

    print("<td>", file=f)
    htmlloc(code, scope, ctx, traceid, f)
    print("</td>", file=f)

    # print variables
    print("<td>", file=f)
    htmltrace(code, scope, ctx, traceid, f)
    print("</td>", file=f)

    # print stack
    if verbose:
        print("<td>%d</td>"%ctx.fp, file=f)
        print("<td align='center'>", file=f)
        print("<table border='1'>", file=f)
        for v in ctx.stack:
            print("<tr><td align='center'>", file=f)
            if isinstance(v, PcValue):
                print("<a href='#P%d'>"%v.pc, file=f)
                print("%s"%strValue(v), file=f)
                print("</a>", file=f)
            else:
                print("%s"%strValue(v), file=f)
            print("</td></tr>", file=f)
        print("</table>", file=f)
        print("</td>", file=f)
        assert not s.choosing
        if ctx in n.edges:
            (nn, nc, steps) = n.edges[ctx]
            print("<td>%s</td>"%htmlstrsteps(steps), file=f)
            print("<td><a href='javascript:show(%d)'>"%nn.uid, file=f)
            print("%d</a></td>"%nn.uid, file=f)
        else:
            print("<td>no steps</td>", file=f)
            print("<td></td>", file=f)
    print("</tr>", file=f)

def htmlstate(f):
    print("<table border='1' width='90%'>", file=f)
    print("<col style='width:20%'>", file=f)
    print("<col style='width:80%'>", file=f)

    print("<tr><td>state id</td><td>%d</td></tr>"%n.uid, file=f)
    # if s.failure != None:
    #     print("<tr><td>status</td><td>failure</td></tr>", file=f)
    if s.initializing:
        print("<tr><td>status</td><td>initializing</td></tr>", file=f)
    elif len(s.ctxbag) == 0:
        if len(s.stopbag) == 0:
            print("<tr><td>status</td><td>terminal</td></tr>", file=f)
        else:
            print("<tr><td>status</td><td>stopped</td></tr>", file=f)
    else:
        print("<tr><td>status</td><td>normal</td></tr>", file=f)

    if verbose:
        print("<tr><td>from</td>", file=f)
        print("<td><table><tr>", file=f)
        for src in sorted(n.sources, key=lambda x: (x.len, x.uid)):
            print("<td><a href='javascript:show(%d)'>%d</td>"%(src.uid, src.uid), file=f)
        print("</tr></table></td></tr>", file=f)

    if s.choosing != None:
        print("<tr><td>choosing</td><td>%s</td></tr>"%s.choosing.nametag(), file=f)

    print("</table>", file=f)

def htmlnode(n, code, scope, f, verbose):
    print("<div id='div%d' style='display:none'>"%n.uid, file=f);
    print("<div class='container'>", file=f)

    print("<a name='N%d'/>"%n.uid, file=f)

    if verbose:
        print("<td>", file=f)
        height = htmlpath(n, "black", f)
        print("</td>", file=f)

    # if n.state.failure != None:
    #     print("<table border='1' style='color: red'><tr><td>Failure:</td>", file=f)
    #     print("<td>%s</td>"%n.state.failure, file=f)
    #     print("</tr></table>", file=f)

    print("<table border='1'>", file=f)
    print("<tr><th>Process</th><th>Status</th><th>Stack Trace</th><th>Variables</th>", file=f)
    if verbose:
        print("<th>FP</th><th>Stack</th>", file=f)
        print("<th>Steps</th><th>Next State</th></tr>", file=f)
    else:
        print("</tr>", file=f)
        print("<tr><td></td><td></td><td></td><td></td></tr>", file=f)
    for ctx in sorted(n.state.ctxbag.keys(), key=lambda x: x.nametag()):
        htmlrow(ctx, n.state.ctxbag, n, code, scope, f, verbose)
    for ctx in sorted(n.state.stopbag.keys(), key=lambda x: x.nametag()):
        htmlrow(ctx, n.state.stopbag, n, code, scope, f, verbose)

    print("</table>", file=f)
    print("</div>", file=f);
    print("</div>", file=f);

def htmlcode(code, scope, f):
    print("<div id='table-wrapper'>", file=f)
    print("<div id='table-scroll'>", file=f)
    print("<table border='1'>", file=f)
    print("<tbody>", file=f)
    lastloc = None
    for pc in range(len(code)):
        print("<tr>", file=f)
        if scope.locations.get(pc) != None:
            (file, line) = scope.locations[pc]
            if (file, line) != lastloc:
                lines = files.get(file)
                if lines != None and line <= len(lines):
                    print("<th colspan='3' align='left' style='background-color: yellow'>%s:%d"%(html.escape(os.path.basename(file)), line),
                        html.escape(lines[line - 1]), "</th>", file=f)
                else:
                    print("<th colspan='2' align='left'>Line", line, "</th>", file=f)
                print("</tr><tr>", file=f)
            lastloc = (file, line)
        print("<td><a name='P%d'>"%pc, pc, "</a></td><td>", file=f)
        print("<span title='%s'>"%html.escape(code[pc].explain()), file=f)
        if isinstance(code[pc], JumpOp) or isinstance(code[pc], JumpCondOp):
            print("<a href='#P%d'>"%code[pc].pc, code[pc], "</a>", file=f)
        elif isinstance(code[pc], PushOp) and isinstance(code[pc].constant[0], PcValue):
            print("Push <a href='#P%d'>"%code[pc].constant[0].pc, strValue(code[pc].constant[0]), "</a>", file=f)
        else:
            print(html.escape(str(code[pc])), file=f)
        print("</span></td></tr>", file=f)
    print("</tbody>", file=f)
    print("</table>", file=f)
    print("</div>", file=f)
    print("</div>", file=f)

def htmldump(nodes, code, scope, node, fulldump, verbose):
    with open("harmony.html", "w") as f:
        print("""
<html>
  <head>
    <style>
#table-wrapper {
  position:relative;
}
#table-scroll {
  height:200px;
  overflow:auto;  
}
#table-wrapper table {
  width:100%;
}
#table-wrapper table * {
  color:black;
}
#table-wrapper table thead th .text {
  position:absolute;   
  top:-20px;
  z-index:2;
  height:20px;
  width:35%;
  border:1px solid red;
}
table {
    border-collapse: collapse;
    border-style: hidden;
}
table td, table th {
    border: 1px solid black;
}
    </style>
  </head>
  <body>
        """, file=f)

        print("<table>", file=f)
        print("<col style='width:50%'>", file=f)
        print("<col style='width:50%'>", file=f)

        if node != None:
            print("<tr><td colspan='2'>", file=f)
            height = htmlpath(node, "red", f)
            print("</td></tr>", file=f)
            print("<tr><td></td></tr>", file=f)

        print("<tr>", file=f)

        print("<td valign='top'>", file=f)
        htmlcode(code, scope, f)
        print("</td>", file=f)

        print("<td valign='top'>", file=f)
        if fulldump:
            for n in nodes:
                htmlnode(n, code, scope, f, verbose)
        else:
            if node == None:
                cnt = 0
                for n in nodes:
                    htmlnode(n, code, scope, f, verbose)
                    cnt += 1
                    if not fulldump and cnt > 100:
                        break
            else:
                n = node
                while n != None:
                    htmlnode(n, code, scope, f, verbose)
                    n = n.parent
        print("</td>", file=f)
        print("</tr>", file=f)
        print("</table>", file=f)

        if node == None:
            row = 0
            sid = 1
        else:
            row = node.len + height + 1
            sid = node.uid
        print(
            """
                <div id='divNone' style='display:none';>
                  <div class='container'>
                    <p>
                        State information not available.
                        Use harmony -d for a complete htmldump.
                    </p>
                  </div>
                </div>

                <script>
                  var current = 1;

                  function show(id) {
                      x = document.getElementById('div' + current);
                      if (x == null) {
                          x = document.getElementById('divNone')
                      }
                      x.style.display = 'none';
                      x = document.getElementById('div' + id)
                      if (x == null) {
                          x = document.getElementById('divNone')
                      }
                      x.style.display = 'block';
                      current = id;
                  }

                  function rowshow(row, id) {
                    show(id);
                    var tbl = document.getElementById("issuestbl");
                    for (var i = 1; i < tbl.rows.length; i++) {
                        if (i == row + 1) {
                            tbl.rows[i].style.backgroundColor = "#A5FF33";
                        }
                        else {
                            tbl.rows[i].style.backgroundColor = "";
                        }
                    }
                  }

                  function setrow(tblid, row) {
                    var tbl = document.getElementById('loc' + tblid);
                    for (var i = 0; i < tbl.rows.length; i++) {
                        var div = document.getElementById('vars' + tblid + '_' + i);
                        if (i == row) {
                            tbl.rows[i].style.backgroundColor = "#A5FF33";
                            div.style.display = 'block';
                        }
                        else {
                            tbl.rows[i].style.backgroundColor = "";
                            div.style.display = 'none';
                        }
                    }
                  }

                  rowshow(%d, %d)
                </script>
            """%(row, sid), file=f)
        print("</body>", file=f)
        print("</html>", file=f)
    print("open file://" + os.getcwd() + "/harmony.html for more information")

def dumpCode(printCode, code, scope, f=sys.stdout):
    lastloc = None
    if printCode == "json":
        print("{", file=f);
        print('  "labels": {', file=f);
        for (k, v) in scope.labels.items():
            print('    "%s": "%d",'%(k, v), file=f)
        print('    "__end__": "%d"'%len(code), file=f)
        print('  },', file=f);
        print('  "code": [', file=f);
    for pc in range(len(code)):
        if printCode == "verbose":
            if scope.locations.get(pc) != None:
                (file, line) = scope.locations[pc]
                if (file, line) != lastloc:
                    lines = files.get(file)
                    if lines != None and line <= len(lines):
                        print("%s:%d"%(file, line), lines[line - 1], file=f)
                    else:
                        print(file, ":", line, file=f)
                lastloc = (file, line)
            print("  ", pc, code[pc], file=f)
        elif printCode == "json":
            if pc < len(code) - 1:
                print("    %s,"%code[pc].jdump(), file=f)
            else:
                print("    %s"%code[pc].jdump(), file=f)
        else:
            print(code[pc], file=f)
    if printCode == "json":
        print("  ],", file=f);
        print('  "pretty": [', file=f)
        for pc in range(len(code)):
            if pc < len(code) - 1:
                print('    ["%s","%s"],'%(code[pc], code[pc].explain()), file=f)
            else:
                print('    ["%s","%s"]'%(code[pc], code[pc].explain()), file=f)
        print("  ],", file=f);
        print("  \"locations\": {", file=f, end="");
        firstTime = True
        for pc, (file, line) in scope.locations.items():
            if firstTime:
                firstTime = False
                print(file=f)
            else:
                print(",", file=f)
            print("    \"%d\": { \"file\": \"%s\", \"line\": \"%d\", \"code\": %s }"%(pc, file, line, json.dumps(files[file][line-1])), file=f, end="")
        print(file=f)
        print("  }", file=f);
        print("}", file=f);

config = {
    "infile": "$$home$$/.charm.c",
    "outfile": "$$home$$/.charm.exe",
    "compile": "gcc -O3 -std=c99 $$infile$$ -m64 -o $$outfile$$"
}

def usage():
    print("Usage: harmony [options] harmony-file ...")
    print("  options: ")
    print("    -a: list machine code")
    print("    -c name=value: define a constant")
    print("    -d: htmldump full state into html file")
    print("    -f: run with internal model checker (not supported)")
    print("    -h: help")
    print("    -m module=version: select a module version")
    print("    -s: silent (do not print periodic status updates)")
    print("    -v: print version number")
    exit(1)

def main():
    global silent

    # Get options.  First set default values
    consts = []
    mods = []
    printCode = None
    blockflag = False
    charmflag = True
    fulldump = False
    testflag = False
    suppressOutput = False
    charmoptions = []
    try:
        opts, args = getopt.getopt(sys.argv[1:], "Aabc:dfhjm:stv",
                ["const=", "cf=", "help", "module=", "suppress", "version"])
    except getopt.GetoptError as err:
        print(str(err))
        usage()
    for o, a in opts:
        if o == "-a":
            printCode = "verbose"
            charmflag = False
        elif o == "--cf":
            charmoptions += [a]
        elif o == "-A":
            printCode = "terse"
            charmflag = False
        elif o == "-j":
            printCode = "json"
            charmflag = False
        elif o == "-f":
            charmflag = False
        elif o == "-b":
            blockflag = True
        elif o in { "-c", "--const" }:
            consts.append(a)
        elif o == "-d":
            fulldump = True
        elif o in { "-m", "--module" }:
            mods.append(a)
        elif o == "-s":
            silent = True
        elif o == "-t":
            testflag = True
        elif o in { "-h", "--help" }:
            usage()
        elif o == "--suppress":
            suppressOutput = True
        elif o in { "-v", "--version" }:
            print("Version", ".".join([str(v) for v in version]))
            sys.exit(0)
        else:
            assert False, "unhandled option"

    (code, scope) = doCompile(args, consts, mods)

    if charmflag:
        # see if there is a configuration file
        global config
        conffile = "%s/.harmony.json"%pathlib.Path.home()
        if os.path.exists(conffile):
            with open(conffile) as f:
                config = json.load(f)
        else:
            config["infile"] = "%s/.charm.c"%pathlib.Path.home()
            config["outfile"] = "%s/.charm.exe"%pathlib.Path.home()
            config["compile"] = "gcc -O3 -std=c99 %s -m64 -o %s"%(config["infile"], config["outfile"])
        if testflag:
            tmpfile = "harmony.json"
        else:
            fd, tmpfile = tempfile.mkstemp(".json", prefix="harmony", text=True)
            os.close(fd)
        with open(tmpfile, "w") as fd:
            dumpCode("json", code, scope, f=fd)
        path = pathlib.Path(config["outfile"])
        rebuild = testflag or not path.exists()
        if not rebuild:
            st = path.stat()
            now = time.time()
            if now - st.st_mtime > 15 * 60:
                rebuild = True
        if rebuild:
            with open(config["infile"], "w") as fd:
                if not testflag:
                    print("#define NDEBUG", file=fd)
                print("#define HARMONY_COMBINE", file=fd)
                print(charm_src, file=fd)
            if testflag:
                # if os.name == "nt":
                #     r = os.system("cl %s /link /out:%s"%(config["infile"], config["outfile"]))
                # else:
                    r = os.system("gcc -g -std=c99 %s -m64 -o %s"%(config["infile"], config["outfile"]))
            else:
                # if os.name == "nt":
                #     r = os.system("cl %s /link /out:%s"%(config["infile"], config["outfile"]))
                # else:
                    r = os.system(config["compile"]);
            if r != 0:
                print("can't create charm model checker")
                sys.exit(r);
        r = os.system("%s %s %s"%(config["outfile"], " ".join(charmoptions), tmpfile));
        if not testflag:
            os.remove(tmpfile)
        if r != 0:
            print("charm model checker failed")
            sys.exit(r);
        b = Brief()
        if not b.run():
            gh = GenHTML()
            gh.run()
            if not suppressOutput:
                print("open file://" + os.getcwd() + "/harmony.html for more information")
        sys.exit(0);

    if printCode == None:
        (nodes, bad_node) = run(code, scope.labels, blockflag)
        if bad_node != None:
            if not silent:
                htmldump(nodes, code, scope, bad_node, fulldump, False)
            sys.exit(1)
    else:
        dumpCode(printCode, code, scope)

if __name__ == "__main__":
    main()
++++++
