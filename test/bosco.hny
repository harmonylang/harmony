import synch;

const N = 4;
const F = 1;
const NROUNDS = 2;

network = {};
decisions = {};
done = [False,] * N;

def broadcast(msg):
    atomic:
        network |= {msg};
    ;
;
def process(self, proposal):
    let est = proposal:
        for round in {0..NROUNDS-1}:
            # Broadcast estimate
            broadcast(self, round, est);

            # Handle received messages
            let received = {}:
                # Receive messages until there are enough
                while len(received) < (N - F):
                    let eligible = { (p,r,e) for (p,r,e) in (network - received)
                                            such that r == round }:
                        if len(eligible) > 0:
                            received |= {choose(eligible)};
                        ;
                    ;
                ;

                # Update estimate
                let ests = { e for (p,r,e) in received }
                let cnts = { (len({(p,x) for (p,r,x) in received
                                    such that x == e}), e) for e in ests }
                let (n, best) = max(cnts):
                    est = best;
                    # if n >= (N - F):
                    #     atomic:
                    #         decisions |= { best };
                    #     ;
                    # ;
                ;
            ;
        ;
    ;
    # done[self] = True;
;
def main():
    await all(done);
    assert len(decisions) <= 1;
;

let nzeroes = choose({0..N/2}):
    for i in {0..N-1}:
        spawn process(i, 0 if i < nzeroes else 1);
    ;
;
# spawn main();
