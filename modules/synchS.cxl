import list;

def Lock():
    result = dict{ .locked: False, .suspended: [] };
;
def lock(lk):
    atomic:
        if (^lk).locked:
            stop (^lk).suspended;
            assert (^lk).locked;
        else:
            (^lk).locked = True;
        ;
    ;
;
def unlock(lk):
    atomic:
        if (^lk).suspended == []:
            (^lk).locked = False;
        else:
            go (head((^lk).suspended)) ();
            (^lk).suspended = tail((^lk).suspended);
        ;
    ;
;
def Condition(lk):
    result = dict{ .lock: lk, .waiters: [] };
;
def wait(c):
    atomic:
        unlock((^c).lock);
        stop (^c).waiters;
    ;
;
def notify(c):
    atomic:
        let lk = (^c).lock, waiters = (^c).waiters:
            if waiters != []:
                (^lk).suspended = (^lk).suspended + [waiters[0],];
                (^c).waiters = tail(waiters);
            ;
        ;
    ;
;
def notifyAll(c):
    atomic:
        let lk = (^c).lock, waiters = (^c).waiters:
            (^lk).suspended = (^lk).suspended + waiters;
            (^c).waiters = [];
        ;
    ;
;
def Semaphore(cnt):
    result = dict{ .count: cnt, .waiters: [] };
;
def P(sema):
    atomic:
        if (^sema).count > 0:
            (^sema).count = (^sema).count - 1;
        else:
            stop (^sema).waiters;
        ;
    ;
;
def V(sema):
    atomic:
        let cnt = (^sema).count, waiters = (^sema).waiters:
            if waiters != []:
                assert cnt == 0;
                go (waiters[0]) ();
                (^sema).waiters = tail(waiters);
            else:
                (^sema).count = cnt + 1;
            ;
        ;
    ;
;
def Queue():
    result = dict{ list: [], waiters: [] };;
;
def dequeue(q):
    atomic:
        let list = ^q.list:
            if list == []:
                stop ^q.waiters;
            ;
            result = head(list);
            ^q.list = tail(list);
        ;
    ;
;
def enqueue(q, item):
    atomic:
        ^q.list = append(^q.list, item);
        let waiters = ^q.waiters:
            if waiters != []:
                go (waiters[0]) item;
                ^q.waiters = tail(waiters);
            ;
        ;
    ;
;
