# return s[b:e]
def subseq(s, b, e) returns result:
    result = [ s[x] for x in {b..e-1} ]

def append(s, e) returns result:
    result = s + [e,]

def head(s) returns result:
    result = s[0]

builtin tail "list$tail"
def tail(s) returns result:
    result = subseq(s, 1, len(s))

# sum of a list or set
def sum(a) returns accu:
    accu = 0
    for v in a:
        accu += v

# convert list (or values of a dict) to a set
def set(a) returns result:
    result = { v for v in a }

# convert set into a (sorted) list
def list(a) returns result:
    result = [ v for v in a ]

# convert values of a dictionary into a list
def values(d) returns result:
    result = [ v for _:v in d ]

# like Python .items()
def items(d) returns result:
    result = [ (k, v) for k:v in d ]

# quicksort of a list
def qsort(a) returns sorted:
    if a == []:
        sorted = []
    else:
        let (pivot, rest) = head(a), tail(a)
        let lower = [ v for v in rest where v < pivot ]
        let higher = [ v for v in rest where v >= pivot ]:
            sorted = qsort(lower) + [pivot,] + qsort(higher)

# like Python sorted()
def sorted(d) returns result:
    result = qsort(list(d))

# like Python reversed()
def reversed(d) returns result:
    let n = len(d):
        result = [ d[n-i] for i in { 1..n } ]

# like Python index()
def index(d, e) returns i:
    i = 0
    while d[i] != e:
        i += 1

# like Python startswith (only defined for strings)
def startswith(d, prefix) returns result:
    result = (len(prefix) <= len(d)) and all(d[i] == prefix[i] for i in { 0 .. len(prefix) - 1 })

# left fold.  Compute f(f(f(z, d[0]), d[1]), d[2] ...)
def foldl(d, f, z) returns result:
    result = z
    for e in d:
        result = f(result, e)

# right fold.  Compute f(d[0], f(d[1], ..., f(d[n-1], z)))
def foldr(d, f, z) returns result:
    result = z if len d == 0 else f(d[0], foldr(tail(d), f, z))

# Python functools reduce operator
def reduce(f, d, z) returns result:
    result = foldl(d, f, z)

# Return a permutation of set s
def permuted(s) returns perm:
    perm = []
    var c = s
    while c != {}:
        let e = choose c:
            perm += [ e, ]
            c -= { e }

# Return a list of elements satisfying the condition
def filter(cond, s) returns t:
    t = []
    for e in s where cond(e):
        t += [e,]
